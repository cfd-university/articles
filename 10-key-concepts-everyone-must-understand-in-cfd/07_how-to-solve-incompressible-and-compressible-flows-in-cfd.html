<!-- How to solve incompressible and compressible flows in CFD -->
<!-- https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-solve-incompressible-and-compressible-flows-in-cfd/ -->

<!-- wp:paragraph -->
<p>This article will take a deep dive into how to solve the Navier-Stokes equations numerically. We will look at the differences between compressible and incompressible flows and what solution algorithms exist to solve them. Along the way, we will also look at the difference between the conservative and primitive (or non-conservative) variable formulation. We will see (through an example and a derivation) why we really want to use conservative variables for compressible flows while primitive variables are preferred for incompressible flows.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And then, there is the scientific misconduct that no one is talking about; the SIMPLE algorithm. We will discuss the SIMPLE algoirithm, and its friends (SIMPLEC, PISO, PIMPLE), and why these really are just inferior and plagiarised description of the pressure projection method of Chorin. We will derive the equations from scratch, and by the end of the article, you will be able to see how all of these methods are one and the same. We have a wild journey ahead of us, did you bring a hot cup of tea? You will need it! Let's get going. </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading">In this series</h2>
<!-- /wp:heading -->

<!-- wp:shortcode -->
[custom_category_posts_list category_slug="10-key-concepts-everyone-must-understand-in-cfd"]
<!-- /wp:shortcode -->

<!-- wp:heading -->
<h2 class="wp-block-heading">In this article</h2>
<!-- /wp:heading -->

<!-- wp:aioseo/table-of-contents {"headings":[{"id":6,"blockClientId":"40917088-5836-4644-8e9e-b652605d735e","content":"Introduction","level":2,"anchor":"aioseo-introduction","order":0,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":24,"blockClientId":"3cb90536-8ae3-4f1d-ad84-b69cce361263","content":"Primitive vs. conserved variable formulations","level":2,"anchor":"aioseo-primitive-vs-conserved-variable-formulations","order":1,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":103,"blockClientId":"f660d6e6-d108-48d4-8cd6-fdb1376da576","content":"Compressible flows","level":2,"anchor":"aioseo-compressible-flows","order":2,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":178,"blockClientId":"c873d9bf-3e3e-46b6-bb1d-bc82b73b3903","content":"Incompressible flows","level":2,"anchor":"aioseo-incompressible-flows","order":3,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":213,"blockClientId":"33446043-09a8-4cfe-be45-593050c6a239","content":"Artificial Compressibility","level":3,"anchor":"aioseo-artificial-compressibility","order":4,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":295,"blockClientId":"c30c46d5-57ea-4e0d-afa6-3f8f2e122fd4","content":"Exact projection methods: The fractional step, pressure projection","level":3,"anchor":"aioseo-pressure-projection-based","order":5,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":379,"blockClientId":"55d0c7f0-4b62-42e5-a2e6-4e573277cfec","content":"Approximate projection methods: The SIMPLE method and its derivatives","level":3,"anchor":"aioseo-pressure-projection-based","order":6,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":538,"blockClientId":"066420ba-f12f-44c6-a031-d7bf748914f6","content":"How to go from the SIMPLE algorithm to the PISO algorithm","level":4,"anchor":"aioseo-how-to-go-from-the-simple-algorithm-to-the-piso-algorithm","order":7,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":549,"blockClientId":"9834272b-e01d-4fe3-aa0d-712fc5e55512","content":"Bonus: the PIMPLE algorithm","level":4,"anchor":"aioseo-bonus-the-pimple-algorithm","order":8,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":566,"blockClientId":"14ce4253-3277-4dbc-ba93-4ab12c20c78a","content":"The verdict","level":4,"anchor":"aioseo-the-verdict","order":9,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]}]},{"id":572,"blockClientId":"68611a09-bb24-4ec4-8c6c-580ee0724248","content":"Summary","level":2,"anchor":"aioseo-summary","order":10,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]} -->
<div class="wp-block-aioseo-table-of-contents"><ul><li><a href="#aioseo-introduction">Introduction</a></li><li><a href="#aioseo-primitive-vs-conserved-variable-formulations">Primitive vs. conserved variable formulations</a></li><li><a href="#aioseo-compressible-flows">Compressible flows</a></li><li><a href="#aioseo-incompressible-flows">Incompressible flows</a><ul><li><a href="#aioseo-artificial-compressibility">Artificial Compressibility</a></li><li><a href="#aioseo-pressure-projection-based">Exact projection methods: The fractional step, pressure projection</a></li><li><a href="#aioseo-pressure-projection-based">Approximate projection methods: The SIMPLE method and its derivatives</a><ul><li><a href="#aioseo-how-to-go-from-the-simple-algorithm-to-the-piso-algorithm">How to go from the SIMPLE algorithm to the PISO algorithm</a></li><li><a href="#aioseo-bonus-the-pimple-algorithm">Bonus: the PIMPLE algorithm</a></li><li><a href="#aioseo-the-verdict">The verdict</a></li></ul></li></ul></li><li><a href="#aioseo-summary">Summary</a></li></ul></div>
<!-- /wp:aioseo/table-of-contents -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-introduction">Introduction</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In our journey through key concepts in CFD, we have looked at <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-derive-the-navier-stokes-equations/" target="_blank" rel="noopener" title="">how to derive the Navier-Stokes equation</a>, <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-discretise-the-navier-stokes-equations/">how to discretise it</a>, <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/" target="_blank" rel="noopener" title="">how to use numerical schemes</a> to obtain unknown quantities, and <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-implement-boundary-conditions-in-cfd/" target="_blank" rel="noopener" title="">how to apply boundary conditions</a>. You might reasonably assume that this is it; we have all the concepts together, and we can start implementing these equations and start solving them. There is just one small problem: the Navier-Stokes equations are under-constrained.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What do I mean by that? Well, let's look at the equations. For the general Navier-Stokes equations, we have the following continuity or mass conservation equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho}{\partial t}+\nabla\cdot(\rho\mathbf{u})=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In this equation, we have the density [katex]\rho[/katex], as well as the velocity vector [katex]\mathbf{u}[/katex], which contains three velocity components [katex]u[/katex], [katex]v[/katex], and [katex]w[/katex] (or [katex]u_x[/katex], [katex]u_y[/katex], and [katex]u_z[/katex]). Thus, we have 4 unknowns in this equation. If we now also consider the conservation of momentum equation, we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\mathbf{u} + \nu\nabla(\nabla\cdot\mathbf{u}) - \frac{2}{3}\nu\nabla(\nabla\cdot\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This equation is solved for [katex]\mathbf{u}[/katex], so this equation needs to be solved for each velocity component [katex]u[/katex], [katex]v[/katex], and [katex]w[/katex]. Great, now we have 3 additional equations, and together with the continuity equation, we have now 4 equations. But, we also have introduced the pressure gradient, and thus the pressure [katex]p[/katex] is another quantity we don't know. So even if we now have 4 equations, we have a total of 5 unknowns at this point, that is, the density [katex]\rho[/katex], the velocity components [katex]u[/katex], [katex]v[/katex], and [katex]w[/katex], and the pressure [katex]p[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, we need to figure out an additional equation that ties all of these variables together in some way. And this is what we will discuss in the article today. The Navier-Stokes equations can't be solved as they are, and we need to augment them with some equations to get a solution. We also saw in the article on <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/" target="_blank" rel="noopener" title="">what are hyperbolic, parabolic, and elliptic flows</a>, that the flow fundamentally changes whether we deal with subsonic or supersonic flows. That is, if the Mach number is below or above one, respectively.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If the character changes, then it stands to reason that the underlying equations also have to adapt accordingly. Thus, we have to find now two separate types of equations. The way that we do that in fluid dynamics is by considering the change in density. The following image shows how much the density changes for air as a function of the Mach number.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5190,"width":"500px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="https://cfd.university/wp-content/uploads/2025/04/density-variation-with-mach-number.jpg" alt="" class="wp-image-5190" style="width:500px"/><figcaption class="wp-element-caption">Reproduced from <a href="https://www.researchgate.net/figure/Changes-in-density-r-with-increasing-fluid-velocity-in-terms-of-Mach-number-for-dry_fig3_349771873" target="_blank" rel="noopener" title="">ResearchGate</a></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Thus, for flows which have a maximum Mach number below [katex]Ma&lt;0.3[/katex], we can see that the density changes by at most 5%. We simplify this and say that the density does not change below a Mach number of [katex]Ma&lt;0.3[/katex]. This is our demarcation. Anything to the left of [katex]Ma&lt;0.3[/katex] is treated as an incompressible flow, and anything to the right is treated as a compressible flow.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can generalise this and say that an incompressible flow is one in which the density does not change, while the density is allowed to change for compressible flows. This definition is independent of the Mach number, but the previous figure nicely demonstrates this for air.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can formalise this with a property called the compressibility [katex]\beta[/katex], and this is given as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\beta=-\frac{1}{V}\frac{\partial V}{\partial p}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]V[/katex] is the volume and [katex]p[/katex] is the pressure. Thus, we measure how much the volume changes as a result of increasing the pressure. If you take a softball and you apply pressure, for example, you place it between your hands and you squeeze it, it will get smaller (its volume will decrease). So, we see that the gradient [katex]\partial V/\partial p[/katex] must be negative. We normalise this by the volume itself, and we multiply this by [katex]-1[/katex] so that our compressibility factor [katex]\beta[/katex] is positive.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we look at materials such as water, we have [katex]\beta\approx 4.6\cdot 10^{-10}[/katex] at room temperature. Compare that to air, which has [katex]\beta\approx 1[/katex] at room temperature. A material with a low compressibility will not show any compressible effects, while a material with high compressibility will exhibit compressible effects.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As a result, water, for example, will essentially behave like an incompressible fluid. If we tried to simulate water with a compressible solver, we would see painfully slow convergence. This is because a compressible solver, as we will see, requires density changes to update the remaining flow variables. If the compressibility is low, the density changes are slow, and thus convergence is slow. An incompressible solver ignores density changes and thus is able to converge much faster at low Mach numbers (or flows with little to no density changes).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There is one main modelling difference between compressible and incompressible flows, and that is how variables are written in our derivatives. We distinguish between primitive and conserved variable formulations, and because this is another topic not getting the attention in the literature it deserves, we'll need to talk about this topic first before we can look at the different techniques to solve compressible and incompressible flows.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-primitive-vs-conserved-variable-formulations">Primitive vs. conserved variable formulations</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>To see the difference between the primitive and conservative variable formulation, let's start by looking at the momentum equation of the Navier-Stokes equations. We have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\mathbf{u} + \nu\nabla(\nabla\cdot\mathbf{u}) - \frac{2}{3}\nu\nabla(\nabla\cdot\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, we simplify this equation and say that we have an inviscid fluid (that is, [katex]\nu=0[/katex]), and we also do not consider the pressure. This means the entire right-hand side goes to zero, and we are left with:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = 0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we now assume a one-dimensional flow, then we are left with only the velocity component in the x direction. This can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial u}{\partial t} + u\frac{\partial u}{\partial x} = 0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This equation is known as the Burgers equation, named after the Dutch physicist Johannes Martinus Burgers, and it is an important model equation in CFD. It allows us to study how numerical schemes behave to non-linearities, as the second term is fully non-linear. We could create a linear equation out of this by saying that the [katex]u[/katex] in front of the space derivative is a constant and set [katex]u=a[/katex]. If we were to do that, then we have obtained the linear advection equation, which is another important model equation in CFD.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The Burgers equation above is written in non-conservative, or primitive variable, form. The primitive variables are the ones we are solving for. In this case, the Burgers equation is solving for the variable [katex]u[/katex] as indicated in the time derivative, but we also see that all other derivatives (in this case, just one, i.e. the second term with the spatial derivative) evaluating derivatives of [katex]u[/katex]. When all derivatives solve for the same variable, we say the equation is written in primitive variable formulation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The origin of why we call them primitive variables comes from various directions, but the first reported source is from a 1921 paper by Bjerknes (“The Meteorology of the Temperate Zone and the General Atmospheric CIRCULATION. 1.”&nbsp;<em>Monthly Weather Review</em>&nbsp;49, no. 1 (1921): 1-3) where he was using primitive equations to solve meteorological equations. Back in 1921, CFD was not an established field and much of what would later form the body of CFD was developed by meteorologists.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What happens if we write the spatial derivative in the Burgers equation, i.e. [katex]u(\partial u/\partial x)[/katex] as a fully non-linear derivative, i.e. [katex]\partial uu/\partial x=\partial u^2/\partial x[/katex]? Well, let's see. The product rule of differentiation tells us that the derivative of a product can be expressed as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial ab}{\partial x}=a\frac{\partial b}{\partial x}+b\frac{\partial a}{\partial x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In our case, both [katex]a[/katex] and [katex]b[/katex] are equal to [katex]u[/katex], so we would have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial uu}{\partial x}=\frac{\partial u^2}{\partial x}=u\frac{\partial u}{\partial x}+u\frac{\partial u}{\partial x}=2u\frac{\partial u}{\partial x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>So we can't simply write [katex]u(\partial u/\partial x)=\partial u^2/\partial x[/katex], this would be missing a factor of two. Instead, we have to divide the equation by this factor of two, which would result in the following equality:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{2}\frac{\partial u^2}{\partial x}=u\frac{\partial u}{\partial x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can now change the spatial derivative in our Burgers equation and arrive at:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial u}{\partial t}+\frac{1}{2}\frac{\partial u^2}{\partial x}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we have the velocity component [katex]u[/katex] in the time derivative, that is the primitive variable we are solving for, and we have [katex]u^2[/katex] in the derivative. The derivative is not multiplied by any other variable. Instead, it contains all variables in the derivative. We could say it has conserved all variables. Therefore, we call this approach the conserved variable approach.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This becomes even more clear when we consider the Navier-Stokes equation again. This was given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\mathbf{u} + \nu\nabla(\nabla\cdot\mathbf{u}) - \frac{2}{3}\nu\nabla(\nabla\cdot\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This equation is given in primitive variable or non-conservative form. Let's write this equation in conservative form. First, let's multiply by the density. This results in</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\rho\frac{\partial \mathbf{u}}{\partial t} + (\rho\mathbf{u}\cdot\nabla)\mathbf{u} = -\nabla p + \mu\nabla^2\mathbf{u} + \mu\nabla(\nabla\cdot\mathbf{u}) - \frac{2}{3}\mu\nabla(\nabla\cdot\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, we are using the fact that [katex]\nu=\mu/\rho[/katex]. We can use the same product rule to write the time derivative in conservative form:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho\mathbf{u}}{\partial t}=\rho\frac{\partial \mathbf{u}}{\partial t}+\mathbf{u}\frac{\partial \rho}{\partial t}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The continuity equation is given as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho}{\partial t}+\nabla\cdot (\rho\mathbf{u})=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can solve this for the time derivative and then insert in the above equation, which provides:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho\mathbf{u}}{\partial t}=\rho\frac{\partial \mathbf{u}}{\partial t}+\mathbf{u}\left[-\nabla\cdot (\rho\mathbf{u})\right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we solve this for the first derivative on the right-hand side, we obtain:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\rho\frac{\partial \mathbf{u}}{\partial t} =\frac{\partial \rho\mathbf{u}}{\partial t}+\mathbf{u}\nabla\cdot (\rho\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Inserting this into our Navier-Stokes equations, we obtain:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho\mathbf{u}}{\partial t}+\mathbf{u}\nabla\cdot (\rho\mathbf{u}) + (\rho\mathbf{u}\cdot\nabla)\mathbf{u} = -\nabla p + \mu\nabla^2\mathbf{u} + \mu\nabla(\nabla\cdot\mathbf{u}) - \frac{2}{3}\mu\nabla(\nabla\cdot\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, let's investigate the second and third terms on the left-hand side. If we set [katex]a=\rho\mathbf{u}[/katex] and [katex]b=\mathbf{u}[/katex], then we have</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{u}\nabla\cdot (\rho\mathbf{u}) + (\rho\mathbf{u}\cdot\nabla)\mathbf{u}=\mathbf{b}\nabla\cdot \mathbf{a} + (\mathbf{a}\cdot\nabla)\mathbf{b}=\nabla\cdot(\mathbf{a}\otimes \mathbf{b})=\nabla\cdot(\rho\mathbf{u}\otimes\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The additional term from the time derivative, after writing this term in conservative form, combines with the non-linear term. We can write this non-conservative form, i.e. [katex](\rho\mathbf{u}\cdot\nabla)\mathbf{u}[/katex] in conservative from, i.e. [katex]\nabla\cdot(\rho\mathbf{u}\otimes\mathbf{u})[/katex] with the help of this additional term.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, our final Navier-Stokes equation can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho\mathbf{u}}{\partial t} + \nabla\cdot (\rho\mathbf{u}\otimes\mathbf{u}) = -\nabla p + \mu\nabla^2\mathbf{u} + \mu\nabla(\nabla\cdot\mathbf{u}) - \frac{2}{3}\mu\nabla(\nabla\cdot\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, let's inspect the time derivative. We are no longer simply solving for the primitive variable [katex]\mathbf{u}[/katex], but instead we solve now for [katex]\rho\mathbf{u}[/katex]. This is the momentum, and the equation above is the conservation law for momentum. As a result, we call the above formulation the conserved variable approach, where we now solve for the quantity that is being conserved (here, the momentum) through the conservation law.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The next question that you will be asking is, which of these forms is to be preferred? Well, let's return to the Burgers equation, and let's discretise this equation with a first-order upwind scheme using the finite difference method (we'll assume the velocities are always positive, which makes our discussion easier to follow). Then, both conservative and non-conservative (primitive variable) formulations result in:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Conservative form</strong>:</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{u^{n+1}_i-u^n_i}{\Delta t}+\left[\frac{u^2_i-u^2_{i-1}}{\Delta x}\right]^n=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Primitive variable form</strong>:</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{u^{n+1}_i-u^n_i}{\Delta t}+u^n_i\frac{u^n_i-u^n_{i-1}}{\Delta x}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's see how both of them compare. We will solve them on a domain that is going from 0 to 1, and we will test this equation for two separate initial conditions. The first one is a smooth profile, where we use a sine wave that has exactly one period between 0 and 1. The animation of this simulation is shown below:</p>
<!-- /wp:paragraph -->

<!-- wp:video {"id":5194} -->
<figure class="wp-block-video"><video controls src="https://cfd.university/wp-content/uploads/2025/04/continuous.mp4"></video></figure>
<!-- /wp:video -->

<!-- wp:paragraph -->
<p>As you can see, there are some slight differences between both formulations, but overall, they give the same result. If anything, the conservative formulation has a slightly better resolution near the discontinuity once that forms. So, for smooth profiles, either the conservative or non-conservative approach works well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Note that the above velocity profile contains negative velocities, so our discretisation will not work here. To ensure we have only positive velocities, we either have to shift the initial data so that all values of [katex]u[/katex] are positive or use backward differencing if the velocities are negative. I have used the following (Python-based) discretisation to obtain the plot above:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"# conservative\nif u_old[i] \u003e= 0.0:\n  u[i] = old_u[i] - dt * 0.5 * (pow(old_u[i], 2) - pow(old_u[i-1], 2))/dx\nelse:\n  u[i] = old_u[i] - dt * 0.5 * (pow(old_u[i+1], 2) - pow(old_u[i], 2))/dx\n  \n# non-conservative (primitive variable approach)\nif old_u[i] \u003e= 0.0:\n  u[i] = old_u[i] - dt * old_u[i] * (old_u[i] - old_u[i-1])/dx\nelse:\n  u[i] = old_u[i] - dt * old_u[i] * (old_u[i+1] - old_u[i])/dx","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# conservative\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e u_old[i] \u0026gt;= \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  u[i] = old_u[i] - dt * \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.5\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(old_u[i], \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) - \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(old_u[i-\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e], \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e))/dx\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eelse\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  u[i] = old_u[i] - dt * \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.5\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(old_u[i+\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e], \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) - \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(old_u[i], \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e))/dx\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# non-conservative (primitive variable approach)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e old_u[i] \u0026gt;= \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  u[i] = old_u[i] - dt * old_u[i] * (old_u[i] - old_u[i-\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e])/dx\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eelse\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  u[i] = old_u[i] - dt * old_u[i] * (old_u[i+\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e] - old_u[i])/dx\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"python","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":11,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="# conservative
if u_old[i] &gt;= 0.0:
  u[i] = old_u[i] - dt * 0.5 * (pow(old_u[i], 2) - pow(old_u[i-1], 2))/dx
else:
  u[i] = old_u[i] - dt * 0.5 * (pow(old_u[i+1], 2) - pow(old_u[i], 2))/dx
  
# non-conservative (primitive variable approach)
if old_u[i] &gt;= 0.0:
  u[i] = old_u[i] - dt * old_u[i] * (old_u[i] - old_u[i-1])/dx
else:
  u[i] = old_u[i] - dt * old_u[i] * (old_u[i+1] - old_u[i])/dx" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #6A9955"># conservative</span></span>
<span class="line"><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> u_old[i] &gt;= </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">:</span></span>
<span class="line"><span style="color: #D4D4D4">  u[i] = old_u[i] - dt * </span><span style="color: #B5CEA8">0.5</span><span style="color: #D4D4D4"> * (</span><span style="color: #DCDCAA">pow</span><span style="color: #D4D4D4">(old_u[i], </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4">) - </span><span style="color: #DCDCAA">pow</span><span style="color: #D4D4D4">(old_u[i-</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">], </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4">))/dx</span></span>
<span class="line"><span style="color: #C586C0">else</span><span style="color: #D4D4D4">:</span></span>
<span class="line"><span style="color: #D4D4D4">  u[i] = old_u[i] - dt * </span><span style="color: #B5CEA8">0.5</span><span style="color: #D4D4D4"> * (</span><span style="color: #DCDCAA">pow</span><span style="color: #D4D4D4">(old_u[i+</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">], </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4">) - </span><span style="color: #DCDCAA">pow</span><span style="color: #D4D4D4">(old_u[i], </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4">))/dx</span></span>
<span class="line"><span style="color: #D4D4D4">  </span></span>
<span class="line"><span style="color: #6A9955"># non-conservative (primitive variable approach)</span></span>
<span class="line"><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> old_u[i] &gt;= </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">:</span></span>
<span class="line"><span style="color: #D4D4D4">  u[i] = old_u[i] - dt * old_u[i] * (old_u[i] - old_u[i-</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">])/dx</span></span>
<span class="line"><span style="color: #C586C0">else</span><span style="color: #D4D4D4">:</span></span>
<span class="line"><span style="color: #D4D4D4">  u[i] = old_u[i] - dt * old_u[i] * (old_u[i+</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">] - old_u[i])/dx</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>But let's see what happens if we are dealing with discontinuities. We consider an initial profile that is 1 between 0 and 0.25 and 0 everywhere else. Let's look at the comparison of the primitive and conserved variable formulation:</p>
<!-- /wp:paragraph -->

<!-- wp:video {"id":5195} -->
<figure class="wp-block-video"><video controls src="https://cfd.university/wp-content/uploads/2025/04/discontinuous.mp4"></video></figure>
<!-- /wp:video -->

<!-- wp:paragraph -->
<p>This is the correct solution and not a programming error! If you want to have a mathematical derivation, the <a href="https://cfd.university/blog/how-to-get-started-with-computational-fluid-dynamics-cfd/#aioseo-compressible-flows" target="_blank" rel="noopener" title="">book by LeVeque</a> has some more detail, but let me give you an intuitive description. Let's look at what happens around the x location of [katex]x=0.25[/katex] at the first time step. This is schematically shown below:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5197,"width":"600px","sizeSlug":"large","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://cfd.university/wp-content/uploads/2025/04/initial_data_discontinuity-1024x535.png" alt="" class="wp-image-5197" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Let's say we are currently at location [katex]i[/katex], that is, all values before are set to [katex]u=1[/katex] and all values to the right are set to [katex]u=0[/katex], including the node we are currently at. This means we have [katex]u_{i-1}=1[/katex], [katex]u_i=0[/katex], and [katex]u_{i+1}=0[/katex]. Now let's insert that into our spatial derivative for both the conservative and non-conservative (primitive variable) formulation. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Conservative form</strong>:</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial u^2}{\partial x}\approx\frac{u_i^2-u_{i-1}^2}{\Delta x}=\frac{0^2-1^2}{\Delta x}=-\frac{1}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Non-conservative (primitive variable) form</strong>:</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u\frac{\partial u}{\partial x}\approx u_i\frac{u_i-u_{i-1}}{\Delta x}=0\cdot\frac{0-1}{\Delta x}=0\cdot \frac{-1}{\Delta x}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We are getting very different results near the discontinuity! In this case, the conservative formulation produces the correct physical behaviour, and, as a result, it is the preferred formulation for compressible flows. This ensures that when we deal with discontinuities, we are capturing them without problems. This doesn't mean we can't use the primitive variable formulation for compressible flows (we can, and people do), but we may need to take extra steps to ensure discontinuities are resolved.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, from this discussion, it is clear that the conservative form is preferred for compressible flows. But what about incompressible flows? Let's take a look. Let's write the Navier-Stokes equations out again. We have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\mathbf{u} + \nu\nabla(\nabla\cdot\mathbf{u}) - \frac{2}{3}\nu\nabla(\nabla\cdot\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We also have the continuity equation given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\nabla \cdot\mathbf{u}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can use this to eliminate the last two terms in the momentum equation, which results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's multiply by the density first, this results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\rho\frac{\partial \mathbf{u}}{\partial t} + (\rho\mathbf{u}\cdot\nabla)\mathbf{u} = -\nabla p + \mu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can now write the time derivative again in conservative form, this results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho \mathbf{u}}{\partial t}=\rho\frac{\partial\mathbf{u}}{\partial t}+\mathbf{u}\frac{\partial \rho}{\partial t}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>An incompressible flow is one in which the density does not change. In other words, the density is constant and thus, the derivative of the density must be zero, both in space and time. This means we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho \mathbf{u}}{\partial t}=\rho\frac{\partial\mathbf{u}}{\partial t}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can switch between both conserved and primitive variable formulation without incurring additional terms, thanks to the continuity equation. What about the non-linear term? Well, we saw before that we can write:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{u}\nabla\cdot (\rho\mathbf{u}) + (\rho\mathbf{u}\cdot\nabla)\mathbf{u}=\nabla\cdot(\rho\mathbf{u}\otimes\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>But we can use the continuity equation again here to eliminate the first term ([katex]\nabla\cdot (\rho\mathbf{u})=0[/katex]). This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>(\rho\mathbf{u}\cdot\nabla)\mathbf{u}=\nabla\cdot(\rho\mathbf{u}\otimes\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Again, we see that both the conserved variable and primitive variable form are equivalent in a mathematical sense. If we further consider that our flow is typically smooth and does not have any discontinuities (they do exist in some cases, for example, at interfaces between two different fluids), then using the primitive variable formulation makes it easier to work with the equations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While some researchers have successfully used the conservative variable formulation for incompressible flows, most solvers make use of the primitive variable formulation, i.e. the opposite of what compressible solvers are doing. For this reason, it seems to me that people generally split into either incompressible or compressible flows in terms of their specialisation (rarely both), as the mathematical and numerical treatment is slightly different for both.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Hopefully, you now have a much better idea of why we have primitive and conserved variables, what their mathematical difference are and how that manifests itself in the solution. I have always looked for a clear description on that when I was a student and could not find a good definition, hopefully this will have helped you in clearing this up.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now that we have discussed the differences let us continue in our discussion and see how we solve the compressible Navier-Stokes equations next.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-compressible-flows">Compressible flows</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>As discussed in the previous section, the compressible form of the Navier-Stokes equation is most commonly solved in the conservative form, though some prefer to <a href="https://wjrider.wordpress.com/2016/08/08/the-benefits-of-using-primitive-variables/" target="_blank" rel="noopener" title="">solve it with primitive variables</a> instead. In this section, we will stick with the convention and look at the conservative form.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The conservation of mass, or continuity equation, for a compressible flow is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho}{\partial t}+\nabla\cdot(\rho\mathbf{u})=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We derived the compressible form of the Navier-Stokes equations in a <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-derive-the-navier-stokes-equations/" target="_blank" rel="noopener" title="">previous article</a>, which is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\mathbf{u} + \nu\nabla(\nabla\cdot\mathbf{u}) - \frac{2}{3}\nu\nabla(\nabla\cdot\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We also saw in the previous section that we can multiply it by the density and then rewrite it in conservative form. This is then given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho\mathbf{u}}{\partial t} + \nabla\cdot (\rho\mathbf{u}\otimes\mathbf{u}) = -\nabla p + \mu\nabla^2\mathbf{u} + \mu\nabla(\nabla\cdot\mathbf{u}) - \frac{2}{3}\mu\nabla(\nabla\cdot\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>And finally, we need to look at the energy equation. We have not yet derived it in any previous article, and doing so would probably warrant its own article. We'll use the end result here and likely return to its derivation in a future article. For now, we consider the following equation for the conservation of total energy:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho E}{\partial t}+\nabla\cdot[(\rho E + p)\mathbf{u}]=\mathbf{u} \cdot \left[\mu\nabla^2\mathbf{u} + \mu\nabla(\nabla\cdot\mathbf{u})-\frac{2}{3}\mu\nabla(\nabla\cdot\mathbf{u})\right]-\nabla\cdot\kappa\nabla T</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Both the momentum and energy equation contain the viscous stresses. These can be identified as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\nabla\cdot\tau=\mu\nabla^2\mathbf{u} + \mu\nabla(\nabla\cdot\mathbf{u})-\frac{2}{3}\mu\nabla(\nabla\cdot\mathbf{u})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]\tau[/katex] is the viscous stress tensor. With these equations now written out in full, we can now write out the scalar form of each equation, which we will need to solve in a CFD solver. These are given as follows:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Conservation of mass</strong> (continuity equation):</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho}{\partial t} +\frac{\partial \rho u}{\partial x} +\frac{\partial \rho v}{\partial y} +\frac{\partial \rho w}{\partial z}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Conservation of x-momentum</strong>:</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho u}{\partial t} + \frac{\partial (\rho u^2 + p)}{\partial x} + \frac{\partial \rho u v}{\partial y} + \frac{\partial \rho u w}{\partial z} = \frac{\partial \tau_{xx}}{\partial x} + \frac{\partial \tau_{yx}}{\partial y} + \frac{\partial \tau_{zx}}{\partial z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Conservation of y-momentum</strong>:</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial\rho v}{\partial t} + \frac{\partial \rho u v}{\partial x}  + \frac{\partial (\rho v^2 + p)}{\partial y}  + \frac{\partial \rho v w}{\partial z} = \frac{\partial \tau_{xy}}{\partial x} + \frac{\partial \tau_{yy}}{\partial y} + \frac{\partial \tau_{zy}}{\partial z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Conservation of z-momentum</strong>:</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho w}{\partial t} + \frac{\partial \rho u w}{\partial x} + \frac{\partial \rho v w}{\partial y} + \frac{\partial (\rho w^2 + p)}{\partial z} = \frac{\partial \tau_{xz}}{\partial x} + \frac{\partial \tau_{yz}}{\partial y} + \frac{\partial \tau_{zz}}{\partial z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Conservation of total energy</strong>:</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho E}{\partial t} + \frac{\partial \left[ (\rho E + p) u \right]}{\partial x}  + \frac{\partial \left[ (\rho E + p) v \right]}{\partial y} + \frac{\partial \left[ (\rho E + p) w \right]}{\partial z} = \\[0.5em]
\frac{\partial (u \tau_{xx} + v \tau_{xy} + w \tau_{xz} - q_x)}{\partial x}  + \frac{\partial (u \tau_{yx} + v \tau_{yy} + w \tau_{yz} - q_y)}{\partial y}  + \frac{\partial (u \tau_{zx} + v \tau_{zy} + w \tau_{zz} - q_z)}{\partial z} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, the components of the viscous stress tensor in scalar form are given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\tau_{xx} = 2\mu \frac{\partial u}{\partial x} + \lambda (\nabla \cdot \mathbf{v}), \quad
\tau_{yy} = 2\mu \frac{\partial v}{\partial y} + \lambda (\nabla \cdot \mathbf{v}), \quad
\tau_{zz} = 2\mu \frac{\partial w}{\partial z} + \lambda (\nabla \cdot \mathbf{v})\\[1.0em]
\tau_{xy} = \mu \left( \frac{\partial u}{\partial y} + \frac{\partial v}{\partial x} \right), \quad
\tau_{xz} = \mu \left( \frac{\partial u}{\partial z} + \frac{\partial w}{\partial x} \right), \quad
\tau_{yz} = \mu \left( \frac{\partial v}{\partial z} + \frac{\partial w}{\partial y} \right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The heat flux [katex]\mathbf{q}[/katex] is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>q_x = -\kappa \frac{\partial T}{\partial x}, \quad
q_y = -\kappa \frac{\partial T}{\partial y}, \quad
q_z = -\kappa \frac{\partial T}{\partial z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>And finally, the divergence of the velocity field is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\nabla\cdot\mathbf{u}=\frac{\partial u}{\partial x}+\frac{\partial v}{\partial y} + \frac{\partial w}{\partial z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we look through the equations, then we see that we have the following unknowns: the density [katex]\rho[/katex], the three velocity components [katex]u[/katex], [katex]v[/katex], and [katex]w[/katex] in the x, y, and z direction, the pressure [katex]p[/katex], the total energy [katex]E[/katex] and the temperature [katex]T[/katex]. This means that we have 7 unknowns. However, we can obtain the temperature from the total energy.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The total energy (per unit mass) is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>E=e+\frac{1}{2}(u^2+v^2+w^2)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]e[/katex] is the internal energy. This, in turn, can be expressed as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>e=c_vT</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>[katex]c_v[/katex] is the specific heat capacity at constant volume, and this expression holds true for an ideal gas. Thus, we can insert this into our definition of the total energy and obtain:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>E=c_vT+\frac{1}{2}(u^2+v^2+w^2)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The temperature can now be expressed as a function of the total energy as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>T=\frac{E-0.5(u^2+v^2+w^2)}{c_v}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>So, instead of 7 unknowns, we really only have 6 unknowns, or 6 independent variables. If we count the equations, then we see that we have one conservation of mass equation, three conservation of momentum equations, and one conservation of energy equation. This gives a total of 5 equations for 6 unknowns. This means we need an additional equation, which is typically given in the form of the equation of state. For an ideal gas, we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>p=\rho RT</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Where [katex]R[/katex] is the specific gas constant. This approximation works well for low pressures and high temperatures. At high pressures, atoms are forced closer together, showing stronger repulsive/attractive forces, which are not considered by the ideal gas law. At low temperatures (near the gas' boiling point), a gas will condense into liquid, changing its properties, which isn't captured by the ideal gas law.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If one of these real gas effects is important, we need to use a more appropriate equation of state. Examples are the <a href="https://en.wikipedia.org/wiki/Van_der_Waals_equation" target="_blank" rel="noopener" title="">Van der Walls</a>, <a href="https://en.wikipedia.org/wiki/Redlich%E2%80%93Kwong_equation_of_state" target="_blank" rel="noopener" title="">Redlick-Kwong</a>, and <a href="https://wiki.whitson.com/eos/eos_models/pr_eos/" target="_blank" rel="noopener" title="">Peng-Robinson</a> equation of state.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now we have the 6 equations for 6 independent variables, and we can solve the equations. The scalar equations derived above are particularly suitable to be solved with the finite difference approximation. We just have to approximate derivatives with a suitable scheme and then solve each equation for the unknown quantities. For finite volume approximations, however, it is more convenient to write the equations in vector form. The general vector form is given by:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{U}}{\partial t}+\frac{\partial \mathbf{F}^{Inv}}{\partial \mathbf{x}}=\frac{\partial\mathbf{G}^{Visc}}{\partial \mathbf{x}}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]\mathbf{U}[/katex] represents the vector of the conserved quantities, [katex]\mathbf{F}^{Inv}[/katex] the inviscid fluxes, and [katex]\mathbf{G}^{Visc}[/katex] the viscous fluxes. We can expand the vector in the x, y, and z direction as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{U}}{\partial t}+\frac{\partial \mathbf{F}^{Inv}_x}{\partial x}+\frac{\partial \mathbf{F}^{Inv}_y}{\partial y}+\frac{\partial \mathbf{F}^{Inv}_z}{\partial z}=\frac{\partial \mathbf{G}^{Visc}_x}{\partial x}+\frac{\partial \mathbf{G}^{Visc}_y}{\partial y}+\frac{\partial \mathbf{G}^{Visc}_z}{\partial z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The conserved variables and inviscid fluxes and the left-hand side are given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{U}=\begin{bmatrix}\rho \\[0.5em] \rho u \\[0.5em] \rho v \\[0.5em] \rho w \\[0.5em] \rho E \end{bmatrix},\quad

\mathbf{F}^{Inv}_x=\begin{bmatrix}\rho u \\[0.5em] \rho u^2 + p \\[0.5em] \rho u v \\[0.5em] \rho u w \\[0.5em] u(\rho E + p) \end{bmatrix},\quad

\mathbf{F}^{Inv}_y=\begin{bmatrix}\rho v \\[0.5em] \rho u v \\[0.5em] \rho v^2 + p \\[0.5em] \rho v w \\[0.5em] v(\rho E + p) \end{bmatrix},\quad

\mathbf{F}^{Inv}_z=\begin{bmatrix}\rho w \\[0.5em] \rho u w \\[0.5em] \rho v w \\[0.5em] \rho w^2 + p \\[0.5em] w(\rho E + p) \end{bmatrix}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The viscous fluxes on the right-hand side of the vector equation are given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{G}^{Visc}_x=\begin{bmatrix} 0 \\[0.5em] \tau_{xx} \\[0.5em] \tau_{xy} \\[0.5em] \tau_{xz} \\[0.5em] u\tau_{xx} + v\tau_{xy} + w \tau_{xz} - q_x \end{bmatrix},\quad

\mathbf{G}^{Visc}_y=\begin{bmatrix} 0 \\[0.5em] \tau_{yx} \\[0.5em] \tau_{yy} \\[0.5em] \tau_{yz} \\[0.5em] u\tau_{yx} + v\tau_{yy} + w \tau_{yz} - q_y \end{bmatrix},\quad

\mathbf{G}^{Visc}_z=\begin{bmatrix} 0 \\[0.5em] \tau_{zx} \\[0.5em] \tau_{zy} \\[0.5em] \tau_{zz} \\[0.5em] u\tau_{zx} + v\tau_{zy} + w \tau_{zz} - q_z \end{bmatrix}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We still need to use the equation of state to close this system of equations, but working with the vector form is easier than with the scalar form. Why is that? Well, in the next step of the finite volume approximation, we need to interpolate values from the cell centroids to the face centres. We saw in the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-discretise-the-navier-stokes-equations/#aioseo-the-finite-volume-method" target="_blank" rel="noopener" title="">article on the finite volume method</a> that a time derivative can be approximated as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\int_V\int_t^{t+\Delta t}\frac{\partial \phi}{\partial t}\mathrm{d}t\mathrm{d}V=(\phi^{n+1}-\phi^n)V</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>On the other hand, a first-order derivative can be approximated as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\int_t^{t+\Delta t}\int_An\cdot\phi\,\mathrm{d}A\mathrm{d}t=\int_An\cdot\phi\,\mathrm{d}A\Big|_t^{t+\Delta t}=\Delta t\int_An\cdot\phi\,\mathrm{d}A\approx \Delta t\sum_{i=1}^{n_{faces}}n_f\cdot \phi_i A_i</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This means that for an arbitrary unstructured grid, we can combine these two approximations with our generalised vector equation form as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>(\mathbf{U}^{n+1}-\mathbf{U}^n)V+\Delta t\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{F}^{Inv}_x\right)_i A_i+\Delta t\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{F}^{Inv}_y\right)_i A_i+\Delta t\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{F}^{Inv}_z\right)_i A_i=\\
\Delta t\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{G}^{Visc}_x\right)_i A_i+\Delta t\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{G}^{Visc}_y\right)_i A_i+\Delta t\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{G}^{Visc}_z\right)_i A_i</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can clean this up a bit by dividing each term by the volume of the cell [katex]V[/katex] and the time step [katex]\Delta t[/katex]. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\mathbf{U}^{n+1}-\mathbf{U}^n}{\Delta t}+\frac{1}{V}\left[\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{F}^{Inv}_x\right)_i A_i+\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{F}^{Inv}_y\right)_i A_i+\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{F}^{Inv}_z\right)_i A_i\right]=\\
\frac{1}{V}\left[\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{G}^{Visc}_x\right)_i A_i+\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{G}^{Visc}_y\right)_i A_i+\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{G}^{Visc}_z\right)_i A_i\right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we are dealing with a structure grid with regular elements, as shown in the figure below:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5204,"width":"600px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="https://cfd.university/wp-content/uploads/2025/04/three_dimensional_control_volume_with_normal_vector.png" alt="" class="wp-image-5204" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>where the cell's centroid is assumed to be at location [katex]i,j,k[/katex], then we can write the locations on the faces at which the integrals are to be evaluated. We can further state that the volume can be written as [katex]V=\Delta x\Delta y\Delta z[/katex]. Let's look at the second term in more detail. We can simplify this term as follows, still assuming that we work with the cell shown above:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{V}\left[\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{F}^{Inv}_x\right)_i A_i\right]=\frac{1}{\Delta x\Delta y\Delta z}\left[\begin{bmatrix}1\\0\\0\end{bmatrix}\cdot\left(\mathbf{F}^{Inv}_x\right)_{i+1/2,j,k}\Delta A_{i+1/2,j,k}+\begin{bmatrix}-1\\0\\0\end{bmatrix}\cdot\left(\mathbf{F}^{Inv}_x\right)_{i-1/2,j,k}\Delta A_{i-1/2,j,k}\right]=\\[1.0em]

\frac{\left(\mathbf{F}^{Inv}_x\right)_{i+1/2,j,k}\Delta y \Delta z -\left(\mathbf{F}^{Inv}_x\right)_{i-1/2,j,k}\Delta y\Delta z}{\Delta x\Delta y\Delta z}=\frac{\left(\mathbf{F}^{Inv}_x\right)_{i+1/2,j,k} -\left(\mathbf{F}^{Inv}_x\right)_{i-1/2,j,k}}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, we multiply the inviscid flux vector with the normal direction, and we can see the direction of the normal vector in the figure above. It is always pointed out of the control volume, wo on some faces it will have a positive sign, on others, it will have a negative sign (when it points against the coordinate direction). On the face at location [katex]i+1/2,j,k[/katex], the normal vector points in the positive direction (along the x-axis), while at location [katex]i-1/2,j,k[/katex] it points against the x coordinate direction, so its component will be negative.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We also see that the face area can be approximated by the length of the faces multiplied by each other. This can then be simplified with the volume to arrive at the expression we see above. For the inviscid fluxes in the y direction, we obtain in a similar way the following expression:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{V}\left[\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{F}^{Inv}_y\right)_i A_i\right]=\frac{1}{\Delta x\Delta y\Delta z}\left[\begin{bmatrix}0\\1\\0\end{bmatrix}\cdot\left(\mathbf{F}^{Inv}_y\right)_{i,j+1/2,k}\Delta A_{i,j+1/2,k}+\begin{bmatrix}0\\-1\\0\end{bmatrix}\cdot\left(\mathbf{F}^{Inv}_y\right)_{i,j-1/2,k}\Delta A_{i,j-1/2,k}\right]=\\[1.0em]
\frac{\left(\mathbf{F}^{Inv}_y\right)_{i,j+1/2,k}\Delta x \Delta z -\left(\mathbf{F}^{Inv}_y\right)_{i,j-1/2,k}\Delta x\Delta z}{\Delta x\Delta y\Delta z}=\frac{\left(\mathbf{F}^{Inv}_y\right)_{i,j+1/2,k} -\left(\mathbf{F}^{Inv}_y\right)_{i,j-1/2,k}}{\Delta y}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>And, in the z direction, we also obtain in a similar way the following expression:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{V}\left[\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{F}^{Inv}_z\right)_i A_i\right]=\frac{1}{\Delta x\Delta y\Delta z}\left[\begin{bmatrix}0\\0\\1\end{bmatrix}\cdot\left(\mathbf{F}^{Inv}_z\right)_{i,j,k+1/2}\Delta A_{i,j,k+1/2}+\begin{bmatrix}0\\0\\-1\end{bmatrix}\cdot\left(\mathbf{F}^{Inv}_z\right)_{i,j,k-1/2}\Delta A_{i,j,k-1/2}\right]=\\[1.0em]

\frac{\left(\mathbf{F}^{Inv}_z\right)_{i,j,k+1/2}\Delta x \Delta y -\left(\mathbf{F}^{Inv}_z\right)_{i,j,k-1/2}\Delta x\Delta y}{\Delta x\Delta y\Delta z}=\frac{\left(\mathbf{F}^{Inv}_z\right)_{i,j,k+1/2} -\left(\mathbf{F}^{Inv}_z\right)_{i,j,k-1/2}}{\Delta z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can repeat the exact same steps for the viscous fluxes, as these are also first-order derivatives, and we obtain:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{V}\left[\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{G}^{Visc}_x\right)_i A_i\right]=\frac{\left(\mathbf{G}^{Visc}_x\right)_{i+1/2,j,k} -\left(\mathbf{G}^{Visc}_x\right)_{i-1/2,j,k}}{\Delta x}\\[1em]

\frac{1}{V}\left[\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{G}^{Visc}_y\right)_i A_i\right]=\frac{\left(\mathbf{G}^{Visc}_y\right)_{i,j+1/2,k} -\left(\mathbf{G}^{Visc}_y\right)_{i,j-1/2,k}}{\Delta y}\\[1em]

\frac{1}{V}\left[\sum_{i=1}^{n_{faces}}n_f\cdot \left(\mathbf{G}^{Visc}_z\right)_i A_i\right]=\frac{\left(\mathbf{G}^{Visc}_z\right)_{i,j,k+1/2} -\left(\mathbf{G}^{Visc}_z\right)_{i,j,k-1/2}}{\Delta z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Putting all of this together now, our generalised vector equation can be written for a structured, cartesian grid as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\mathbf{U}^{n+1}_{i,j,k}-\mathbf{U}^n_{i,j,k}}{\Delta t}+
\frac{\left(\mathbf{F}^{Inv}_x\right)_{i+1/2,j,k} -\left(\mathbf{F}^{Inv}_x\right)_{i-1/2,j,k}}{\Delta x} + \frac{\left(\mathbf{F}^{Inv}_y\right)_{i,j+1/2,k} -\left(\mathbf{F}^{Inv}_y\right)_{i,j-1/2,k}}{\Delta y} + \frac{\left(\mathbf{F}^{Inv}_z\right)_{i,j,k+1/2} -\left(\mathbf{F}^{Inv}_z\right)_{i,j,k-1/2}}{\Delta z}=
\\[1em]
\frac{\left(\mathbf{G}^{Visc}_x\right)_{i+1/2,j,k} -\left(\mathbf{G}^{Visc}_x\right)_{i-1/2,j,k}}{\Delta x} +
\frac{\left(\mathbf{G}^{Visc}_y\right)_{i,j+1/2,k} -\left(\mathbf{G}^{Visc}_y\right)_{i,j-1/2,k}}{\Delta y} +
\frac{\left(\mathbf{G}^{Visc}_z\right)_{i,j,k+1/2} -\left(\mathbf{G}^{Visc}_z\right)_{i,j,k-1/2}}{\Delta z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, remember that we have 5 variables within each vector of [katex]\mathbf{U}[/katex], [katex]\mathbf{F}^{Inv}[/katex], and [katex]\mathbf{G}^{Visc}[/katex]. This means we have to solve this equation 5 times for each cell and for each time step. All we have to do is find approximations of these quantities at the face centroids, e.g. [katex]i+1/2,j,k[/katex], insert them into the equation and solve for [katex]\mathbf{U}^{n+1}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We find the approximations for the vector quantities at the face locations through interpolation, and we looked at suitable schemes in my <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/#aioseo-numerical-schemes-for-finite-volume-discretisation" target="_blank" rel="noopener" title="">article on numerical schemes for the finite volume method</a>. A good choice here would be the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/#aioseo-muscl-scheme" target="_blank" rel="noopener" title="">MUSCL</a> or <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/#aioseo-weno-scheme" target="_blank" rel="noopener" title="">WENO</a> scheme. Let's assume that we are using an explicit time integration for simplicity. Then the above vector form can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{U}^{n+1}_{i,j,k}=\mathbf{U}^n_{i,j,k}-\Delta t\left[
\frac{\left(\mathbf{F}^{Inv}_x\right)_{i+1/2,j,k} -\left(\mathbf{F}^{Inv}_x\right)_{i-1/2,j,k}}{\Delta x} + \frac{\left(\mathbf{F}^{Inv}_y\right)_{i,j+1/2,k} -\left(\mathbf{F}^{Inv}_y\right)_{i,j-1/2,k}}{\Delta y} + \frac{\left(\mathbf{F}^{Inv}_z\right)_{i,j,k+1/2} -\left(\mathbf{F}^{Inv}_z\right)_{i,j,k-1/2}}{\Delta z}\right]
\\[1em]
-\Delta t\left[\frac{\left(\mathbf{G}^{Visc}_x\right)_{i+1/2,j,k} -\left(\mathbf{G}^{Visc}_x\right)_{i-1/2,j,k}}{\Delta x} +
\frac{\left(\mathbf{G}^{Visc}_y\right)_{i,j+1/2,k} -\left(\mathbf{G}^{Visc}_y\right)_{i,j-1/2,k}}{\Delta y} +
\frac{\left(\mathbf{G}^{Visc}_z\right)_{i,j,k+1/2} -\left(\mathbf{G}^{Visc}_z\right)_{i,j,k-1/2}}{\Delta z}\right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Add the correct <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-implement-boundary-conditions-in-cfd/" target="_blank" rel="noopener" title="">boundary conditions</a>, and you have all you need to write a compressible Navier-Stokes solver. </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-incompressible-flows">Incompressible flows</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's start our discussion with why we want to use different algorithms for incompressible flows. At the beginning of this article, we said that incompressible flows are those where the density does not change. We also saw that there are materials, such as water, that behave like an incompressible fluid due to their low compressibility factor [katex]\beta[/katex]. This means that if we were to use any equation of state, for example, the ideal gas law, we have a functional relation between the pressure [katex]p[/katex] and the density [katex]\rho[/katex] as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>p=\rho RT</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If the density changes slowly, then so will the pressure. OK, moving on, let's consider the CFL condition next. <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/explicit-vs-implicit-time-integration-and-the-cfl-condition/#aioseo-how-stability-relates-to-the-cfl" target="_blank" rel="noopener" title="">When we looked at the CFL number</a>, we said that this is a measure to determine a stable time step for explicit time integration methods. For our discussion, let us write the CFL number in the following way:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>CFL=u_{max}\frac{\Delta t}{\Delta x},\quad u_{max}=\max(\lambda),\quad \lambda=[u, u+a, u-a]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]\lambda[/katex] represents the eigenvalues of the equation we are solving. The eigenvalues will give us the characteristic speeds at which information is travelling. I have only shown the eigenvalues here for a one dimensional flow, in two and three dimensions, we also get [katex]v, v+a, v-a[/katex] and [katex]w, w+a,w-a[/katex], respectively. Here, [katex]a[/katex] is the speed of sound. Let's quickly review what these eigenvalues physically represent. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The first eigenvalue [katex]u[/katex] represents the speed at which a contact wave is travelling. A contact wave is defined as an interface at which the density is discontinuous, but the pressure is not. For example, if you consider a flame and you look at an interface between burnt and non-burned gas, there will be a difference in the density across the flame front since the flame will have a higher temperature, and so the burned gas will have a different density to the unburned gas, where the temperature is lower. The pressure is the same across the interface, though.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Interfaces, in general, are good examples of contact discontinuities, and we can see where the name <em>contact</em> is derived from. The water-air interface on a body of water is another good example. At the interface, air will impose atmospheric pressure on the water, so they will have the same pressure on either side of the interface, but the density of air and water is very different. In general, interfaces in multiphase flows will have these contact discontinuities, and the interfaces move with the characteristic speed [katex]u[/katex] (and [katex]v,\, w[/katex] in a three-dimensional flow).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The two other eigenvalues represent acoustic pressure waves travelling through your domain. Consider the following jet travelling at speed [katex]u[/katex]:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5031,"width":"600px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="http://cfd.university/wp-content/uploads/2025/02/shock-waves-on-aircraft.webp" alt="" class="wp-image-5031" style="width:600px"/><figcaption class="wp-element-caption">Reproduced from <a href="https://www.scienceabc.com/pure-sciences/what-are-shock-waves-and-how-are-they-created.html" target="_blank" rel="noopener" title="">ScienceABC</a></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We see that the wavefront travels with a velocity of [katex]u+a[/katex] and [katex]u-a[/katex]. If we are on the ground and [katex]u=0[/katex], then these wavefronts would propagate in all directions equally (with speed [katex]a[/katex], i.e. the speed of sound). But once we start moving, the sound wave ahead of the jet will slow down ([katex]u-a[/katex]) while the propagation of waves behind the jet will increase ([katex]u+a[/katex]).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once we reach [katex]u=a[/katex], or a Mach number of [katex]Ma=u/a=1[/katex], the wave fronts can no longer propagate in front of us. We will have overtaken them. As a result, if we place a tangent on all of the wave fronts that emanate from the tip of the jet, we get the shock cone shown above, which represents the shock waves that will form.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Returning to the discussion of our incompressible flow, we said that an incompressible flow typically satisfies [katex]Ma&lt;0[/katex]. In many cases, we have speeds much smaller than [katex]Ma=0.3[/katex]. Think, for example, of flow within a boundary layer. Close to the wall, we get very low velocities. Thus, our local velocity is very small in comparison to the speed of sound [katex]a[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Returning to our CFL condition, we said that it is given as [katex]CFL=u_{max}\Delta t/\Delta x[/katex]. Solving this for the time step gives us [katex]\Delta t= CFL \Delta x /u_{max}[/katex]. If we consider the flow around an airfoil of chord length 1 meter, a Reynolds number of around a million, standard air and an explicit time stepping, then we have</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>[katex]CFL\le 1[/katex]</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>[katex]\Delta x&lt;&lt;1[/katex] (if we resolve this down to a [katex]y^+[/katex] value of 1, we have [katex]\Delta x\approx10^{-6}[/katex] meters)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>[katex]u_{max}=\max (u, u+a, u-a)\approx 10^2\, m/s[/katex]. For standard air, we have [katex]a=340\, m/s[/katex].</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>If we just consider orders of magnitude, then we can compute the timestep as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\Delta t=\frac{1\cdot 10^{-6}}{10^2}=10^{-8}\, s</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is a rather small time step. If we are interested in studying the vortex shedding behind the airfoil (well, we need a three-dimensional wing rather than a two-dimensional airfoil), then we can look at the relation between the Reynolds number and the Strouhal number, which is given by the following image:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5208,"width":"800px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="https://cfd.university/wp-content/uploads/2025/03/strouhal_vs_reynolds_number.jpg" alt="" class="wp-image-5208" style="width:800px"/><figcaption class="wp-element-caption">Reproduced from <a href="https://en.wikipedia.org/wiki/File:Lienhard_StrouhalVsReynoldsVortex.jpg" target="_blank" rel="noopener" title="">Wikipedia</a></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>The Strouhal number is given as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>St=\frac{fL}{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]f[/katex] is the frequency at which periodic flow patterns occur (such as vortex shedding), [katex]L[/katex] is the characteristic length (which is the same definition of [katex]L[/katex] in the Reynolds number), and [katex]u[/katex] is the characteristic velocity (again, the same as in the Reynolds number definition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Solving this equation for [katex]f[/katex], we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>f=\frac{St\cdot u}{L}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In the example for the airfoil, we assumed standard air and a Reynolds number of around 1 million. With a characteristic length of [katex]L=1[/katex] meter, we have a velocity of around [katex]u=15[/katex] meters per second. From the plot above, we can see that a Reynolds number of a million produces a Strouhal number of about [katex]St=0.2[/katex]. This means that our frequency can be computed as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>f=\frac{0.2\cdot 15}{1}=3\,\frac{1}{s}=3\, Hz</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This means that one vortex shedding frequency takes [katex]T=1/f=1/3[/katex] seconds. If we divide this by the time step [katex]\Delta t=10^{-8}[/katex] seconds, then we get the total number of time steps required to resolve a single vortex shedding period. We have: [katex](1/3)/10^{-8}=33,333,333[/katex] time steps. This sounds like a lot, but it may not even be the upper limit. We said before that the pressure changes with changes in density. But, if the density changes very slowly, the pressure will change slowly, too.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, we may even need more than the 33 million time steps for a single vortex shedding period. We can see that using a compressible method requires a lot of time steps to get the solution for an essentially incompressible fluid. In the literature, this is typically referred to as a stiff system of equations. The stiffness here means that the system does not change quickly and so we need a lot of iterations to see changes in the solution.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What are the solutions, then? Well, we no longer want to depend on density changes to drive the solution. Instead, we want to compute changes in pressure directly and see how that affects the solution. For this reason, we also differentiate between density-based and pressure-based solution approaches to solve compressible and incompressible flows, respectively. For example, in ANSYS Fluent, you have to specify if you want to use a density-based or a pressure-based approach, which selects either the compressible or incompressible solver.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we already have a working compressible solver, we might be tempted to use it for incompressible flows if we can introduce a small correction instead of having to write a new solver from scratch. Approaches have been introduced in the literature which fall under the topic of preconditioning or low Mach number correction approaches. These are applied top density-based formulations, i.e. those where we link pressure and density through the equation of state.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's look at preconditioning. One of the issues where a stiff system of equations comes from is the discrepancy between the local flow velocity [katex]u[/katex] and the speed of sound [katex]a[/katex]. If we can&nbsp;scale&nbsp;our system of equations so that the propagation speed of acoustic waves becomes similar to the local flow velocities, then we get larger time steps, and as a result, fewer time steps are required to advance the solution in time. We will look at one such method in just a second.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On the other hand, pressure-based solution algorithms accept that there is no coupling between the pressure and the density, so the equation of state can no longer be used. Instead, we say the pressure and velocity are completely decoupled and we have to come up with a clever way of coupling them back together. These algorithms are known as pressure velocity coupling algorithms, and you may be more familiar with their street names like SIMPLE, PISO, PIMPLE (great name!), and, in general, projection, or pressure projection, methods.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The last sentence has 8 commas, a new record. Whoop whoop 🥳🎉. Let's continue.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We will review a subset of each of these methods so that you get an idea of how each method works. We will start with my personal favourite and the highly underrated artificial compressibility method first. It is my favourite because it is the simplest incompressible method to implement. It allows for a fully explicit implementation, making it a great method to implement from scratch, while all other project-based methods require the solution of an implicit system of equations. This can be confusing if you just want to start out.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, while the artificial compressibility method is easy to implement, it is not as efficient as its projection-based counterparts (like SIMPLE, PISO, etc.). So you won't find it used much these days. But for your own personal fun and solver development, I'll give it an A+. Once you have that implemented and working, you can always switch to a different method and validate it against your artificial compressibility method implementation. Sounds good? Let's see what this method is all about!</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-artificial-compressibility">Artificial Compressibility</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The artificial compressibility method was first published in 1967 by one of the great minds in CFD. Chorin, to me, is the father of incompressible algorithms. He gave us not just the artificial compressibility method but also introduced us to projection methods (covered later), which are the foundation for methods you have probably already used (SIMPLE, PISO, etc.). He is right up there with the greats such as Lax, Wendroff, Godunov, Harten, and van Leer.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So let's see what Chorin did. He said that we should just use the equations that govern compressible flows. Now, we already know that this won't work for the continuity equation, as the density is constant. However, let's review this for a second. The equation is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \rho}{\partial t}+\nabla\cdot(\rho\mathbf{u})=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Chorin said that we know that the pressure and density are related through the equation of state, i.e. we have [katex]p=\rho R T[/katex]. While we know that this equation no longer holds for an incompressible flow, we can generalise this as a functional relationship. We can express that as [katex]p=f(\rho, \beta)=\rho\beta[/katex], where [katex]\beta[/katex] is some unknown scaling factor. This may not be a constant.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Chorin now said that if we solve this for the density, i.e. [katex]\rho=p/\beta[/katex], then we can insert this into the continuity equation. This would result in</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{\beta}\frac{\partial p}{\partial \tau}+\nabla\cdot(\rho\mathbf{u})=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, we have written the value of [katex]1/\beta[/katex] in front of the time derivative. Why? Well, we don't know its value, so we treat it as a constant, even though it may not be one. But, take a closer look at the time derivative. It is no longer a time derivative. We have exchanged [katex]t[/katex] (real time) for a new variable [katex]\tau[/katex] (pseudo time). What does that mean?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, the equation above no longer represents the continuity equation. But, if we weaken the equation a bit, we can insist that the above equation is still valid. We can say that the equation is only valid in the limit of steady-state flows. Steady-state flows require, by definition, that there are no changes in time. If there are no more changes in time, then we have [katex]\partial p/\partial\tau = 0[/katex]. So the time derivative of the pressure will vanish, and we recover the continuity equation of an incompressible flow, i.e. [katex]\nabla\cdot (\rho\mathbf{\rho})[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This doesn't mean that the time history itself is completely wrong; if you look at an animation of the artificial compressibility method, it will appear as if it resolves the transient behaviour correctly. However, if you were to take measurements that depend on the timestep, like measuring frequencies, these would be all wrong now. Thus, we only resolve a physically meaningful flow field once the time derivative vanishes and the flow has settled for a steady-state solution.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let us write the three-dimensional scalar form of this equation in Cartesian coordinates. Then we get</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{\beta}\frac{\partial p}{\partial \tau}+\frac{\partial \rho u}{\partial x}+\frac{\partial \rho v}{\partial y}+\frac{\partial \rho w}{\partial z}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we perform a quick discretisation using the finite difference method with a first-order Euler in time and a second-order central scheme in space, we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{\beta}\frac{p^{n+1}_{i,j,k}-p^n_{i,j,k}}{\Delta \tau}+\rho\left(\frac{u^n_{i+1,j,k}-u^n_{i-1,j,k}}{2\Delta x}+\frac{v^n_{i,j+1,k}-v^n_{i,j-1,k}}{2\Delta y}+\frac{w^n_{i,j,k+1}-w^n_{i,j,k-1}}{2\Delta z}\right)=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Solving this for [katex]p^{n+1}_{i,j,k}[/katex], we get</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>p^{n+1}_{i,j,k}=p^n_{i,j,k} - \Delta\tau \rho\beta\left(\frac{u^n_{i+1,j,k}-u^n_{i-1,j,k}}{2\Delta x}+\frac{v^n_{i,j+1,k}-v^n_{i,j-1,k}}{2\Delta y}+\frac{w^n_{i,j,k+1}-w^n_{i,j,k-1}}{2\Delta z}\right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Thus, we have found a cheap and easy way to compute an updated pressure field using the continuity equation. We can use this pressure field now in our momentum equation, which was given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial \tau} + (\mathbf{u}\cdot\nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's write the scalar form of this equation as well. In three dimensions, we get three equations for [katex]\mathbf{u}=[u,v,w][/katex], which are:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial u}{\partial \tau}+u\frac{\partial u}{\partial x}+v\frac{\partial u}{\partial y}+w\frac{\partial u}{\partial z}=-\frac{1}{\rho}\frac{\partial p}{\partial x}+\nu\left(\frac{\partial^2 u}{\partial x^2}+\frac{\partial^2 u}{\partial y^2}+\frac{\partial^2 u}{\partial z^2}\right)\\[1em]

\frac{\partial v}{\partial \tau}+u\frac{\partial v}{\partial x}+v\frac{\partial v}{\partial y}+w\frac{\partial v}{\partial z}=-\frac{1}{\rho}\frac{\partial p}{\partial y}+\nu\left(\frac{\partial^2 v}{\partial x^2}+\frac{\partial^2 v}{\partial y^2}+\frac{\partial^2 v}{\partial z^2}\right)\\[1em]

\frac{\partial w}{\partial \tau}+u\frac{\partial w}{\partial x}+v\frac{\partial w}{\partial y}+w\frac{\partial w}{\partial z}=-\frac{1}{\rho}\frac{\partial p}{\partial z}+\nu\left(\frac{\partial^2 w}{\partial x^2}+\frac{\partial^2 w}{\partial y^2}+\frac{\partial^2 w}{\partial z^2}\right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>To make the discretisation a bit more easy to manage, let us introduce the following operator:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathrm{upwind}(\phi)=\max(u_{i,j,k},\,0)\frac{\phi_{i,j,k}-\phi_{i-1,j,k}}{\Delta x}+\min(u_{i,j,k},\, 0)\frac{\phi_{i+1,j,k}-\phi_{i, j, k}}{\Delta x}+\\[1em]

\max(v_{i,j,k},\,0)\frac{\phi_{i,j,k}-\phi_{i,j-1,k}}{\Delta y}+\min(v_{i,j,k},\, 0)\frac{\phi_{i,j+1,k}-\phi_{i, j, k}}{\Delta y}+\\[1em]

\max(w_{i,j,k},\,0)\frac{\phi_{i,j,k}-\phi_{i,j,k-1}}{\Delta z}+\min(w_{i,j,k},\, 0)\frac{\phi_{i,j,k+1}-\phi_{i, j, k}}{\Delta z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is the upwind discretisation. Here, [katex]\phi[/katex] is one of the velocity components, i.e. [katex][u,v,w][/katex]. We can also introduce a diffusion operator as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathrm{diffusion}(\phi)=\nu\left(\frac{\phi_{i+1,j,k}-2\phi_{i,j,k}+\phi_{i-1,j,k}}{\Delta x^2}+\frac{\phi_{i,j+1,k}-2\phi_{i,j,k}+\phi_{i,j-1,k}}{\Delta y^2}+\frac{\phi_{i,j,k+1}-2\phi_{i,j,k}+\phi_{i,j,k-1}}{\Delta z^2}\right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>With these operators defined, let us write the discretised form of the three-dimensional momentum equation with first-order Euler in time and a central operator for the pressure. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{u^{n+1}_{i,j,k}-u^n_{i,j,k}}{\Delta \tau}+\mathrm{upwind}(u)=-\frac{1}{\rho}\frac{p^{n+1}_{i+1,j,k}-p^{n+1}_{i-1,j,k}}{2\Delta x}+\mathrm{diffusion}(u)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can solve this now for [katex]u^{n+1}_{i,j,k}[/katex] to arrive at:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u^{n+1}_{i,j,k}=u^n_{i,j,k}+\Delta \tau\left[-\mathrm{upwind}(u)-\frac{1}{\rho}\frac{p^{n+1}_{i+1,j,k}-p^{n+1}_{i-1,j,k}}{2\Delta x}+\mathrm{diffusion}(u)\right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can find similar discretisations for [katex]v^{n+1}_{i,j,k}[/katex] and [katex]w^{n+1}_{i,j,k}[/katex] as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>v^{n+1}_{i,j,k}=v^n_{i,j,k}+\Delta \tau\left[-\mathrm{upwind}(v)-\frac{1}{\rho}\frac{p^{n+1}_{i,j+1,k}-p^{n+1}_{i,j-1,k}}{2\Delta y}+\mathrm{diffusion}(v)\right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>And:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>w^{n+1}_{i,j,k}=w^n_{i,j,k}+\Delta \tau\left[-\mathrm{upwind}(w)-\frac{1}{\rho}\frac{p^{n+1}_{i,j,k+1}-p^{n+1}_{i,j,k-1}}{2\Delta z}+\mathrm{diffusion}(w)\right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Since we obtain the pressure already, it is no longer an unknown and so we can solve the momentum equation. We do that until all pseudo-time derivatives vanish. How can we check that? Well, if the pseudo time derivatives are discretised as [katex]\partial \phi/\partial\tau=(\phi^{n+1}-\phi^n)/\Delta \tau[/katex], then [katex]\partial \phi/\partial[/katex] is zero for [katex]\phi^{n+1}=\phi^n[/katex], since [katex](\phi^{n+1}-\phi^n)/\Delta \tau=0/\Delta\tau=0[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In other words, if we evaluate the continuity and momentum equation until they no longer change, then we have found a valid solution that satisfies the Navier-Stokes equation again. We can introduce a convergence condition that states that if the solution does not change by more than 0.1%, for example, then we have reached convergence. This may be expressed as [katex]\phi^{n+1}-\phi^n&lt;10^{-3}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another convergence condition we can impose is the incompressible continuity equation itself. We know that for an incompressible flow, we have [katex]\nabla\cdot\mathbf{u}=0[/katex]. We can impose a similar constraint by requiring the continuity equation to be satisfied, for example, by stating [katex]\nabla\cdot\mathbf{u}&lt;10^{-3}[/katex]. This could be written as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{u_{i+1,j,k}-u_{i-1,j,k}}{2\Delta x}+\frac{v_{i,j+1,k}-v_{i,j-1,k}}{2\Delta y}+\frac{w_{i,j,k+1}-w_{i,j,k-1}}{2\Delta z}&lt;10^{-3}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can now check that this condition is satisfied at each node [katex]i,j,k[/katex], or we can compute the average through the L2 vector norm, for example, and compare that against [katex]10^{-3}[/katex] (or a smaller convergence condition).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Hopefully everything up to this point makes sense. The artificial compressibility method does not get more complicated than this. It is very straightforward to implement, and it does give results reasonably well. It suffers from a slower convergence compared to other methods, but there are ways to stabilise the procedure to potentially bring it closer to the projection methods discussed next. But before we go there, I wanted to close the circle and bring back our discussion on preconditioning.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For this, let us write all scalar equations we have obtained thus far below:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{\beta}\frac{\partial p}{\partial \tau}+\frac{\partial \rho u}{\partial x}+\frac{\partial \rho v}{\partial y}+\frac{\partial \rho w}{\partial z}=0\\[1em]

\frac{\partial u}{\partial \tau}+u\frac{\partial u}{\partial x}+v\frac{\partial u}{\partial y}+w\frac{\partial u}{\partial z} + \frac{1}{\rho}\frac{\partial p}{\partial x}=\nu\left(\frac{\partial^2 u}{\partial x^2}+\frac{\partial^2 u}{\partial y^2}+\frac{\partial^2 u}{\partial z^2}\right)\\[1em]

\frac{\partial v}{\partial \tau}+u\frac{\partial v}{\partial x}+v\frac{\partial v}{\partial y}+w\frac{\partial v}{\partial z} + \frac{1}{\rho}\frac{\partial p}{\partial y}=\nu\left(\frac{\partial^2 v}{\partial x^2}+\frac{\partial^2 v}{\partial y^2}+\frac{\partial^2 v}{\partial z^2}\right)\\[1em]

\frac{\partial w}{\partial \tau}+u\frac{\partial w}{\partial x}+v\frac{\partial w}{\partial y}+w\frac{\partial w}{\partial z} + \frac{1}{\rho}\frac{\partial p}{\partial z}=\nu\left(\frac{\partial^2 w}{\partial x^2}+\frac{\partial^2 w}{\partial y^2}+\frac{\partial^2 w}{\partial z^2}\right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can also write this system of equations as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{P}^{-1}\frac{\partial \mathbf{U}}{\partial \tau}+\mathbf{A}^{Inv}\frac{\partial \mathbf{U}}{\partial x}+\mathbf{B}^{Inv}\frac{\partial \mathbf{U}}{\partial y}+\mathbf{C}^{Inv}\frac{\partial \mathbf{U}}{\partial z}=\mathbf{A}^{Visc}\frac{\partial^2 \mathbf{U}}{\partial x^2}+\mathbf{B}^{Visc}\frac{\partial^2 \mathbf{U}}{\partial y^2}+\mathbf{C}^{Visc}\frac{\partial^2 \mathbf{U}}{\partial z^2}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, we have introduced the primitive variable vector [katex]\mathbf{U}=[p,u,v,w]^T[/katex] and matrices:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{A}^{Inv}=\begin{bmatrix}0 &amp; \rho &amp; 0 &amp; 0 \\ 1/\rho &amp; u &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; u &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; u\end{bmatrix},\quad
\mathbf{B}^{Inv}=\begin{bmatrix}0 &amp; 0 &amp; \rho &amp; 0 \\ 0 &amp; v &amp; 0 &amp; 0 \\ 1/\rho &amp; 0 &amp; v &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; v\end{bmatrix},\quad
\mathbf{C}^{Inv}=\begin{bmatrix}0 &amp; 0 &amp; 0 &amp; \rho \\ 0 &amp; w &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; w &amp; 0 \\ 1/\rho &amp; 0 &amp; 0 &amp; w\end{bmatrix},\quad\\[1em]
\mathbf{A}^{Visc}=\mathbf{B}^{Visc}=\mathbf{C}^{Visc}=\begin{bmatrix}0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \nu &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \nu &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \nu\end{bmatrix}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Does this vector equation look familiar? Yes, it is almost identical to the vector equation we saw in the discussion on compressible flows. The difference here is that we use primitive or non-conserved variables. So we no longer deal with the inviscid and viscous fluxes [katex]\mathbf{F}^{Inv}[/katex] and [katex]\mathbf{G}^{Visc}[/katex] but rather with the primitive variables [katex]\mathbf{U}[/katex] directly. To see that these matrixes give us the right scalar equation again, we can write out the vector equation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{P}^{-1}\begin{bmatrix}\partial p/\partial \tau \\ \partial u/\partial \tau \\ \partial v/\partial \tau \\ \partial w/\partial \tau\end{bmatrix}+
\begin{bmatrix}0 &amp; \rho &amp; 0 &amp; 0 \\ 1/\rho &amp; u &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; u &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; u\end{bmatrix}
\begin{bmatrix}\partial p/\partial x \\ \partial u/\partial x \\ \partial v/\partial x \\ \partial w/\partial x\end{bmatrix}+
\begin{bmatrix}0 &amp; 0 &amp; \rho &amp; 0 \\ 0 &amp; v &amp; 0 &amp; 0 \\ 1/\rho &amp; 0 &amp; v &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; v\end{bmatrix}
\begin{bmatrix}\partial p/\partial y \\ \partial u/\partial y \\ \partial v/\partial y \\ \partial w/\partial y\end{bmatrix}+
\begin{bmatrix}0 &amp; 0 &amp; 0 &amp; \rho \\ 0 &amp; w &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; w &amp; 0 \\ 1/\rho &amp; 0 &amp; 0 &amp; w\end{bmatrix}
\begin{bmatrix}\partial p/\partial z \\ \partial u/\partial z \\ \partial v/\partial z \\ \partial w/\partial z\end{bmatrix}
=\\[1em]
\begin{bmatrix}0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \nu &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \nu &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \nu\end{bmatrix}
\begin{bmatrix}\partial^2 p/\partial x^2 \\ \partial^2 u/\partial x^2 \\ \partial^2 v/\partial x^2 \\ \partial^2 w/\partial x^2\end{bmatrix}+
\begin{bmatrix}0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \nu &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \nu &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \nu\end{bmatrix}
\begin{bmatrix}\partial^2 p/\partial y^2 \\ \partial^2 u/\partial y^2 \\ \partial^2 v/\partial y^2 \\ \partial^2 w/\partial y^2\end{bmatrix}+
\begin{bmatrix}0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \nu &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \nu &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \nu\end{bmatrix}
\begin{bmatrix}\partial^2 p/\partial z^2 \\ \partial^2 u/\partial z^2 \\ \partial^2 v/\partial z^2 \\ \partial^2 w/\partial z^2\end{bmatrix}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The advantage of doing this is that we can create an incompressible solver with very little effort if we already have a compressible solver implemented. We can reuse the same numerical schemes and everything else stays the same, we just have to change the the vector equation from conserved to non-conserved variable formulation and ensure that we have <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-implement-boundary-conditions-in-cfd/#aioseo-inlet" target="_blank" rel="noopener" title="">subsonic boundary conditions</a> implemented.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The downside is that the artificial compressibility method retains the hyperbolic character of the compressible Navier-Stokes equations. As we discussed in the article on <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/" target="_blank" rel="noopener" title="">hyperbolic, parabolic, and elliptic partial differential equations</a>, <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-hyperbolic-flows" target="_blank" rel="noopener" title="">hyperbolic flows</a> behave very differently from <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-elliptic-flows" target="_blank" rel="noopener" title="">elliptic flows</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Is that a problem? Not necessarily, but consider the following analogy: Imagine you are extremely active, and you exercise several times per day. You do some running and some cycling, and you visit your local gym in the morning before heading to university or work. Now, your friend approaches you and asks you: "Do you want to run a marathon with me?" You probably don't even have to think twice and accept the invite on the spot because this activity aligns with your&nbsp;character.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, imagine you are a <a href="https://www.istockphoto.com/vector/couch-potato-gm1490842170-515322632" target="_blank" rel="noopener" title="">couch potato</a>. While you do <em>occasionally</em> enjoy outdoor walking and perhaps a bit of recreational cycling, you feel most comfortable in your home sweet home. You work or study from home when you can, and you are happy to do your groceries once or twice a week; you don't need more activity in your life than that. Now your friend comes around again and asks: "Do you want to run a marathon with me?". This does not align with your <em>character</em>, so your friend would have to spend a lot of time convincing you to join in.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In both cases, you can be convinced to run the marathon, but in once case, it is very fast, in the other case, it takes time. The same is true for the Navier-Stokes equation. If the equations you are solving are fully hyperbolic (artificial compressibility method) but the underlying equations they are solving are mixed elliptic/hyperbolic (incompressible Navier-Stokes equation), then it will take time to get convergence.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, if you solve the compressible Navier-Stokes equations, which are fully hyperbolic, with a system of fully hyperbolic equations, then you get better and much faster convergence. Since we do not modify the equations for compressible flows but rather solve them as they are (while closing them with the equation of state), we retain the mathematical character and, therefore, get better convergence.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We haven't looked yet at [katex]\mathbf{P}[/katex]. This can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{P}^{-1}=\begin{bmatrix}1/\beta &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0\end{bmatrix}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We see that this matrix only multiplies the time derivative in the continuity equation with the factor of [katex]1/\beta[/katex]. We said earlier that preconditioning methods achieve faster convergence for compressible methods by scaling the equations in some form. Here, we can think of [katex]\beta[/katex] as a scaling parameter for the pressure. Its value can be anything we want since it multiplies the time derivative of the pressure, which will vanish for steady-state flows.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Think of the physical role of pressure; it dictates the propagation of pressure waves, which in turn is governed by the speed of sound. We said that incompressible flows suffer from slow convergence because local flow velocities are much smaller than the local speed of sound. So, by tampering (scaling) the pressure, we could reasonably argue that we would be tampering with the local speed of sound. If we wanted to see this in equation form, we would need to calculate the eigenvalues of the system. To do that, let's write out our continuity equation for a moment:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{\beta}\frac{\partial p}{\partial \tau}+\frac{\partial \rho u}{\partial x}+\frac{\partial \rho v}{\partial y}+\frac{\partial \rho w}{\partial z}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's modify it by multiplying this equation by [katex]\beta[/katex]. This will result in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial p}{\partial \tau}+\frac{\partial \beta\rho u}{\partial x}+\frac{\partial \beta\rho v}{\partial y}+\frac{\partial \beta\rho w}{\partial z}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Since [katex]\beta[/katex] is a constant (or at least, we treat it as one), we can just place it within the derivative. Now, the preconditioning matrix [katex]\mathbf{P}^{-1}[/katex] is a zero matrix, so we can remove it, but we need to modify our [katex]\mathbf{A}^{Inv}[/katex], [katex]\mathbf{B}^{Inv}[/katex], and [katex]\mathbf{C}^{Inv}[/katex] matrix, which now become:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{A}^{Inv}=\begin{bmatrix}0 &amp; \beta\rho &amp; 0 &amp; 0 \\ 1/\rho &amp; u &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; u &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; u\end{bmatrix},\quad
\mathbf{B}^{Inv}=\begin{bmatrix}0 &amp; 0 &amp; \beta\rho &amp; 0 \\ 0 &amp; v &amp; 0 &amp; 0 \\ 1/\rho &amp; 0 &amp; v &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; v\end{bmatrix},\quad
\mathbf{C}^{Inv}=\begin{bmatrix}0 &amp; 0 &amp; 0 &amp; \beta\rho \\ 0 &amp; w &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; w &amp; 0 \\ 1/\rho &amp; 0 &amp; 0 &amp; w\end{bmatrix}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we have to look at the eigenvalues of [katex]\mathbf{A}^{Inv}[/katex], [katex]\mathbf{B}^{Inv}[/katex], and [katex]\mathbf{C}^{Inv}[/katex]. We compute the eigenvalues for each matrix as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\lambda^\mathbf{A}=\det(\mathbf{A}^{Inv}-\lambda\mathbf{I}),\quad \lambda^\mathbf{B}=\det(\mathbf{B}^{Inv}-\lambda\mathbf{I}),\quad \lambda^\mathbf{C}=\det(\mathbf{C}^{Inv}-\lambda\mathbf{I})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p> We can do this by hand, but for anything more than a 2 by 2 matrix, I can't be bothered doing this analytically and rather write a piece of code that can do this for me. I trust that most know how to do it by hand, but perhaps not how to do this in code, so let's see how we can achieve this. The following Python code uses the <code>sympy</code> package for symbolic math manipulation. Let's look through it first and then discuss it afterwards.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"import sympy as sp\n\n# define symbols required to construct matrices\nrho = sp.symbols('rho')\nbeta = sp.symbols('beta')\nu = sp.symbols('u')\nv = sp.symbols('v')\nw = sp.symbols('w')\n\n# define inviscid coefficient matrices\nA = sp.Matrix([\n    [0, beta * rho, 0, 0],\n    [1/rho, u, 0, 0],\n    [0, 0, u, 0],\n    [0, 0, 0, u]\n])\n\nB = sp.Matrix([\n    [0, 0, beta * rho, 0],\n    [0, v, 0, 0],\n    [1/rho, 0, v, 0],\n    [0, 0, 0, v]\n])\n\nC = sp.Matrix([\n    [0, 0, 0, beta * rho],\n    [0, w, 0, 0],\n    [0, 0, w, 0],\n    [1/rho, 0, 0, w]\n])\n\n# compute eigenvalues and roots of eigenvalues\nlam = sp.symbols('lambda')\n\neigenvalues_of_A = sp.det(A - lam * sp.eye(4))\neigenvalues_of_B = sp.det(B - lam * sp.eye(4))\neigenvalues_of_C = sp.det(C - lam * sp.eye(4))\n\nroots_of_A = sp.roots(sp.Poly(eigenvalues_of_A, lam))\nroots_of_B = sp.roots(sp.Poly(eigenvalues_of_B, lam))\nroots_of_C = sp.roots(sp.Poly(eigenvalues_of_C, lam))\n\n# print eigenvalues\nprint(roots_of_A)\nprint(roots_of_B)\nprint(roots_of_C)","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eimport\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e sympy \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eas\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e sp\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# define symbols required to construct matrices\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003erho = sp.symbols(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026#39;rho\u0026#39;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003ebeta = sp.symbols(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026#39;beta\u0026#39;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eu = sp.symbols(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026#39;u\u0026#39;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003ev = sp.symbols(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026#39;v\u0026#39;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003ew = sp.symbols(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026#39;w\u0026#39;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# define inviscid coefficient matrices\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eA = sp.Matrix([\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, beta * rho, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e],\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e/rho, u, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e],\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, u, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e],\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, u]\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e])\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eB = sp.Matrix([\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, beta * rho, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e],\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, v, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e],\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e/rho, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, v, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e],\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, v]\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e])\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eC = sp.Matrix([\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, beta * rho],\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, w, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e],\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, w, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e],\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e/rho, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, w]\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e])\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# compute eigenvalues and roots of eigenvalues\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003elam = sp.symbols(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026#39;lambda\u0026#39;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eeigenvalues_of_A = sp.det(A - lam * sp.eye(\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e4\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eeigenvalues_of_B = sp.det(B - lam * sp.eye(\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e4\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eeigenvalues_of_C = sp.det(C - lam * sp.eye(\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e4\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eroots_of_A = sp.roots(sp.Poly(eigenvalues_of_A, lam))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eroots_of_B = sp.roots(sp.Poly(eigenvalues_of_B, lam))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eroots_of_C = sp.roots(sp.Poly(eigenvalues_of_C, lam))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# print eigenvalues\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eprint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(roots_of_A)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eprint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(roots_of_B)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eprint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(roots_of_C)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"python","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":46,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="import sympy as sp

# define symbols required to construct matrices
rho = sp.symbols('rho')
beta = sp.symbols('beta')
u = sp.symbols('u')
v = sp.symbols('v')
w = sp.symbols('w')

# define inviscid coefficient matrices
A = sp.Matrix([
    [0, beta * rho, 0, 0],
    [1/rho, u, 0, 0],
    [0, 0, u, 0],
    [0, 0, 0, u]
])

B = sp.Matrix([
    [0, 0, beta * rho, 0],
    [0, v, 0, 0],
    [1/rho, 0, v, 0],
    [0, 0, 0, v]
])

C = sp.Matrix([
    [0, 0, 0, beta * rho],
    [0, w, 0, 0],
    [0, 0, w, 0],
    [1/rho, 0, 0, w]
])

# compute eigenvalues and roots of eigenvalues
lam = sp.symbols('lambda')

eigenvalues_of_A = sp.det(A - lam * sp.eye(4))
eigenvalues_of_B = sp.det(B - lam * sp.eye(4))
eigenvalues_of_C = sp.det(C - lam * sp.eye(4))

roots_of_A = sp.roots(sp.Poly(eigenvalues_of_A, lam))
roots_of_B = sp.roots(sp.Poly(eigenvalues_of_B, lam))
roots_of_C = sp.roots(sp.Poly(eigenvalues_of_C, lam))

# print eigenvalues
print(roots_of_A)
print(roots_of_B)
print(roots_of_C)" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">import</span><span style="color: #D4D4D4"> sympy </span><span style="color: #C586C0">as</span><span style="color: #D4D4D4"> sp</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955"># define symbols required to construct matrices</span></span>
<span class="line"><span style="color: #D4D4D4">rho = sp.symbols(</span><span style="color: #CE9178">&#39;rho&#39;</span><span style="color: #D4D4D4">)</span></span>
<span class="line"><span style="color: #D4D4D4">beta = sp.symbols(</span><span style="color: #CE9178">&#39;beta&#39;</span><span style="color: #D4D4D4">)</span></span>
<span class="line"><span style="color: #D4D4D4">u = sp.symbols(</span><span style="color: #CE9178">&#39;u&#39;</span><span style="color: #D4D4D4">)</span></span>
<span class="line"><span style="color: #D4D4D4">v = sp.symbols(</span><span style="color: #CE9178">&#39;v&#39;</span><span style="color: #D4D4D4">)</span></span>
<span class="line"><span style="color: #D4D4D4">w = sp.symbols(</span><span style="color: #CE9178">&#39;w&#39;</span><span style="color: #D4D4D4">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955"># define inviscid coefficient matrices</span></span>
<span class="line"><span style="color: #D4D4D4">A = sp.Matrix([</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, beta * rho, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">],</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">/rho, u, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">],</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, u, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">],</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, u]</span></span>
<span class="line"><span style="color: #D4D4D4">])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">B = sp.Matrix([</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, beta * rho, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">],</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, v, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">],</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">/rho, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, v, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">],</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, v]</span></span>
<span class="line"><span style="color: #D4D4D4">])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">C = sp.Matrix([</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, beta * rho],</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, w, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">],</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, w, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">],</span></span>
<span class="line"><span style="color: #D4D4D4">    [</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">/rho, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, w]</span></span>
<span class="line"><span style="color: #D4D4D4">])</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955"># compute eigenvalues and roots of eigenvalues</span></span>
<span class="line"><span style="color: #D4D4D4">lam = sp.symbols(</span><span style="color: #CE9178">&#39;lambda&#39;</span><span style="color: #D4D4D4">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">eigenvalues_of_A = sp.det(A - lam * sp.eye(</span><span style="color: #B5CEA8">4</span><span style="color: #D4D4D4">))</span></span>
<span class="line"><span style="color: #D4D4D4">eigenvalues_of_B = sp.det(B - lam * sp.eye(</span><span style="color: #B5CEA8">4</span><span style="color: #D4D4D4">))</span></span>
<span class="line"><span style="color: #D4D4D4">eigenvalues_of_C = sp.det(C - lam * sp.eye(</span><span style="color: #B5CEA8">4</span><span style="color: #D4D4D4">))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">roots_of_A = sp.roots(sp.Poly(eigenvalues_of_A, lam))</span></span>
<span class="line"><span style="color: #D4D4D4">roots_of_B = sp.roots(sp.Poly(eigenvalues_of_B, lam))</span></span>
<span class="line"><span style="color: #D4D4D4">roots_of_C = sp.roots(sp.Poly(eigenvalues_of_C, lam))</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955"># print eigenvalues</span></span>
<span class="line"><span style="color: #DCDCAA">print</span><span style="color: #D4D4D4">(roots_of_A)</span></span>
<span class="line"><span style="color: #DCDCAA">print</span><span style="color: #D4D4D4">(roots_of_B)</span></span>
<span class="line"><span style="color: #DCDCAA">print</span><span style="color: #D4D4D4">(roots_of_C)</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>After we have imported the module on line 1, we introduce our symbols on lines 4-8. Sympy needs these to know which variables to treat as symbols, in our case, we have the density and velocity components, as well as the [katex]\beta[/katex]parameter. We then construct the coefficient matrices on lines 11-30 which we can now use for the eigenvalue calculation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We define the additional symbol <code>lambda</code> on line 33, which we then use to compute the eigenvalues on lines 35-37. Here, <code>sp.eye(4)</code> produces a 4 by 4 identity matrix. With those eigenvalues found, we want to extract the roots of the polynomial that is generated by lines 35-37, which is done on lines 39-41. Printing the results for each matrix on lines 44-46 results in the following values:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>A:\quad u,\,u,\,\frac{1}{2}\left(u+\sqrt{u^2+4\beta}\right),\,\frac{1}{2}\left(u-\sqrt{u^2+4\beta}\right)\\[1em]
B:\quad v,\,v,\,\frac{1}{2}\left(v+\sqrt{v^2+4\beta}\right),\,\frac{1}{2}\left(v-\sqrt{v^2+4\beta}\right)\\[1em]
C:\quad w,\,w,\,\frac{1}{2}\left(w+\sqrt{w^2+4\beta}\right),\,\frac{1}{2}\left(w-\sqrt{w^2+4\beta}\right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We have again a few contact discontinuities in each direction, i.e. [katex]u[/katex], [katex]v[/katex], and [katex]w[/katex]. And then, we have two additional eigenvalues. Let's see what happens if we set [katex]\beta=0[/katex]. In this case, the square root of, for example, [katex]\sqrt{u^2+4\beta}[/katex] becomes [katex]\sqrt{u^2+4\cdot 0}=\sqrt{u^2}=u[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's abbreviate this square root with the letter [katex]a[/katex]. Then, we can rewrite these eigenvalues as [katex]0.5(u+\sqrt{u^2+4\beta})=0.5(u+a)[/katex] and [katex]0.5(u-\sqrt{u^2+4\beta})=0.5(u-a)[/katex]. So we see, the content of the square root resembles the speed of sound in compressible flows, or, in other words, the propagation speed of characteristics (e.g. pressure waves, disturbances).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, we are in a better position to judge the real importance of the [katex]\beta[/katex] parameter. Not only is it used now to represent the functional relationship between the pressure [katex]p[/katex] and the density [katex]\rho[/katex], but also to <em>scale</em> the characteristic speed at which disturbances (pressure waves) travel. In other words, we are able to scale [katex]a=\sqrt{u^2+4\beta}[/katex] by modifying [katex]\beta[/katex] so that [katex]u[/katex] and [katex]a[/katex] become closer together.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's return to our airfoil example above, where we calculated the number of timesteps required to resolve one vortex shedding cycle or period. We said that our time step is calculated as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\Delta t=\frac{1\cdot 10^{-6}}{10^2}=10^{-8}\, s</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, the denominator of [katex]10^2[/katex] represents the max eigenvalue, e.g. [katex]u\pm a[/katex]. If we are able to scale this value now by [katex]\beta[/katex], so that [katex]a[/katex] becomes either the same order of magnitude or insignificant compared to [katex]u[/katex], then the denominator simply becomes [katex]u[/katex]. Indeed, for incompressible flows, the CFL number is calculated based on the maximum local velocity rather than the maximum eigenvalue.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, let's say that our velocities are of the order of [katex]1[/katex], then our time step becomes:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\Delta t=\frac{1\cdot 10^{-6}}{1}=10^{-6}\, s</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Before we had 33,333,333 time steps required to resolve a single vortex shedding period, this reduces no by two orders of magnitude, i.e. to [katex](1/f)/(\Delta t)=(1/3)/10^{-6}=333,333[/katex] time steps required per vortex shedding period. Even though this change seems small, with a good high-performance cluster, even a large and complex case, this small change can be the difference between 1 day of computation vs 100 days of computation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, by optimising the [katex]\beta[/katex] value, we can (in theory) reduce the number of iterations required to reach convergence. But as mentioned before, a value of [katex]\beta=1[/katex] is typically best.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you want to play around with this parameter, you can try the range of [katex]0.1\le\beta\le 10[/katex], these tend to work well. A while ago, I did test it for a wide range of values. This is what I obtained:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5213,"width":"600px","sizeSlug":"large","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://cfd.university/wp-content/uploads/2025/04/beta_parameter_tunig_for_artificial_compressibility_method-1024x745.png" alt="" class="wp-image-5213" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>On the left y-axis, you see the number of iterations required, and on the right y-axis, the time taken (in seconds) to get a solution. On the x-axis, we see different values for the [katex]\beta[/katex] parameter. I have tested this for one test case and different numerical schemes (where RS stands for Riemann solver). For other test cases, this will likely look slightly different, but you will probably always get an optimum around [katex]\beta=1[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And this is all there is to the artificial compressibility method. It is a quick and easy method to implement for incompressible flows, and I would strongly recommend starting with this formulation first when you are writing an incompressible Navier-Stokes equation solver. It is very quick to get an implementation with this equation, and we don't have to mess with linear systems here, which is a bonus. This cannot be said for the remaining equations we will look at, so let's have a look at them next.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-pressure-projection-based">Exact projection methods: The fractional step, pressure projection</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Chorin gave us the artificial compressibility method (ACM), and if you ever walk the Monaco Formula 1 track, you will lots of appreciation for the ACM. They have placed road signs everywhere and even created a medal of honour that any citizen receives who understands the ACM. Don't believe me? Here is proof (go on, you have my permission to have a virtual walk around Monaco on google earth, I'll wait here ...) </p>
<!-- /wp:paragraph -->

<!-- wp:columns -->
<div class="wp-block-columns"><!-- wp:column -->
<div class="wp-block-column"><!-- wp:image {"id":5220,"width":"auto","height":"300px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="https://cfd.university/wp-content/uploads/2025/04/acm_road_sign.jpeg" alt="" class="wp-image-5220" style="width:auto;height:300px"/><figcaption class="wp-element-caption">Road signage in Monaco</figcaption></figure>
<!-- /wp:image --></div>
<!-- /wp:column -->

<!-- wp:column -->
<div class="wp-block-column"><!-- wp:image {"id":5221,"width":"auto","height":"300px","sizeSlug":"full","linkDestination":"none","align":"left"} -->
<figure class="wp-block-image alignleft size-full is-resized"><img src="https://cfd.university/wp-content/uploads/2025/04/acm_medal.jpg" alt="" class="wp-image-5221" style="width:auto;height:300px"/><figcaption class="wp-element-caption">Medal of honour</figcaption></figure>
<!-- /wp:image --></div>
<!-- /wp:column --></div>
<!-- /wp:columns -->

<!-- wp:paragraph -->
<p>Look, it's either that or ACM stands for Auto Club de Monaco; you choose which conspiracy theory you believe most ...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But Chorin didn't stop there. He thought, why not introduce a second, completely different method? Why not create some competition for myself? Why not fight fire with fire? His theory was so good that it was not fully understood (in my personal view). In fact, many copy cats sprung up (long before we even used the term copy cats) and feasted on his research without either knowing it (i.e. incompetency) or acknowledging it (i.e. scientific misconduct (fancy word for fraud)). We'll get to that, don't you worry. The SIMPLE method will get some beating today ...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But before we collectively circle the SIMPLE algorithm and stone it as it should have been a long, long time ago, let's first indulge ourselves in the pressure projection method of Chorin. It is pretty ingenious. If it is not obvious by now, I do have a little man crush on Chorin, but don't tell him.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The main problem with the momentum equation for incompressible flows is that it contains the pressure gradient. If the equation only contained the velocity, well, then there wouldn't be any dependence on the pressure and we could solve the momentum equation directly. So Chorin said, "bin it" (I did not check but I'm <em>sure</em> these were his words!) and threw the pressure out. Problem solved. It must be this famous Polish mathematicians' humour. Well, this is the momentum equation that we are getting:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\mathbf{u}^*-\mathbf{u}^n}{\Delta t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = \nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The pressure gradient is gone, but wait, he did it again! Look at the time derivative, it is all messed up. Chorin appears to have a troublesome relation with time derivatives, but it is not as bad as it first seems.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the artificial compressibility method, we scaled the time derivative in the continuity equation. This directly destroyed the time derivative and we no longer had real time but rather pseudo time. But in the equation above, we left the time derivative as it is, so we are still operating in real time, not pseudo time. However, since we removed the pressure, we can no longer claim that the velocity we obtain from this equation represents the velocity at the next time step [katex]n+1[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Instead, we solve the velocity for some intermediate velocity field [katex]\mathbf{u}^*[/katex], which is somewhere between time level [katex]n[/katex] and [katex]n+1[/katex]. For this reason, we have to write the time derivative in discretised form, and we call the equation above a semi-discretised equation as a result (you may see this term used in the literature).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can't ignore the pressure indefinitely, though, and eventually, we have to face it. What Chorin did was to use the so called fractional step procedure. This procedure allows you to split partial differential equation (or ordinary ones) into several equations and solve them individually. The way that it works is to write each dropped term (here the pressure gradient) as its own fractional step. Each fractional step will then advance the time derivative from the intermediate velocity field to the next time level.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can introduce as many fractional steps as we want, we would just have more intermediate velocity fields. In our case, we have exactly two fractional step, and the second becomes: </p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\mathbf{u}^{n+1}-\mathbf{u}^*}{\Delta t} = -\frac{1}{\rho}\nabla p</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, the time derivative advances the solution in time from the intermediate velocity field [katex]\mathbf{u}^*[/katex], not the old velocity field [katex]\mathbf{u}^n[/katex], and goes to the next time level at [katex]n+1[/katex]. We have to collect terms on the right-hand side that we have dropped in the previous fractional step, i.e. here the pressure gradient.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So why does that work? Well, it's easy to prove that both fractional steps are consistent with the original momentum equation, yet I have never seen this proof written down (perhaps I haven't looked very far?!). But once you have seen it, this fractional step procedure feels very natural. So let's write down the proof (well, proof is perhaps a strong word, I'll show you how it works, I think this is more useful). To do that, let's solve the above equation for the intermediate velocity [katex]\mathbf{u}^*[/katex]. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{u}^*= \frac{\Delta t}{\rho}\nabla p+\mathbf{u}^{n+1}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's insert this expression into the first fractional step:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\left(\frac{\Delta t}{\rho}\nabla p+\mathbf{u}^{n+1}\right)-\mathbf{u}^n}{\Delta t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = \nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We split the addition within the parenthesis into two fractions, which yields:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\frac{\Delta t}{\rho}\nabla p}{\Delta t}+\frac{\mathbf{u}^{n+1}-\mathbf{u}^n}{\Delta t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = \nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We simplify the pressure gradient term, as [katex]\Delta t[/katex] appears both in the nominator and denominator. It will vanish and so we are left with:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{\rho}\nabla p+\frac{\mathbf{u}^{n+1}-\mathbf{u}^n}{\Delta t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = \nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Subtracting the pressure gradient, and writing the discretised time derivative as a partial derivative again results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial  t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = - \frac{1}{\rho}\nabla p +\nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>As you can see, we are still solving the same equation, we have just split it into two separate equations. If you wanted, you could write as many fractional steps as you have terms. For example, the following fractional step procedure will also solve the same momentum equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\mathbf{u}^{*}-\mathbf{u}^{n}}{\Delta t}=-(\mathbf{u}\cdot\nabla)\mathbf{u} \\[1em]
\frac{\mathbf{u}^{**}-\mathbf{u}^{*}}{\Delta t}=- \frac{1}{\rho}\nabla p \\[1em]
\frac{\mathbf{u}^{n+1}-\mathbf{u}^{**}}{\Delta t}=\nu\nabla^2\mathbf{u} \\[1em]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Go ahead and solve for [katex]\mathbf{u}^*[/katex] and [katex]\mathbf{u}^{**}[/katex] as we did before, and insert into modify the equation until you recover the momentum equation. You will always get back to that equation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This three stage algorithm looks, in equations, very different from Chorin's pressure projection method, so why don't we call it the tom algorithm? Obviously, I am taking the piss here, but this is, in essence, what the SIMPLE algorithm does, and this is, why I have some beef with it. It uses a different mathematical representation, but it solves, in the end, the same equations. Under specific conditions, the SIMPLE algorithm and the pressure projection method become almost identical!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Anyways, so why does this fractional step procedure help us? Well, as we have so any idiot (me) can split the equation in as many fractional steps as they want. The genius idea of Chorin was to isolate the pressure, and the pressure only (as we saw, we only have two fractional steps). This means that the first fractional step depends only on the velocity field, which we can solve. However, the second fractional step consisted of the pressure that we did not know. But let's have another look at Chorin's second fractional step. We saw it was given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\mathbf{u}^{n+1}-\mathbf{u}^*}{\Delta t} = -\frac{1}{\rho}\nabla p</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Yes, we do not know the pressure, but, since we have a mechanism to compute the intermediate velocity field, [katex]\mathbf{u}^*[/katex] is no longer unknown. So if the pressure is unknown, we have to turn our attention to the other unknown in this equation, i.e. [katex]\mathbf{u}^{n+1}[/katex]. Do we know this value? Not precisely, but we know that the incompressible continuity equation is given as [katex]\nabla\cdot\mathbf{u}=0[/katex]. So the idea now is to use the continuity equation to get rid of [katex]\mathbf{u}^{n+1}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The idea here is that the continuity equation has to be satisfied for each time step. So the velocity field at [katex]n[/katex] and [katex]n+1[/katex] has to satisfy [katex]\nabla\cdot\mathbf{u}=0[/katex]. This means [katex]\nabla\cdot\mathbf{u}^n=\nabla\cdot\mathbf{u}^{n+1}=0[/katex]. But what about [katex]\nabla\cdot\mathbf{u}^*[/katex]?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The continuity equation is only valid for a fluid that follows the incompressible Navier-Stokes equation. But, we obtained this intermediate velocity field [katex]\mathbf{u}^*[/katex] from the modified momentum equation and therefore the velocity field will not satisfy the Navier-Stokes equation. As a result, [katex]\nabla\cdot\mathbf{u}^*\ne 0[/katex]. This is good news, because we can now multiply each term with the divergence operator as: </p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\overbrace{\nabla\cdot\mathbf{u}^{n+1}}^{=0}-\overbrace{\nabla\cdot\mathbf{u}^*}^{\ne 0}}{\Delta t} = -\frac{1}{\rho}\nabla\cdot\nabla p</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If you look up the pressure projection method in the literature, you will also hear that we have used the Helmholtz-Hodge decomposition, where we have separated the velocity field into an irrotational and sinusoidal part. Instead of saying "we can decompose the velocity field", people also say that "the velocity field is projected onto an irrotational and sinusodial space".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Engineers tend to use the word decomposition, while Mathematicians think in terms of projections. They refer to one and the same thing (at least in this context), and this is where the term pressure projection is coming from. If you buy a book for £50 and there is a 20% VAT on the sales price, then we can decompose the book price into £40 profit for the publisher or author and £10 sales tax for the government. Or we could say that the sales price can be projected onto a publisher profit space and a sales tax space.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So if you hear the terminology Helmholtz-Hodge decomposition, or projection operator, think: [katex]\nabla\cdot\mathbf{u}^{n+1}=0[/katex]. This is why we use it. Fancy words to describe one and the same thing.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As we can see from the equation above, we can remove the term involving [katex]\nabla\cdot\mathbf{u}^{n+1}[/katex] and the right-hand side becomes the laplacian operator for the pressure.</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{-\nabla\cdot\mathbf{u}^*}{\Delta t} = -\frac{1}{\rho}\nabla^2 p</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Solving this for the pressure results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\nabla^2 p=\frac{\rho}{\Delta t}\nabla\cdot\mathbf{u}^*</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>So, now that we have the intermediate velocity field [katex]\mathbf{u}^*[/katex], we can compute the pressure field [katex]p[/katex] as a result. Let's look at the second fractional step again:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\mathbf{u}^{n+1}-\mathbf{u}^*}{\Delta t} = -\frac{1}{\rho}\nabla p</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We haven't actually used this equation yet, we have only used a derived form of it. So, we do know what the pressure is now, as well as the intermediate velocity field. The only unknown is the velocity [katex]\mathbf{u}^{n+1}[/katex]. So let's solve this equation for it. This produces:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{u}^{n+1}=\mathbf{u}^* -\frac{\Delta t}{\rho}\nabla p</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>And with that, we have found a way to compute both the pressure and the velocity at the next time step. Cool, let's write the equation in a form that we can implement, i.e. a discretised form.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The first equation we need to solve is the momentum equation with the pressure removed. We had:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\mathbf{u}^*-\mathbf{u}^n}{\Delta t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = \nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Using the [katex]\mathrm{upwind}(\phi)[/katex] and [katex]\mathrm{diffusion}(\phi)[/katex] operator from the previous section, we can write this equation as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\mathbf{u}^*_{i,j,k}-\mathbf{u}^n_{i,j,k}}{\Delta t}+\mathrm{upwind}(\mathbf{u})=\mathrm{diffusion}(\mathbf{u})\\[1em]
\mathbf{u}^*_{i,j,k} = \mathbf{u}^n_{i,j,k} + \Delta t\left[ -\mathrm{upwind}(\mathbf{u}) + \mathrm{diffusion}(\mathbf{u}) \right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The scalar equations for [katex]\mathbf{u}=[u,\, v,\, w[/katex] can then be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u^*_{i,j,k} = u^n_{i,j,k} + \Delta t\left[ -\mathrm{upwind}(u) + \mathrm{diffusion}(u) \right]\\[1em]
v^*_{i,j,k} = v^n_{i,j,k} + \Delta t\left[ -\mathrm{upwind}(v) + \mathrm{diffusion}(v) \right]\\[1em]
w^*_{i,j,k} = w^n_{i,j,k} + \Delta t\left[ -\mathrm{upwind}(w) + \mathrm{diffusion}(w) \right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>With the intermediate velocity field available, we can solve the pressure Poisson equation, which we obtained as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\nabla^2 p=\frac{\rho}{\Delta t}\nabla\cdot\mathbf{u}^*</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>There is one small problem here, can you spot it? We no longer have a time derivative, so we are unable to use a simple explicit time integration. As we have discussed in my <a href="https://cfd.university/learn/how-to-compile-write-and-use-cfd-libraries-in-c/how-to-write-a-cfd-library-discretising-the-model-equation/" target="_blank" rel="noopener" title="">article on how to discretise the steady state heat diffusion equation</a>, i.e. [katex]\alpha(\partial^2 T/\partial x^2)=0[/katex], whenever we want to obtain the solution to an equation where there is no time derivative, we have to use an implicit discretisation. This means we are now evaluating the pressure in the equation above at [katex]p^{n+1}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Using a second-order central scheme for the pressure and a central scheme for the intermediate velocity field, and bringing the term [katex]\rho/\Delta t[/katex] on the left-hand side, the Poisson equation is written in discretised form as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\Delta t}{\rho}\frac{p^{n+1}_{i+1,j,k}-2p^{n+1}_{i,j,k}+p^{n+1}_{i-1,j,k}}{\Delta x^2}+\frac{\Delta t}{\rho}\frac{p^{n+1}_{i,j+1,k}-2p^{n+1}_{i,j,k}+p^{n+1}_{i,j-1,k}}{\Delta y^2}+\frac{\Delta t}{\rho}\frac{p^{n+1}_{i,j,k+1}-2p^{n+1}_{i,j,k}+p^{n+1}_{i,j,k-1}}{\Delta z^2}=\\[1em]

\left(\frac{u^*_{i+1,j,k}-u^*_{i-1,j,k}}{2\Delta x}+\frac{u^*_{i,j+1,k}-u^*_{i,j-1,k}}{2\Delta y}+\frac{u^*_{i,j,k+1}-u^*_{i,j,k-1}}{2\Delta z}\right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we factor out all the terms that go in front our pressure. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>p^{n+1}_{i+1,j,k}\left(\frac{\Delta t}{\rho\Delta x^2}\right) + p^{n+1}_{i,j,k}\left(\frac{-2\Delta t}{\rho\Delta x^2}\right) + p^{n+1}_{i-1,j,k}\left(\frac{\Delta t}{\rho\Delta x^2}\right) + \\[1em]
p^{n+1}_{i,j+1,k}\left(\frac{\Delta t}{\rho\Delta y^2}\right) + p^{n+1}_{i,j,k}\left(\frac{-2\Delta t}{\rho\Delta y^2}\right) + p^{n+1}_{i,j-1,k}\left(\frac{\Delta t}{\rho\Delta y^2}\right) +\\[1em]
p^{n+1}_{i,j,k+1}\left(\frac{\Delta t}{\rho\Delta z^2}\right) + p^{n+1}_{i,j,k}\left(\frac{-2\Delta t}{\rho\Delta z^2}\right) + 
p^{n+1}_{i,j,k-1}\left(\frac{\Delta t}{\rho\Delta z^2}\right)
=\\[1em]
\frac{u^*_{i+1,j,k}-u^*_{i-1,j,k}}{2\Delta x}+\frac{u^*_{i,j+1,k}-u^*_{i,j-1,k}}{2\Delta y}+\frac{u^*_{i,j,k+1}-u^*_{i,j,k-1}}{2\Delta z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Combining presure terms at location [katex]i,\, j,\, k[/katex], we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>p^{n+1}_{i,j,k}\left(\frac{-2\Delta t}{\rho\Delta x^2}+\frac{-2\Delta t}{\rho\Delta y^2}+\frac{-2\Delta t}{\rho\Delta z^2}\right) +\\[1em]
p^{n+1}_{i+1,j,k}\left(\frac{\Delta t}{\rho\Delta x^2}\right) + p^{n+1}_{i-1,j,k}\left(\frac{\Delta t}{\rho\Delta x^2}\right) + \\[1em]
p^{n+1}_{i,j+1,k}\left(\frac{\Delta t}{\rho\Delta y^2}\right) + p^{n+1}_{i,j-1,k}\left(\frac{\Delta t}{\rho\Delta y^2}\right) +\\[1em]
p^{n+1}_{i,j,k+1}\left(\frac{\Delta t}{\rho\Delta z^2}\right) + p^{n+1}_{i,j,k-1}\left(\frac{\Delta t}{\rho\Delta z^2}\right)
=\\[1em]
\frac{u^*_{i+1,j,k}-u^*_{i-1,j,k}}{2\Delta x}+\frac{u^*_{i,j+1,k}-u^*_{i,j-1,k}}{2\Delta y}+\frac{u^*_{i,j,k+1}-u^*_{i,j,k-1}}{2\Delta z}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>By setting the following coefficients:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p = \left(\frac{-2\Delta t}{\rho\Delta x^2}+\frac{-2\Delta t}{\rho\Delta y^2}+\frac{-2\Delta t}{\rho\Delta z^2}\right)\\[1em]
a_w = \left(\frac{\Delta t}{\rho\Delta x^2}\right)\\[1em]
a_e = \left(\frac{\Delta t}{\rho\Delta x^2}\right)\\[1em]
a_n = \left(\frac{\Delta t}{\rho\Delta y^2}\right)\\[1em]
a_s = \left(\frac{\Delta t}{\rho\Delta y^2}\right)\\[1em]
a_f = \left(\frac{\Delta t}{\rho\Delta z^2}\right)\\[1em]
a_b = \left(\frac{\Delta t}{\rho\Delta z^2}\right)\\[1em]
b = \frac{u^*_{i+1,j,k}-u^*_{i-1,j,k}}{2\Delta x}+\frac{u^*_{i,j+1,k}-u^*_{i,j-1,k}}{2\Delta y}+\frac{u^*_{i,j,k+1}-u^*_{i,j,k-1}}{2\Delta z}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can write our pressure Poisson equation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p\cdot p^{n+1}_{i,j,k} + a_e\cdot p^{n+1}_{i+1,j,k} + a_w\cdot p^{n+1}_{i,j-1,k} + a_n\cdot p^{n+1}_{i,j+1,k} + a_s\cdot p^{n+1}_{i,j-1,k} + a_f\cdot p^{n+1}_{i,j,k+1} + a_b\cdot p^{n+1}_{i,j,k-1} = b</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Or, in compact form:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p\cdot p^{n+1}_{i,j,k} + \sum_{f}^{nNeighbours} a_f \cdot p^{n+1}_f = b</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Solving this for [katex]p^{n+1}_{i,j,k}[/katex], i.e. the varible we want to solve for, we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>p^{n+1}_{i,j,k} = \frac{1}{a_p}\left(b - \sum_{f}^{nNeighbours} a_f \cdot p^{n+1}_f \right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we have the problem that we have [katex]p^{n+1}[/katex] on both the left and right-hand side of the equation. To find a solution to this problem, we modify this equation, which now reads:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>p^{n+1,m+1}_{i,j,k} = \frac{1}{a_p}\left(b - \sum_{f}^{nNeighbours} a_f \cdot p^{n+1,m}_f \right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, we have introduced another time index [katex]m[/katex] for the pressure, which indicates that we have to solve the above equation iteratively until we have reached a converged solution, i.e. until [katex]p^{n+1,m+1}\approx p^{n+1, m}[/katex]. We can check that by taking the difference between the two, and if the the difference is below a predefined convergence threshold, for example, [katex]\epsilon = 10^{-4}[/katex], then we can stop the iterative loop.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The algorithm described above is known as the Jacobi method. It is the slowest method to reach a converged solution for an implicit discretisation. There are much better solution algorithms available, but these require us to provide the coefficient matrix [katex]\mathbf{A}[/katex], i.e. we need to construct the following system of equations:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{A}p=\mathbf{b}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can write out this equation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\begin{bmatrix}
a_p &amp; a_e &amp;  \dots &amp; a_n &amp; \dots &amp; a_f &amp; \dots &amp; 0\\
a_w &amp; a_p &amp; a_e &amp; &amp; \ddots &amp; &amp; \ddots &amp; \vdots \\
\vdots &amp; \ddots &amp; \ddots &amp; \ddots &amp; &amp; \ddots &amp; &amp; a_f\\
a_s &amp; &amp; \ddots &amp; \ddots  &amp; \ddots &amp; &amp; \ddots &amp; \vdots \\
\vdots &amp; \ddots &amp; &amp; \ddots &amp; \ddots &amp; \ddots &amp; &amp; a_n \\
a_b &amp; &amp; \ddots &amp;  &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots \\
\vdots &amp; \ddots &amp; &amp; \ddots &amp; &amp; a_w &amp; a_p  &amp; a_e \\
0 &amp; \dots &amp; a_b &amp; \dots &amp;  a_s &amp; \dots &amp; a_w&amp; a_p \\
\end{bmatrix}
p=
\mathbf{b}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The right-hand side vector will contain the divergence of the velocity, as well as boundary conditions close to the boundaries. Once we have constructed both the coefficient matrix [katex]\mathbf{A}[/katex] and the right-hand side vector [katex]\mathbf{b}[/katex], we can use an algorithm such as the Conjugate Gradient algorithm to solve for the pressure [katex]p[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you have missed it, I have written an entire <a href="https://cfd.university/learn/how-to-compile-write-and-use-cfd-libraries-in-c/" target="_blank" rel="noopener" title="">series on how to implement the Conjugate Gradient algorithm</a> and solve equations like the one above. If you want to speed up your convergence, then this is likely what you want to implement. The Conjugate Gradient algorithm is what you would find in commercial and more serious open-source CFD solvers to solve the implicit equation, in this case, the pressure Poisson equation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Whichever way to choose for the pressure [katex]p[/katex], eventually, you will end up with values for [katex]p^{n+1}[/katex]. Once we have these values, we saw that we can obtain the updated velocity field as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{u}^{n+1}=\mathbf{u}^* -\frac{\Delta t}{\rho}\nabla p</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Using a central difference approximation for the pressure gradient term, this can be written in discretised form as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u^{n+1}_{i,j,k}=u^*_{i,j,k} -\frac{\Delta t}{\rho}\frac{p^{n+1}_{i+1,j,k}-p^{n+1}_{i-1,j,k}}{2\Delta x}\\[1em]
v^{n+1}_{i,j,k}=v^*_{i,j,k} -\frac{\Delta t}{\rho}\frac{p^{n+1}_{i,j+1,k}-p^{n+1}_{i,j-1,k}}{2\Delta x}\\[1em]
w^{n+1}_{i,j,k}=w^*_{i,j,k} -\frac{\Delta t}{\rho}\frac{p^{n+1}_{i,j,k+1}-p^{n+1}_{i,j,k-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>And now you know how to implement the pressure projection method as well. But, there is one more family of algorithms to explore. It is time to face the villain; the SIMPLE algorithm and its thug friends (SIMPLER, SIMPLEC, PISO, PIMPLE).</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-pressure-projection-based">Approximate projection methods: The SIMPLE method and its derivatives</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Chorin introduced the notion of pressure projection methods, and we said it was a projection method because we decomposed (or projected) the velocity into an irrotational and sinusoidal part (or irrotational and sinusoidal space). We can write this as [katex]\mathbf{u}=\mathbf{u}^\mathrm{irrotational} + \mathbf{u}^\mathrm{sinusodial}[/katex]. Keep this decomposition/projection in mind for later.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Chorin's pressure projection algorithm was introduced in 1968, and 4 years later, Patankar and Spalding gave us the SIMPLE algorithm in 1972. SIMPLE is an acronym standing for Semi-Implicit Method for Pressure Linked Equations (actually, that should be SIMfPLE ... anyways). We will see later where this semi-implicit nature is coming from. As I have alluded to in the previous sections, the SIMPLE algorithm has so much resemblance to Chorin's pressure projection method that, in my view, it is, at best, a modification but not a new method in its own right!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For crying out loud, SIMPLE, SIMPLER, SIMPLEC, PISO, and all of these variants all use the same fundamental building blocks, and all derive from Chorin's pressure projection. We call these methods <em>approximate</em> projection method, and this approximation actually makes SIMPLE and co less rigorous compared to Chorin's method! The reason we have so many variants of SIMPLE (i.e. SIMPER and SIMPLEC) is because of the approximations made in SIMPLE, and each new variant tries to bring back some rigour into the algorithm.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, there are still small differences, but we will explore those differences in detail, and you will see that these differences do not warrant new methods being released to the world.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The other issue I have with the SIMPLE algorithm, and this is not (entirely) Patankar's fault, is the way the SIMPLE algorithm is introduced in the literature. Sure, in 1972, I understand why people were using staggered grids. And no, I'm not going to introduce staggered grids here as they are outdated. No one (serious about CFD) is still using staggered grids, and we have alternative cures for the issue stemming from co-located grids (storing and solving all variables at the same location, e.g. cell centroid or vertices), typically by using the Rhie-Chow interpolation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>No, we will look at how the SIMPLE algorithm works on a normal grid. Patankar did introduce the SIMPLE algorithm for staggered grids, and most textbooks that talk about the SIMPLE algorithm have pretty much just copied and pasted that description. Yet, any textbook talking about the pressure projection method (which suffers from exactly the same issue) does not talk about the need for staggered grids. So the presentation of the SIMPLE algorithm is just needlessly complex in textbooks, and I remember being very confused about it when I was a student.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To follow the textbook derivation as given by Patankar in his 1980 book <em>Numerical Heat Transfer and Fluid Flow</em> (which is also repeated in Versteeg and Malalasekera's book, well, their book has pretty much copied and pasted chapter 4-6 from Patankar's book, which appears in chapter 4-6 in their book), we need to start by discretising the momentum equation. I'll do a one-dimension consideration here, which we will later generalise to three dimensions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The momentum equation was given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u}\cdot\nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In the SIMPLE algorithm, we assume an implicit discretisation for the velocity. Thus, all velocity components are evaluated at time level [katex]n+1[/katex]. Since we can only solve for one variable per equation, we can't have an implicit treatment for the pressure, and it is evaluated at time level [katex]n[/katex] (in other words, we assume the pressure to be known, either from the previous timestep or the initial solution). This is what SI in SIMPLE stands for: semi-implicit. It is implicit for velocity but explicit for pressure. The equation can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\mathbf{u}^{n+1}-\mathbf{u}^n}{\Delta t} + \left[(\mathbf{u}\cdot\nabla)\mathbf{u}\right]^{n+1} = -\frac{1}{\rho}\nabla p^n + \left[\nu\nabla^2\mathbf{u}\right]^{n+1}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>For a one-dimensional flow (which doesn't really solve anything of interest for incompressible flows, but it does make the derivation easier to follow), we can write the scalar equation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{u^{n+1}-u^n}{\Delta t}+\phi\frac{\partial u^{n+1}}{\partial x}=-\frac{1}{\rho}\frac{\partial p^n}{\partial x} + \nu\frac{\partial^2 u^{n+1}}{\partial x^2}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, I have introduced the linearisation [katex]\phi=u^n[/katex]. We have to do this because implicit equations are solved with linear systems of equations. While these can be extended to solve non-linear systems as well, they are too expensive to solve for very little additional benefit.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's use a first-order upwind discretisation here for the convective flux, a central scheme for the pressure, and the second-order diffusive derivative. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{u_i^{n+1}-u_i^n}{\Delta t}+\max(\phi_i,0)\frac{u^{n+1}_i-u^{n+1}_{i-1}}{\Delta x} + \min(\phi_i,0)\frac{u^{n+1}_{i+1}-u^{n+1}_{i}}{\Delta x}=-\frac{1}{\rho}\frac{p^n_{i+1}-p^n_{i-1}}{2\Delta x} + \nu\frac{u^{n+1}_{i+1}-2u^{n+1}_{i}+u^{n+1}_{i-1}}{\Delta x^2}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Next, we rearrange the equation so that all contributions at time level [katex]n+1[/katex] (in this case, all velocities) are on the left-hand side, while we collect all explicit contributions on the right-hand side. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{u_i^{n+1}}{\Delta t}+\max(\phi_i,0)\frac{u^{n+1}_i-u^{n+1}_{i-1}}{\Delta x} + \min(\phi_i,0)\frac{u^{n+1}_{i+1}-u^{n+1}_{i}}{\Delta x} - \nu\frac{u^{n+1}_{i+1}-2u^{n+1}_{i}+u^{n+1}_{i-1}}{\Delta x^2}=\frac{u_i^n}{\Delta t}-\frac{1}{\rho}\frac{p^n_{i+1}-p^n_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we collect terms that multiply with [katex]u_{i+1}^{n+1}[/katex], [katex]u_{i}^{n+1}[/katex], and [katex]u_{i-1}^{n+1}[/katex], which can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u_{i+1}^{n+1}\left(\frac{\min(\phi_i, 0)}{\Delta x} - \frac{\nu}{\Delta x^2} \right) +
u_{i}^{n+1}\left(\frac{1}{\Delta t} + \frac{\max(\phi_i,0)}{\Delta x} - \frac{\min(\phi_i, 0)}{\Delta x} + \frac{2\nu}{\Delta x^2} \right) +
u_{i-1}^{n+1}\left(-\frac{\max(\phi_i,0)}{\Delta x} - \frac{\nu}{\Delta x^2} \right) = \\[1em]
\frac{u_i^n}{\Delta t}-\frac{1}{\rho}\frac{p^n_{i+1}-p^n_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can now introduce coefficients to make the equation above a bit easier to write:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_e = \left(\frac{\min(\phi_i, 0)}{\Delta x} - \frac{\nu}{\Delta x^2} \right)\\[1em]
a_w = \left(-\frac{\max(\phi_i,0)}{\Delta x} - \frac{\nu}{\Delta x^2} \right)\\[1em]
a_p = \left(\frac{1}{\Delta t} + \frac{\max(\phi_i,0)}{\Delta x} - \frac{\min(\phi_i, 0)}{\Delta x} + \frac{2\nu}{\Delta x^2} \right)\\[1em]
b_i = \frac{u_i^n}{\Delta t}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This will reduce the equation above to:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_e\cdot u_{i+1}^{n+1} +
a_p \cdot u_{i}^{n+1} +
a_w \cdot u_{i-1}^{n+1} =
b_i-\frac{1}{\rho}\frac{p^n_{i+1}-p^n_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we say that velocities and coefficients at the east and west location, i.e. at [katex]i+1[/katex] and [katex]i-1[/katex], respectively, are neighbour coefficients to the central coefficient [katex]a_p[/katex] at location [katex]i[/katex]. We therefore write these neighbouring coefficients as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>- a_e\cdot u_{i+1}^{n+1}
- a_w \cdot u_{i-1}^{n+1} =
\sum^{numNeighbours}_{nb=0}a_{nb} \cdot u^{n+1}_{nb}=\sum a_{nb} \cdot u^{n+1}_{nb}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In this example, we have [katex]numNeighbours = 2[/katex]. Inserting this into our equation, we arrive at:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot u_{i}^{n+1} -
\sum a_{nb} \cdot u^{n+1}_{nb}
=
b_i-\frac{1}{\rho}\frac{p^n_{i+1}-p^n_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Bringing the summation on the right-hand side, we obtain:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot u_{i}^{n+1}
=
\sum a_{nb} \cdot u^{n+1}_{nb} +
b_i - 
\frac{1}{\rho}\frac{p^n_{i+1}-p^n_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is the starting point for the SIMPLE algorithm in many textbooks, and I just wanted to make sure we get to this equation without missing any steps in the derivation so you can follow this discussion. We solve this equation to obtain a velocity for the next time level [katex]n+1[/katex] by using the pressure from the previous time step. But we also need to find a way to solve for the pressure and to do so requires us to rewrite the equation a bit.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The main idea behind the SIMPLE algorithm is that we replace the velocity and pressure with guessed values. If we guess values for the pressure that satisfy the above-shown momentum equation, then we have a solution. To verify that the solution is physical, the velocity field also needs to satisfy the continuity equation. This is an iterative procedure so we have to loop over the momentum equation and iteratively update the pressure until both the continuity and momentum equation are satisfied.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Therefore, the first step in the SIMPLE algorithm to construct an equation for the pressure is to rewrite the above-shown momentum equation in terms of guessed velocity and pressure fields. This is achieved by replacing the time indices [katex]n[/katex] and [katex]n+1[/katex] with [katex]*[/katex], which now indicate that we are using some guessed values. The equation can thus be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot u_{i}^{*}
=
\sum a_{nb} \cdot u^{*}_{nb} +
b_i - 
\frac{1}{\rho}\frac{p^*_{i+1}-p^*_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>A guessed velocity and pressure field, or more generally, an arbitrary value [katex]\phi^*[/katex], can be corrected by some value [katex]\phi'[/katex] to obtain the correct value of [katex]\phi^c[/katex], This can be expressed as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\underbrace{\phi^c}_\mathrm{correct}=\underbrace{\phi^*}_\text{guess}+\underbrace{\phi'}_\text{correction}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Therefore, we can also rewrite our momentum equation with velocities at [katex]u^{n+1}[/katex] as the correct velocities, now expressed as [katex]u[/katex] using the above notation. The correct momentum equation becomes:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot u_{i}^c
=
\sum a_{nb} \cdot u_{nb}^c +
b_i - 
\frac{1}{\rho}\frac{p^c_{i+1}-p^c_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we now subtract the momentum equation containing [katex]\phi^{*}[/katex] (i.e. the guessed velocity and pressure values) from the correct momentum equation (i.e. the one containing [katex]\phi^c[/katex]), then we obtain the following equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot (u_{i}^c-u_i^*)
=
\sum a_{nb} \cdot (u_{nb}^c - u_i^* ) - 
\frac{1}{\rho}\frac{(p^c_{i+1} - p^*_{i+1})-(p^c_{i-1} - p^*_{i-1})}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Since both equations contain the term [katex]b_i[/katex], and we have subtracted one equation from the other, the [katex]b_i[/katex] coefficient has vanished. Three equations earlier, we saw that we can express the correction of a quantity [katex]\phi[/katex] as [katex]\phi'=\phi^c-\phi^*[/katex]. Therefore, we can rewrite the above momentum equation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot u_{i}'
=
\sum a_{nb} \cdot u_{nb}' - 
\frac{1}{\rho}\frac{p'_{i+1}-p'_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This equation now expresses a correction equation. We still can't solve it, but it shows us how the pressure field would have to change in response to a change in velocity. We will use this equation in a second to derive a correction equation for the pressure. But before we do that, let's take a look at how the SIMPLE algorithm treats this equation. It drops the first term on the right-hand side, i.e. the summation over neighbouring velocities and their coefficients. This means the above equation simplifies to:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot u_{i}'
=
- \frac{1}{\rho}\frac{p'_{i+1}-p'_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is the main approximation in the SIMPLE algorithm, and this term is reintroduced (in one way or another) in the SIMPLER (SIMPLE Revised) and SIMPLEC (SIMPLE Consistent) algorithms. In order to make use of this equation, we insert the definition for the correct velocity into this equation. That is, [katex]u'=u^c-u^*[/katex]. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot (u_i^c - u_i^* )
=
- \frac{1}{\rho}\frac{p'_{i+1}-p'_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Solving this equation for the correct velocity [katex]u^*[/katex] gives us:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u_i^c=u^*_i-\frac{1}{\rho a_p}\frac{p'_{i+1}-p'_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let us write out the coefficient for [katex]a_p[/katex]. As a reminder, [katex]a_p[/katex] was given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p = \left(\frac{1}{\Delta t} + \frac{\max(\phi_i,0)}{\Delta x} - \frac{\min(\phi_i, 0)}{\Delta x} + \frac{2\nu}{\Delta x^2} \right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This results in the following expanded velocity correction equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u_i^c=u^*_i-\left(\frac{\Delta t}{\rho} + \frac{\Delta x}{\max(\phi_i,0)\rho} - \frac{\Delta x}{\min(\phi_i,0)\rho} +\frac{\Delta x^2}{2\nu\rho}\right)\frac{p'_{i+1}-p'_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let us now introduce the following coefficient:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_{\Delta x}=\frac{\Delta x}{\max(\phi_i,0)\rho} - \frac{\Delta x}{\min(\phi_i,0)\rho} +\frac{\Delta x^2}{2\nu\rho}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let us also write the velocity correction equation just once using [katex]u^c=u^{n+1}[/katex], as we assume that the correct velocity must be the velocity at the next time level [katex]n+1[/katex]. Then, we can write the equation above as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u_i^{n+1}=u^*_i-\left(\frac{\Delta t}{\rho} + a_{\Delta x} \right)\frac{p'_{i+1}-p'_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's compare that to the velocity correction equation in Chorin's pressure projection algorithm:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u^{n+1}_{i}=u^*_{i} -\frac{\Delta t}{\rho}\frac{p^{n+1}_{i+1}-p^{n+1}_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>I don't know about you, but to me, they look pretty similar. OK, but I hear the Pantankar fanboys (and girls) screaming that there is a coefficient of [katex]a_{\Delta x}[/katex], which depends on [katex]\Delta x[/katex]. Good observation. Let's look at the CFL number for a second, it is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>CFL=u\frac{\Delta t}{\Delta x}\quad \rightarrow\quad \Delta x = u\frac{\Delta t}{CFL}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Thus, the spatial distance [katex]\Delta x[/katex] is proportional to [katex]\Delta t/CFL[/katex]. In other words, as the CFL number is increasing, we have [katex]\Delta x &lt;&lt; \Delta t[/katex]. Therefore, only for small CFL numbers (of the order of one or less) does the coefficient [katex]a_{\Delta x}[/katex] really contribute to the above velocity correction equation. For large CFL values (say, of the order of 10 and larger), both SIMPLE and the pressure projection method of Chorin behave essentially the same.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>OK, let's finish this little detour and come back to the SIMPLE algorithm. We have stolen from the pressure projection, apologies, I meant derived, the velocity correction equation, which was given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u_i^c=u^*_i-\frac{1}{\rho a_p}\frac{p'_{i+1}-p'_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, we take the continuity equation of an incompressible fluid, i.e. [katex]\nabla\cdot \mathbf{u} = 0[/katex], and we want to derive a correction equation for the pressure. The continuity equation will only hold for a physically correct velocity field. In the pressure projection algorithm, we said that using the Helmholtz-Hodge decomposition, we can project (decompose) the velocity field onto an irrotational and sinusoidal part. That is, we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{u}=\mathbf{u}^\text{irrotational}+\mathbf{u}^\text{sinusodial}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is exact, i.e. this holds true for any vector field in a mathematical sense. Therefore, we say that Chorin's projection method is an exact pressure projection. How about the simple method? Well, we already introduced the correction equation, which was given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi^c=\phi^*+\phi'</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We use different terms here, like guessed or initial value and corrected value, but in the end, both concepts represent the same thing. However, since in a strict mathematical sense, we need to iteratively satisfy the equation for \[katex]\phi^c[/katex], we say that this is an approximate pressure projection method.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For the pressure projection, we said that the velocity at time level [katex]n+1[/katex] satisfies the continuity equation, i.e. [katex]\nabla\cdot\mathbf{u}^{n+1}=0[/katex], but the intermediate velocity [katex]\mathbf{u}^*[/katex] does not, i.e. we have [katex]\nabla \cdot \mathbf{u}^*\ne 0[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>By analogy, the same is true for the SIMPLE algorithm. We have [katex]\nabla \cdot \mathbf{u}^c = 0[/katex], but [katex]\nabla \cdot \mathbf{u}^* \ne 0[/katex]. Therefore, if we want to use the continuity equation, we have to use it with respect to the correct velocity [katex]u^c[/katex], for which we have derived the correction equation above.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let us first write the scalar, discretised continuity equation using a central differencing scheme, still in one dimension. This results in: </p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\nabla\cdot\mathbf{u}=\nabla\cdot\mathbf{u}^c=\nabla \cdot u^c=\frac{\partial u^c}{\partial x}=\frac{u^c_{i+1}-u^c_{i-1}}{2\Delta x}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we insert the velocity correction equation, which results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{2\Delta x}\left[\left(u^*_{i+1}-\frac{1}{\rho a_p}\frac{p'_{i+2}-p'_{i}}{2\Delta x}\right)-\left(u^*_{i-1}-\frac{1}{\rho a_p}\frac{p'_{i}-p'_{i-2}}{2\Delta x}\right)\right]=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In this equation, everything is known except for the pressure. The velocity [katex]u^*[/katex] is the guessed velocity (i.e. from the previous time step or initial solution) while [katex]a_p[/katex] contains only known coefficients. Therefore, we can solve this equation for the pressure now. We start by expanding the brackets. This leads to:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{u^*_{i+1}}{2\Delta x}-\frac{1}{\rho a_p}\frac{p'_{i+2}-p'_{i}}{4\Delta x^2}-\frac{u^*_{i-1}}{2\Delta x}+\frac{1}{\rho a_p}\frac{p'_{i}-p'_{i-2}}{4\Delta x^2}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we multiply by [katex]\rho a_p[/katex] and we merge fractions, this results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\rho a_p\frac{u^*_{i+1}-u^*_{i+1}}{2\Delta x}-\frac{p'_{i+2}-2p'_{i}+p'_{i-2}}{4\Delta x^2}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, we place the velocity on the right-hand side, which results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{p'_{i+2}-2p'_{i}+p'_{i-2}}{4\Delta x^2}=\rho a_p\frac{u^*_{i+1}-u^*_{i+1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Can we express the pressure term on the left-hand side differently? Well, let's see what happens if we expand a Taylor series around [katex]i+2[/katex] and [katex]i-2[/katex]. Then we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>p(x+2\Delta x)=p(x)+\frac{\partial p}{\partial x}(2\Delta x)+\frac{\partial^2 p}{\partial x^2}\frac{(2\Delta x)^2}{2!}+\mathcal{O}(\Delta x^3)\\[1em]
p(x-2\Delta x)=p(x)-\frac{\partial p}{\partial x}(2\Delta x)+\frac{\partial^2 p}{\partial x^2}\frac{(2\Delta x)^2}{2!}+\mathcal{O}(\Delta x^3)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's add these two equation together:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>p(x+2\Delta x) + p(x-2\Delta x) = 2p(x) + \frac{2}{2!}\frac{\partial^2 p}{\partial x^2}(2\Delta x)^2</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we solve this for the second-order derivative, we obtain (with [katex](2\Delta x)^2=2^2\Delta x^2=4\Delta x^2[/katex]):</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial^2 p}{\partial x^2} = \frac{p(x+2\Delta x) - 2p(x) + p(x-2\Delta x)}{4\Delta x^2}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we now introduce discrete locations for [katex]x[/katex], where we have location [katex]i[/katex] at [katex]x[/katex], [katex]i+2[/katex] at [katex]x+2\Delta x[/katex] and [katex]i-2[/katex] at [katex]x-2\Delta x[/katex], then we have: </p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial^2 p}{\partial x^2} = \frac{p_{i+2} - 2p_i + p_{i-2}}{4\Delta x^2}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Therefore, our pressure correction equation, i.e.:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{p'_{i+2}-2p'_{i}+p'_{i-2}}{4\Delta x^2}=\rho a_p\frac{u^*_{i+1}-u^*_{i+1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>can now be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial^2 p'}{\partial x^2}=\rho a_p\frac{\partial u^*}{\partial x} \quad\rightarrow\quad \nabla^2 p'=\rho a_p\nabla\cdot \mathbf{u}^*</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Thus, we have to solve this pressure Poisson equation to get values for the corrected pressure values [katex]p'[/katex]. Looks familiar? Well, let's see how we solved the pressure in Chorin's pressure projection method, we had:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\nabla^2 p=\frac{\rho}{\Delta t}\nabla\cdot\mathbf{u}^*</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let us expand [katex]a_p[/katex] again in the pressure correction equation. Then we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\nabla^2 p'=\left(\frac{\rho}{\Delta t}+\frac{1}{a_{\Delta x}}\right)\nabla\cdot \mathbf{u}^*</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We see again the same coefficient as in the pressure projection method of Chorin. In addition, we get [katex]a_{\Delta x}[/katex] again, though now we have to take the inverse, i.e. [katex]1/a_{\Delta x}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is the SIMPLE algorithm of Patankar and Spalding. It appeared 4 years after the pressure projection method of Chorin was published, and people got accused and found guilty of <a href="https://www.youtube.com/watch?v=8_ZRZccKmvg" target="_blank" rel="noopener" title="">far stronger cases of academic misconduct</a>. I will say this, though: Chorin published his work in predominantly mathematical circles, while Patankar's work was published in more engineering-orientated circles. If you had to conduct a literature review back in the 1970s (without the internet and Google), your literature review could only be as good as the printed journals available in your library.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While I'm sure the work of Chorin would have been available to Patankar and Spalding, they may not have thought of looking through applied mathematical journals. Thus, even though I was critical of the work of Patankar, I suppose he has plausible deniability. This doesn't mean, though, that we have to keep using the SIMPLE algorithm or any of its siblings when the pressure projection algorithm is essentially the same, with a more rigorous mathematical foundation to support its derivation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There is one main difference between these two methods that we have not yet looked at. And that is the momentum equation. In the SIMPLE algorithm, we retain the pressure gradient, while in the pressure projection algorithm of Chorin, we do not. We saw that in the SIMPLE algorithm, this leads to a semi-implicit behaviour in the pressure, where the velocity is solved at time level [katex]n+1[/katex] while the pressure is solved explicitly at time level [katex]n[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The pressure projection method of Chorin is fully implicit (if we want, we can also solve the equation fully explicit). Since only the velocity appears in the first fractional step of the momentum equation, we can solve the equation fully implicitly, which means that we can choose a CFL number that is arbitrarily large. In the SIMPLE algorithm, we have to solve the equations implicitly, but we are restricted in the CFL number due to the explicit contribution from the pressure.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Furthermore, since we have made quite a few approximations with the simple algorithm (e.g. dropping the neighbouring contributions of velocity and its coefficients), the SIMPLE algorithm is prone to slow convergence. Thus, we can summarise the SIMPLE algorithm as:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Slow convergence + limited CFL number (despite implicit treatment) + less mathematical rigour + plagiarism = most used pressure velocity coupling algorithm for incompressible flows. </strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>CFD is fascinating if you look into the details, isn't it?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There is one more thing I want to do before I let you go. I want to take the equations we have derived here and put them into a matrix form. This uses a different notation, but it is one you will find in the literature as well, especially when you are dealing with OpenFOAM. Seeing them in one place will help to connect the equations when you find them.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We start with our correction momentum equation. This was given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot u_{i}^{n+1}
=
\sum a_{nb} \cdot u^{n+1}_{nb} +
b_i - 
\frac{1}{\rho}\frac{p^n_{i+1}-p^n_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we collect velocities at time level [katex]n+1[/katex] on the left-hand side, we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot u_{i}^{n+1} -
\sum a_{nb} \cdot u^{n+1}_{nb} 
=
b_i - 
\frac{1}{\rho}\frac{p^n_{i+1}-p^n_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let us now expand the summation again so we see all velocities explicitly. This is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot u_{i}^{n+1} -
a_{e} \cdot u^{n+1}_{e} - 
a_{w} \cdot u^{n+1}_{w}
=
b_i - 
\frac{1}{\rho}\frac{p^n_{i+1}-p^n_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Instead of using indices for the east and west nodes, we write this equation index [katex]i[/katex] instead. Thus, the node at location [katex]e[/katex] is located at [katex]i+1[/katex] and [katex]w[/katex] is located at [katex]i-1[/katex]. The coefficient [katex]a_p[/katex] is now also evaluated at location [katex]i[/katex], just like the velocity that it multiplies. This is then given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>-a_{i-1} \cdot u^{n+1}_{i-1} +
a_i \cdot u_{i}^{n+1} -
a_{i+1} \cdot u^{n+1}_{i+1}
=
b_i - 
\frac{1}{\rho}\frac{p^n_{i+1}-p^n_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This equation can then be written in matrix form:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\begin{bmatrix}
a_1 &amp; -a_2 &amp; 0 &amp; \dots &amp; &amp; 0 &amp; 0 &amp; 0\\[1em]
-a_1 &amp; a_2 &amp; -a_3 &amp;0 &amp; \dots &amp; &amp; &amp; 0\\[1em]
0 &amp; -a_2 &amp; a_3 &amp; -a_4 &amp; 0 &amp; \dots &amp; &amp; 0\\[1em]
\vdots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; &amp; \vdots\\[1em]
\vdots &amp; &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \vdots\\[1em]
0 &amp;  &amp; \dots &amp; 0 &amp; -a_{n-3} &amp; a_{n-2} &amp; -a_{n-1} &amp; 0\\[1em]
0 &amp;  &amp; &amp; \dots &amp; 0 &amp; -a_{n-2} &amp; a_{n-1} &amp; -a_{n}\\[1em]
0 &amp; 0 &amp; 0 &amp; &amp; \dots &amp; 0 &amp; -a_{n-1} &amp; a_{n}\\[1em]
\end{bmatrix}

\begin{bmatrix}
u_1\\[1em]
u_2\\[1em]
u_3\\[1em]
\vdots\\[1em]
\vdots\\[1em]
u_{n-2}\\[1em]
u_{n-1}\\[1em]
u_n\\[1em]
\end{bmatrix}
=
\begin{bmatrix}
b_1-\frac{1}{\rho}\frac{p_2-p_\text{left boundary}}{2\Delta x}\\[1em]
b_2-\frac{1}{\rho}\frac{p_3-p_1}{2\Delta x}\\[1em]
b_3-\frac{1}{\rho}\frac{p_4-p_2}{2\Delta x}\\[1em]
\vdots\\[1em]
\vdots\\[1em]
b_{n-2}-\frac{1}{\rho}\frac{p_{n-1}-p_{n-3}}{2\Delta x}\\[1em]
b_{n-1}-\frac{1}{\rho}\frac{p_n-p_{n-2}}{2\Delta x}\\[1em]
b_n-\frac{1}{\rho}\frac{p_{\text{right boundary}}-p_{n-1}}{2\Delta x}\\[1em]
\end{bmatrix}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now let's say that we are at the second node, i.e. [katex]i=2[/katex]. Looking at the matrix equation above, we could write the equation for node 2 as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>-a_1\cdot u_1^{n+1} + a_2\cdot u_2^{n+1} - a_3 \cdot u_3^{n+1} = b_2 - \frac{1}{\rho}\frac{p_3^n - p_1^n}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can see that this is equivalent to the equation we expressed for the general location [katex]i[/katex] before. We can now write this matrix equation in a more compact form:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{\mathcal{M}}\mathbf{U}^{n+1}=\mathbf{RHS}(\mathbf{b}(\mathbf{U}^n), \nabla p^n)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is the equation we are solving to get an initial velocity field. But we also use this equation to derive the correction equation for the pressure. We saw that the first step requires us to derive a correction equation, which we saw was given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a_p \cdot u_{i}'
=
\sum a_{nb} \cdot u_{nb}' - 
\frac{1}{\rho}\frac{p'_{i+1}-p'_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We see that the term [katex]\mathbf{b}[/katex] has vanished. Therefore, our corrected momentum equation can be written in matrix form as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{\mathcal{M}}\mathbf{U}'=-\frac{1}{\rho}\nabla p'</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we separate the matrix [katex]\mathbf{\mathcal{M}}[/katex] into two matrices. The first matrix will only contain diagonal coefficients, and we call this matrix [katex]\mathbf{\mathcal{A}}[/katex]. The second matrix will contain all the off-diagonal components, and we shall name this matrix [katex]\mathbf{\mathcal{H}}[/katex] (I am using the naming convention here that you will find in the literature). This can be written in matrix form as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{\mathcal{M}}\mathbf{U}'=\mathbf{\mathcal{A}}\mathbf{U}'-\mathbf{\mathcal{H}}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we expand these matrixes, for example, for a simple 1D grid with 5 nodes, then we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\underbrace{\begin{bmatrix}
a_1 &amp; -a_2 &amp; 0 &amp; 0 &amp; 0\\[1em]
-a_1 &amp; a_2 &amp; -a_3 &amp; 0 &amp; 0\\[1em]
0 &amp; -a_2 &amp; a_3 &amp; -a_4 &amp; 0\\[1em]
0 &amp; 0 &amp; -a_3 &amp; a_4 &amp; -a_5\\[1em]
0 &amp; 0 &amp; 0 &amp; -a_4 &amp; a_5
\end{bmatrix}}_{\mathbf{\mathcal{M}}}
\underbrace{\begin{bmatrix}
u_1 \\[1em] u_2 \\[1em] u_3 \\[1em] u_4 \\[1em] u_5
\end{bmatrix}}_{\mathbf{U}'}
=
\underbrace{\begin{bmatrix}
a_1 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\[1em]
0 &amp; a_2 &amp; 0 &amp; 0 &amp; 0\\[1em]
0 &amp; 0 &amp; a_3 &amp; 0 &amp; 0\\[1em]
0 &amp; 0 &amp; 0 &amp; a_4 &amp; 0\\[1em]
0 &amp; 0 &amp; 0 &amp; 0 &amp; a_5
\end{bmatrix}}_{\mathbf{\mathcal{A}}}
\underbrace{\begin{bmatrix}
u_1 \\[1em] u_2 \\[1em] u_3 \\[1em] u_4 \\[1em] u_5
\end{bmatrix}}_{\mathbf{U}'}
-
\underbrace{\begin{bmatrix}
0 &amp; -a_2\cdot u_2' &amp; 0 &amp; 0 &amp; 0\\[1em]
-a_1\cdot u_1' &amp; 0 &amp; -a_3\cdot u_3' &amp; 0 &amp; 0\\[1em]
0 &amp; -a_2\cdot u_2' &amp; 0 &amp; -a_4\cdot u_4' &amp; 0\\[1em]
0 &amp; 0 &amp; -a_3\cdot u_3' &amp; 0 &amp; -a_5\cdot u_5'\\[1em]
0 &amp; 0 &amp; 0 &amp; -a_4\cdot u_4' &amp; 0
\end{bmatrix}}_{\mathbf{\mathcal{H}}}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Inserting this definition, we have the momentum equation of the form:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{\mathcal{A}}\mathbf{U}'-\mathbf{\mathcal{H}}=-\frac{1}{\rho}\nabla p'</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can also write this equation with the off-diagonal matrix on the right-hand side, which results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{\mathcal{A}}\mathbf{U}'=\mathbf{\mathcal{H}}-\frac{1}{\rho}\nabla p'</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Compare that to the discrete form we had obtained previously:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\underbrace{a_p}_\mathbf{\mathcal{A}} \cdot \underbrace{u_{i}'}_{\mathbf{U}'}
=
\underbrace{\sum a_{nb} \cdot u_{nb}'}_\mathbf{\mathcal{H}} -
\frac{1}{\rho}
\underbrace{\frac{p'_{i+1}-p'_{i-1}}{2\Delta x}}_{\nabla p'}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Because the matrix [katex]\mathbf{\mathcal{A}}[/katex] only contains diagonal components, we can easily invert this matrix. That is, the diagonal matrix can be inverted as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{\mathcal{A}}^{-1}=
\begin{bmatrix}
\frac{1}{a_1} &amp; 0 &amp; \dots &amp; 0\\[1em]
0 &amp;\frac{1}{a_2} &amp;  &amp; 0\\[1em]
\vdots &amp; &amp; \ddots &amp; \vdots \\[1em]
0 &amp; &amp; \dots &amp; \frac{1}{a_n}
\end{bmatrix}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Therefore, we can multiply by this inverted matrix, which will provide us with the following correction equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{U}'=\mathbf{\mathcal{A}}^{-1}\mathbf{\mathcal{H}}-\frac{1}{\rho}\mathbf{\mathcal{A}}^{-1}\nabla p'</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>For the SIMPLE algorithm, we made the simplification of dropping the neighbouring contributions, that is, we drop the first term on the right-hand side. This results in the following simplified equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{U}'=-\frac{1}{\rho}\mathbf{\mathcal{A}}^{-1}\nabla p'</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We also said that a correction [katex]\phi'[/katex] can be expressed as [katex]\phi'=\phi^c - \phi^*[/katex], i.e. it is the result from subtracting the guessed value [katex]\phi^*[/katex] from the correct value [katex]\phi^c[/katex]. So, rewriting the above equation in terms of correct and guessed velocity results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{U}^c=\mathbf{U}^*-\frac{1}{\rho}\mathbf{\mathcal{A}}^{-1}\nabla p'</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The discrete equation we obtained was:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u_i^c=u^*_i-\frac{1}{\rho a_p}\frac{p'_{i+1}-p'_{i-1}}{2\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In the literature, though, the term [katex]\mathbf{\mathcal{A}}^{-1}\mathbf{\mathcal{H}}[/katex] isn't dropped from the derivation. Instead, we keep it in the derivation and then if we want to have the pure SIMPLE algorithm, we simply set the coefficients in [katex]\mathbf{\mathcal{H}}[/katex] to zero. If we would like to use the SIMPLEC alternative, for example, those coefficients are not zero, and so we have a unified way of expressing both the SIMPLE algorithm and its derivatives.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the next step, we insert the equation for the corrected velocity into the continuity equation [katex]\nabla\cdot \mathbf{U}[/katex]. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\nabla\cdot\mathbf{U}'=\nabla\cdot(\mathbf{\mathcal{A}}^{-1}\mathbf{\mathcal{H}})-\frac{1}{\rho}\nabla\cdot (\mathbf{\mathcal{A}}^{-1}\nabla p')=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Placing the pressure on the left-hand side and the velocity on the right-hand side, we have the following pressure Poisson equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{\rho}\nabla\cdot (\mathbf{\mathcal{A}}^{-1}\nabla p')=\nabla\cdot(\mathbf{\mathcal{A}}^{-1}\mathbf{\mathcal{H}})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>After we have solved this equation for the corrected pressure, we have a value for the correct pressure through [katex]p^c=p^*+p'[/katex]. Then, we use this correct pressure field to get the correct velocity field. To do that, we rewrite our correction equation, i.e. </p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{U}'=\mathbf{\mathcal{A}}^{-1}\mathbf{\mathcal{H}}-\frac{1}{\rho}\mathbf{\mathcal{A}}^{-1}\nabla p'</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>in terms of correct quantities:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{U}^c=\mathbf{U}^{n+1}=\mathbf{\mathcal{A}}^{-1}\mathbf{\mathcal{H}}-\frac{1}{\rho}\mathbf{\mathcal{A}}^{-1}\nabla p^c</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is the SIMPLE algorithm in matrix form, and you see that both this form and the discrete equation form solve one and the same thing.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Regardless of which form you implement, you will see that the SIMPLE algorithm doesn't work, at least not until we have made some modifications. You see, we made crude approximations to the momentum equation, such as linearisation and dropping some terms entirely. While we derived the equation for an unsteady problem, the resolution of the SIMPLE algorithm in time isn't great due to all the simplifications made. Coupled with convergence issues, it is best used for steady state problems only.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We need to introduce under-relaxation at this point, which is the process of updating the flow field only partially with the newly obtained quantities. If we did not use under-relaxation, the inaccurate SIMPLE algorithm would overshoot the correct solution slightly in each iteration/time step, and due to the non-linear nature of our equations, these inaccuracies would grow exponentially in time, ultimately causing our simulation to diverge.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For the generic quantity [katex]\phi[/katex], we can apply under-relaxation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi^{n+1}=(1-\alpha)\phi^n+\alpha\phi^{n+1},\quad\quad 0&lt;\alpha\le 1</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This will ensure that we are only slightly updating velocity and pressure for each iteration/time step. The pressure projection method of Chorin does not require under-relaxation, though in some cases, it may help to stabilise the simulation.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-how-to-go-from-the-simple-algorithm-to-the-piso-algorithm">How to go from the SIMPLE algorithm to the PISO algorithm</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>I have mentioned that modifications to the matrix [katex]\mathbf{\mathcal{H}}[/katex] will determine which version of the SIMPLE algorithm we are using. But there is one other algorithm which is commonly used, and that is the PISO algorithm, which stands for Pressure Implicit with Splitting of Operators (or PIwSoO, though PISO is probably more catchy).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The PISO algorithm is essentially the SIMPLE algorithm, but we simply insert an additional loop. We solve the same equations and start with the momentum equation (I'll be using the matrix notation here, which is just a bit more compact):</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{\mathcal{M}}\mathbf{U}^{n+1}=\mathbf{RHS}(\mathbf{b}(\mathbf{U}^n), \nabla p^n)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, we start a loop that is not present in the SIMPLE algorithm. We say that we solve the following equations within a loop:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{1}{\rho}\nabla\cdot (\mathbf{\mathcal{A}}^{-1}\nabla p')=\nabla\cdot(\mathbf{\mathcal{A}}^{-1}\mathbf{\mathcal{H}})</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>and</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\mathbf{U}'=\mathbf{\mathcal{A}}^{-1}\mathbf{\mathcal{H}}-\frac{1}{\rho}\mathbf{\mathcal{A}}^{-1}\nabla p'</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Why? Because the matrix [katex]\mathbf{\mathcal{H}}[/katex] depends on the velocity [katex]\mathbf{U}[/katex]. We use the first equation to obtain a new pressure field, and then we use the second equation to correct the velocity field based on this new pressure. As soon as we update the velocity, [katex]\mathbf{\mathcal{H}}[/katex] changes as well since it depends on the velocity, which just changed. Thus, we loop a few times over these two equations until we satisfy them.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We don't do that in the SIMPLE algorithm, and this is the reason why we had to introduce under-relaxation here because of this inaccuracy here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, the PISO algorithm extends the SIMPLE algorithm by adding an additional loop. If you ask me, that is an extension to the SIMPLE algorithm rather than a new method in its own right, but I suppose Patankar and Spalding set the precedence by making the SIMPLE method its own algorithm instead of an extension to Chorin's pressure projection method, so I suppose this modification counts as a new method.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-bonus-the-pimple-algorithm">Bonus: the PIMPLE algorithm</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>If you have never used OpenFOAM (which means you must still have your sanity; look after it before it is gone!), then you will likely never have heard about the PIMPLE algorithm. It is a combination of PISO and SIMPLE, hence the name PIMPLE (great choice, especially when you are googling it. It is only beaten by the carbuncle problem in CFD, though I would strongly suggest not to google carbuncle, or at least not while you are eating!)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It is an unpublished algorithm that extends the PISO algorithm by, well, who would have thought, yet another loop! As we have established, adding a new loop warrants the introduction of a new method, and so we have the PIMPLE algorithm.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It can be summarised as:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Start loop</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Solve PISO algorithm</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Finish loop</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Yep, that's PIMPLE for you. If you run PIMPLE with just one iteration, it will even tell you that it is running in <em>PISO mode</em>. Why would you want to do that? We can belittle the PIMPLE algorithm all we want, but it does remove one essential shortcoming of both the SIMPLE and PISO algorithm, and that is the problem of the semi-implicit nature of the pressure.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We said that because the pressure is evaluated at the previous time level [katex]n[/katex] and not at time level [katex]n+1[/katex], we are limited in the CFL numbers we can use before the simulation starts to diverge. The PIMPLE algorithm introduces this additional loop to stabilise the solution algorithm, and, as a result, we can run simulations at much higher CFL numbers.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It is an expensive trade-off, but if we can increase the CFL number by a factor of, say 5 times, but the additional computation only takes 3 times longer, then we are saving computational cost, as we can now integrate our solution much more efficiently in time.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But it is an unnecessary one. If we look back at Chorin's pressure projection method, it is fully implicit (we have dropped the pressure gradient from the equation). As a result, we can use CFL numbers that are as high as we want. We are only limited by the temporal resolution we want to achieve. From a numerical point, there is nothing holiding us back to use a high CFL number here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But, there are times when we may want to use an additional loop as we do in the PIMPLE algorithm. This idea was introduced in <a href="https://www.researchgate.net/publication/267982395_Time_dependent_calculations_using_multigrid_with_applications_to_unsteady_flows_past_airfoils_and_wings" target="_blank" rel="noopener" title="">1991 by Jameson</a> and it is known these days as dual time stepping. All we do is introduce a second time derivative in the momentum equation. This can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial t}+\frac{\partial \mathbf{u}}{\partial \tau} + (\mathbf{u}\cdot\nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The way that this works is to solve the inner part of the equation, i.e.:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \mathbf{u}}{\partial \tau} + (\mathbf{u}\cdot\nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu\nabla^2\mathbf{u}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>as a steady-state problem. We advance this solution in time until the time derivative becomes zero. If this is the case, then we have obtained the solution at the next time level [katex]n+1[/katex] for the velocity. Since we solve this equation iteratively, we are also solving the pressure correction equation within each iteration, and so it does not matter if the pressure is evaluated at time level [katex]n[/katex], as we will iteratively satisfy this momentum equation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With sufficient iterations, the above equation can be solved, and then we can update the velocity through the real-time derivative. The procedure isn't complicated, but it takes some time to wrap your head around. If you are not fully understanding the concept or have more questions, I get it. It took me some time to understand as well how to implement it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But the takeaway message is that we can use dual time stepping to cheaply and efficiently solve the inner iterations until we get a steady state result, which we can then use to integrate in time with a large CFL number. This is another good idea for an article I have to write in the future, I have placed it on my ever growing to do list.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is essentially what the PIMPLE algorithm does, i.e. it solves the momentum equation iteratively. We can see it as an extension of the PISO algorithm using a dual-time stepping procedure.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-the-verdict">The verdict</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>OK, I want to summarise the stupidity that is the SIMPLE algorithm and all of its derivatives. I really want to get the point across that SIMPLE and co are all sub-optimal implementations of a perfectly fine method that has been around for longer than SIMPLE and any of its friends. We shouldn't be afraid of using the pressure projection algorithm.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's start with the pressure projection method of Chorin. It is fully implicit, rooted in an exact mathematical derivation and treatment, and as a result it does not require any under-relaxation to make the method work.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we want to mildly annoy ourselves, then we add the pressure gradient back into the equation (which is wrong from a mathematical standpoint), and as a result, we lose the fully implicit nature. We fix this by adding a dual time stepping procedure, which allows us to have arbitrarily large CFL numbers again, but we have just increased the computational cost compared to Chorin's original method.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Next, we drop the dual time stepping so we have a more efficient solution, but we are now limited in the maximum CFL number that we can use. This is the PISO algorithm. If we further butcher the pressure Poisson equation by removing non-linear contributions, we are losing accuracy and solving a related but not exact discretised form of the Navier-Stokes equation. As a result, we have to introduce under-relaxation and typically want to limit ourselves to using the SIMPLE algorithm for steady-state flows only.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I think I have made my point.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-summary">Summary</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>OK, let's collect ourselves, there was a lot of information in one article. So let's summarise the main points here:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Incompressible and  compressible flows require different solution algorithm due to the density changing its behaviour. We differentiate between density-based descriptions, where we solve for the density and then use an equation of state to link it to the pressure, and pressure-based descriptions, where the density is may be constant, and we link pressure and velocity through some iterative procedure.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>We saw that we have conservative and non-conservative (primitive) variable formulations, and we prefer conservative variables for compressible flows, especially when we have discontinuouties in our flow (e.g. shock waves). For smooth data, the variable description does not matter and we prefer primitive variables for incompressible flows. They make life easier.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Compressible flows do not change the Navier-Stokes equations, and we solve them as they are. We augment them with an equation of state to link density and pressure, which closes the system.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>For incompressible flows, the density is considered constant, and so we can no longer solve the equations as they are. Instead, we have to construct new equations that derive from either the momentum or continuity equation, that will iteratively link the pressure field to the velocity.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>There are two main families of algorithms that we have looked at; preconditioning like the Artificial Compressibility method, and pressure projection methods, like Chorin's exact projection, and approximate projections like SIMPLE, PISO, and PIMPLE.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>It is common for people specialising in CFD to pick on flow regime (i.e. incompressible or compressible) and then sticking with it. To the best of my judgement, this is due to differences in variable formulation and solution algorithms, as well as differences in numerical schemes (e.g. shock-capturing schemes for compressible flows vs. upwind-based schemes for incompressible flows). It almost feels like both incompressible and compressible flows have almost nothing in common.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I really hope you will be able to see how to solve both sides, and that you will not be scared writing a solver for either incompressible or compressible flows. Now that we have a good idea of how to discretise the Navier-Stokes equations, which schemes to use, how to treat boundaries, and what algorithms to use to solve incompressible and compressible flows, we are ready to face the biggest problem in CFD; how to deal with turbulent flows. This will be discussed in the next article, I'll see you over there!</p>
<!-- /wp:paragraph -->