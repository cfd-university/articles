<!-- wp:paragraph -->
<p>In this article, we continue developing our CGNS mesh reader library and implement the unstructured mesh reading class to complement our structured mesh reading class developed in the <a href="https://cfd.university/learn/the-complete-guide-to-structured-and-unstructured-mesh-reading-using-cgns/how-to-read-a-multi-block-structured-mesh-from-a-cgns-file" target="_blank" rel="noopener" title="">previous article</a>. There are a few similarities between reading a structured and unstructured grid, and where that is the case, I will go through the code a bit faster and refer back to the structured mesh reading. This allows me to concentrate more on the differences, which are mainly in the element connectivity array that we need to read and process.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>By the end of this article, you will have a good understanding of how to read an unstructured mesh from a CGNS file. Unstructured grids do not have to be written into several blocks/zones, as we saw for example with structured grids. However, to be as general as possible, we do allow for multi-block unstructured grids here and do read interface information as well if present. Therefore, the way that mesh reading is described here is as universal as possible and you should be able to read any unstructured grid with this implementation.</p>
<!-- /wp:paragraph -->

<!-- wp:block {"ref":2490} /-->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Download</strong>: <a href="https://cfd.university/download/cgnsmeshreaderlib-part4/?tmstv=1712896766" target="_blank" rel="noopener" title="">cgnsMeshReaderLib-Part4.zip</a></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading -->
<h2 class="wp-block-heading">In this series</h2>
<!-- /wp:heading -->

<!-- wp:shortcode -->
[custom_category_posts_list category_slug="the-complete-guide-to-structured-and-unstructured-mesh-reading-using-cgns"]
<!-- /wp:shortcode -->

<!-- wp:heading -->
<h2 class="wp-block-heading">In this article</h2>
<!-- /wp:heading -->

<!-- wp:aioseo/table-of-contents {"headings":[{"id":8,"blockClientId":"ee62ae69-0ea3-4e4e-8877-0d9b8a313d34","content":"Overview","level":2,"anchor":"aioseo-overview","order":0,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":13,"blockClientId":"a5a4bcd6-2049-4e39-a087-ea27eda0e749","content":"Updating existing files","level":2,"anchor":"aioseo-updating-existing-files","order":1,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":15,"blockClientId":"55b175c3-561d-4d1f-9244-acf899f3e329","content":"Build scripts","level":3,"anchor":"aioseo-build-scripts","order":2,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":17,"blockClientId":"e1accc3b-304b-4b4e-a66d-18b526253056","content":"Windows","level":4,"anchor":"aioseo-windows","order":3,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":20,"blockClientId":"dd0a4081-133f-4f96-a674-d269ed38495f","content":"UNIX","level":4,"anchor":"aioseo-unix","order":4,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]},{"id":23,"blockClientId":"1634218e-0f13-4464-834a-9ac7f8db7460","content":"Header files","level":3,"anchor":"aioseo-header-files","order":5,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":26,"blockClientId":"31c40983-1362-4dee-bbca-9765f69bce51","content":"main.cpp for testing","level":3,"anchor":"aioseo-main-cpp-for-testing","order":6,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]},{"id":29,"blockClientId":"0c2876a5-2935-4d2f-81dd-e71946c2787a","content":"What information is stored in an unstructured grid?","level":2,"anchor":"aioseo-structure-of-a","order":7,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":37,"blockClientId":"8b32e2f7-460a-48b1-9f38-8db5b2586cdd","content":"Creating a derived class for unstructured grids","level":2,"anchor":"aioseo-creating-a-derived-class-for-unstructured-grids","order":8,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":39,"blockClientId":"51580f12-54f4-4147-bab7-c16c0bc4c205","content":"Creating the class interface","level":3,"anchor":"aioseo-creating-the-class-interface","order":9,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":42,"blockClientId":"da8a3254-7255-4458-94dd-5445323a00f3","content":"Preprocessor directives","level":4,"anchor":"aioseo-preprocessor","order":10,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":46,"blockClientId":"a37062f2-510b-42fd-9046-6c8149eb374a","content":"Specified types","level":4,"anchor":"aioseo-specified-types","order":11,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":53,"blockClientId":"23ad3f3a-c4cb-4e02-9190-6bf8508ffcdd","content":"Function declarations","level":4,"anchor":"aioseo-function-declarations","order":12,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]},{"id":58,"blockClientId":"530d6e4f-d3ef-439f-ba54-43415e182510","content":"Implementing the interface","level":3,"anchor":"aioseo-implementing-the-interface","order":13,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":60,"blockClientId":"fdc35e8c-0152-44f4-b32c-cbb0ee0267d2","content":"Constructor","level":4,"anchor":"aioseo-constructor","order":14,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":63,"blockClientId":"de434927-2d7f-43ba-9f37-c2be5576e445","content":"Implementing the readMesh() function","level":4,"anchor":"aioseo-implementing-the-readmesh-function","order":15,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":66,"blockClientId":"fba4c253-bb28-48da-a9f4-1df673b638be","content":"Reading coordinates from a CGNS file","level":4,"anchor":"aioseo-reading-coordinates-from-a-cgns-file","order":16,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":72,"blockClientId":"cd24678f-9665-4fad-9d0d-8380c75d7069","content":"Getting start location for elements in connectivity array","level":4,"anchor":"aioseo-getting-start-location-for-elements-in-connectivity-array","order":17,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":74,"blockClientId":"8fd72900-422f-43f5-b603-9784bb059ce1","content":"Why we need the start location in the first place","level":5,"anchor":"aioseo-why-we-need-the-start-location-in-the-first-place","order":18,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":82,"blockClientId":"1ee475a4-0406-4a75-919c-6606724ca5cd","content":"Implementation of reading the element connectivity start locations","level":5,"anchor":"aioseo-implementation-of-reading-the-element-connectivity-start-locations","order":19,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]},{"id":93,"blockClientId":"deb97524-3250-4ea4-b639-8c8b9d72c86a","content":"Reading cell connectivity","level":4,"anchor":"aioseo-reading-cell-connectivity","order":20,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":96,"blockClientId":"9a223cf4-46ba-4a8c-9ebd-f5ddda02d66f","content":"Setting up element connectivity reading","level":5,"anchor":"aioseo-setting-up-element-connectivity-reading","order":21,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":101,"blockClientId":"df6acebc-973a-473d-9a74-4285a88ced28","content":"Reading element connectivity data for internal, interface, and boundary cells","level":5,"anchor":"aioseo-reading-element-connectivity-data-for-internal-interface-and-boundary-cells","order":22,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":106,"blockClientId":"1ddbb157-10cf-4fa6-9db9-2303b1d850de","content":"A lambda expression to map 1D element connectivity data to 2D","level":5,"anchor":"aioseo-a-lambda-expression-to-map-1d-element-connectivity-data-to-2d","order":23,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":116,"blockClientId":"76c708c0-86eb-4f5c-bdcf-f31323324d18","content":"Writing element connectivity data into class variables","level":5,"anchor":"aioseo-writing-element-connectivity-data-into-class-variables","order":24,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]},{"id":128,"blockClientId":"d190a418-3cf5-45e0-9d75-acd7d15a6bf3","content":"Reading interface connectivity for multi-block unstructured grids from a CGNS file","level":4,"anchor":"aioseo-reading-interface-connectivity-for-multi-block-unstructured-grids-from-a-cgns-file","order":25,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":132,"blockClientId":"f20840af-b902-4e20-a50d-92d37a2eed42","content":"Creating a zone index lookup table","level":5,"anchor":"aioseo-creating-a-zone-index-lookup-table","order":26,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":142,"blockClientId":"7b386f5c-4c5c-4bce-9d1f-405dfbe2700e","content":"Reading interface connectivity data","level":5,"anchor":"aioseo-reading-interface-connectivity-data","order":27,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]},{"id":150,"blockClientId":"c51a900c-9bee-4d0b-a0e4-3e00ac9014be","content":"Reading boundary conditions from a CGNS file","level":4,"anchor":"aioseo-reading-boundary-conditions-from-a-cgns-file","order":28,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]}]},{"id":159,"blockClientId":"feb4e9d5-3c10-47f2-a900-113024439707","content":"Summary","level":2,"anchor":"aioseo-summary","order":29,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]} -->
<div class="wp-block-aioseo-table-of-contents"><ul><li><a href="#aioseo-overview">Overview</a></li><li><a href="#aioseo-updating-existing-files">Updating existing files</a><ul><li><a href="#aioseo-build-scripts">Build scripts</a><ul><li><a href="#aioseo-windows">Windows</a></li><li><a href="#aioseo-unix">UNIX</a></li></ul></li><li><a href="#aioseo-header-files">Header files</a></li><li><a href="#aioseo-main-cpp-for-testing">main.cpp for testing</a></li></ul></li><li><a href="#aioseo-structure-of-a">What information is stored in an unstructured grid?</a></li><li><a href="#aioseo-creating-a-derived-class-for-unstructured-grids">Creating a derived class for unstructured grids</a><ul><li><a href="#aioseo-creating-the-class-interface">Creating the class interface</a><ul><li><a href="#aioseo-preprocessor">Preprocessor directives</a></li><li><a href="#aioseo-specified-types">Specified types</a></li><li><a href="#aioseo-function-declarations">Function declarations</a></li></ul></li><li><a href="#aioseo-implementing-the-interface">Implementing the interface</a><ul><li><a href="#aioseo-constructor">Constructor</a></li><li><a href="#aioseo-implementing-the-readmesh-function">Implementing the readMesh() function</a></li><li><a href="#aioseo-reading-coordinates-from-a-cgns-file">Reading coordinates from a CGNS file</a></li><li><a href="#aioseo-getting-start-location-for-elements-in-connectivity-array">Getting start location for elements in connectivity array</a><ul><li><a href="#aioseo-why-we-need-the-start-location-in-the-first-place">Why we need the start location in the first place</a></li><li><a href="#aioseo-implementation-of-reading-the-element-connectivity-start-locations">Implementation of reading the element connectivity start locations</a></li></ul></li><li><a href="#aioseo-reading-cell-connectivity">Reading cell connectivity</a><ul><li><a href="#aioseo-setting-up-element-connectivity-reading">Setting up element connectivity reading</a></li><li><a href="#aioseo-reading-element-connectivity-data-for-internal-interface-and-boundary-cells">Reading element connectivity data for internal, interface, and boundary cells</a></li><li><a href="#aioseo-a-lambda-expression-to-map-1d-element-connectivity-data-to-2d">A lambda expression to map 1D element connectivity data to 2D</a></li><li><a href="#aioseo-writing-element-connectivity-data-into-class-variables">Writing element connectivity data into class variables</a></li></ul></li><li><a href="#aioseo-reading-interface-connectivity-for-multi-block-unstructured-grids-from-a-cgns-file">Reading interface connectivity for multi-block unstructured grids from a CGNS file</a><ul><li><a href="#aioseo-creating-a-zone-index-lookup-table">Creating a zone index lookup table</a></li><li><a href="#aioseo-reading-interface-connectivity-data">Reading interface connectivity data</a></li></ul></li><li><a href="#aioseo-reading-boundary-conditions-from-a-cgns-file">Reading boundary conditions from a CGNS file</a></li></ul></li></ul></li><li><a href="#aioseo-summary">Summary</a></li></ul></div>
<!-- /wp:aioseo/table-of-contents -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-overview">Overview</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>At this point, we have created the <a href="https://cfd.university/learn/the-complete-guide-to-structured-and-unstructured-mesh-reading-using-cgns/how-to-set-up-a-simple-cgns-based-mesh-reading-library" target="_blank" rel="noopener" title="">library structure and the base class</a>, which includes some shared functionality, and in the <a href="https://cfd.university/learn/the-complete-guide-to-structured-and-unstructured-mesh-reading-using-cgns/how-to-read-a-multi-block-structured-mesh-from-a-cgns-file" target="_blank" rel="noopener" title="">previous article</a>, we implemented a class that is capable of reading multi-block structured grids. In this article, I want to further extend the capability of our library by reading unstructured grids as well. For this, we will generate another derived class from our base mesh reading class, and then look at the implementation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There is quite a bit of overlap between this article and the previous one on <a href="https://cfd.university/learn/the-complete-guide-to-structured-and-unstructured-mesh-reading-using-cgns/how-to-read-a-multi-block-structured-mesh-from-a-cgns-file" target="_blank" rel="noopener" title="">reading a structured grid</a>. Even if your intentions are to only read unstructured grids, the previous article contains a lot of explanations that will not be repeated here to keep things to the point (and, if you have gone through the previous two articles already, you'll appreciate this). There are a few new things we have to discuss in this article, specifically, reading cells which require element connectivity data, and we will focus on this area.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's go through the files we need to update first and then concentrate on the new unstructured mesh reading class.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-updating-existing-files">Updating existing files</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>As we did in the previous example, we need to update a few files. Specifically, we need to make modifications to the build scripts, the header include file, and the main.cpp file, which will now include the unstructured mesh reading class.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-build-scripts">Build scripts</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's start with the build scripts. We look at both the Windows and UNIX build scripts below.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-windows">Windows</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>For the <code>buildAndRun.ps1</code> build script, we need to add the usntructured mesh reading class to the compilation and linking stage. In the updated build script below, we have added a compilation statement on line 10 to compile the unstructured mesh reading class, while we have added its created object file on line 14 for the linker.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"# clean up before building\nRemove-Item .\\build -Force -Recurse\nNew-Item -Name \u0022build\u0022 -ItemType \u0022directory\u0022\nCopy-Item \u0022C:\\libraries\\bin\\hdf5.dll\u0022 -Destination .\\build\nCopy-Item \u0022C:\\libraries\\bin\\zlib.dll\u0022 -Destination .\\build\n\n# compile source files into object files\ncl.exe /nologo /EHsc /std:c++20 /I. /I \u0022C:\\libraries\\include\u0022 /c /O2 /DCOMPILELIB .\\meshReaderLib\\src\\readMeshBase.cpp /Fo\u0022.\\build\\readMeshBase.obj\u0022\ncl.exe /nologo /EHsc /std:c++20 /I. /I \u0022C:\\libraries\\include\u0022 /c /O2 /DCOMPILELIB .\\meshReaderLib\\src\\readStructuredMesh.cpp /Fo\u0022.\\build\\readStructuredMesh.obj\u0022\ncl.exe /nologo /EHsc /std:c++20 /I. /I \u0022C:\\libraries\\include\u0022 /c /O2 /DCOMPILELIB .\\meshReaderLib\\src\\readUnstructuredMesh.cpp /Fo\u0022.\\build\\readUnstructuredMesh.obj\u0022\ncl.exe /nologo /EHsc /std:c++20 /I. /I \u0022C:\\libraries\\include\u0022 /c /O2 /DCOMPILELIB .\\main.cpp /Fo\u0022.\\build\\main.obj\u0022\n\n# link object files against CGNS library and its dependencies\ncl.exe /nologo /EHsc /std:c++20 .\\build\\main.obj .\\build\\readMeshBase.obj .\\build\\readStructuredMesh.obj .\\build\\readUnstructuredMesh.obj /Fe\u0022.\\build\\cgnsTest.exe\u0022 /link /MACHINE:x64 /LIBPATH:\u0022C:\\libraries\\lib\u0022 cgns.lib hdf5.lib msvcrt.lib libcmt.lib\n.\\build\\cgnsTest.exe","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# clean up before building\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eRemove-Item\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e .\\build -Force -Recurse\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eNew-Item\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e -Name \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;build\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e -ItemType \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;directory\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eCopy-Item\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;C:\\libraries\\bin\\hdf5.dll\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e -Destination .\\build\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eCopy-Item\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;C:\\libraries\\bin\\zlib.dll\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e -Destination .\\build\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# compile source files into object files\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecl.exe\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /nologo /EHsc /std:c+\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e+20\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /I. /I \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;C:\\libraries\\include\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /c /O2 /DCOMPILELIB .\\meshReaderLib\\src\\readMeshBase.cpp /Fo\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.\\build\\readMeshBase.obj\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecl.exe\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /nologo /EHsc /std:c+\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e+20\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /I. /I \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;C:\\libraries\\include\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /c /O2 /DCOMPILELIB .\\meshReaderLib\\src\\readStructuredMesh.cpp /Fo\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.\\build\\readStructuredMesh.obj\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecl.exe\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /nologo /EHsc /std:c+\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e+20\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /I. /I \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;C:\\libraries\\include\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /c /O2 /DCOMPILELIB .\\meshReaderLib\\src\\readUnstructuredMesh.cpp /Fo\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.\\build\\readUnstructuredMesh.obj\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecl.exe\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /nologo /EHsc /std:c+\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e+20\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /I. /I \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;C:\\libraries\\include\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /c /O2 /DCOMPILELIB .\\main.cpp /Fo\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.\\build\\main.obj\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# link object files against CGNS library and its dependencies\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecl.exe\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /nologo /EHsc /std:c+\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e+20\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e .\\build\\main.obj .\\build\\readMeshBase.obj .\\build\\readStructuredMesh.obj .\\build\\readUnstructuredMesh.obj /Fe\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.\\build\\cgnsTest.exe\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e /link /MACHINE:x64 /LIBPATH:\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;C:\\libraries\\lib\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e cgns.lib hdf5.lib msvcrt.lib libcmt.lib\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\\build\\\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecgnsTest.exe\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"powershell","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":15,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="# clean up before building
Remove-Item .\build -Force -Recurse
New-Item -Name &quot;build&quot; -ItemType &quot;directory&quot;
Copy-Item &quot;C:\libraries\bin\hdf5.dll&quot; -Destination .\build
Copy-Item &quot;C:\libraries\bin\zlib.dll&quot; -Destination .\build

# compile source files into object files
cl.exe /nologo /EHsc /std:c++20 /I. /I &quot;C:\libraries\include&quot; /c /O2 /DCOMPILELIB .\meshReaderLib\src\readMeshBase.cpp /Fo&quot;.\build\readMeshBase.obj&quot;
cl.exe /nologo /EHsc /std:c++20 /I. /I &quot;C:\libraries\include&quot; /c /O2 /DCOMPILELIB .\meshReaderLib\src\readStructuredMesh.cpp /Fo&quot;.\build\readStructuredMesh.obj&quot;
cl.exe /nologo /EHsc /std:c++20 /I. /I &quot;C:\libraries\include&quot; /c /O2 /DCOMPILELIB .\meshReaderLib\src\readUnstructuredMesh.cpp /Fo&quot;.\build\readUnstructuredMesh.obj&quot;
cl.exe /nologo /EHsc /std:c++20 /I. /I &quot;C:\libraries\include&quot; /c /O2 /DCOMPILELIB .\main.cpp /Fo&quot;.\build\main.obj&quot;

# link object files against CGNS library and its dependencies
cl.exe /nologo /EHsc /std:c++20 .\build\main.obj .\build\readMeshBase.obj .\build\readStructuredMesh.obj .\build\readUnstructuredMesh.obj /Fe&quot;.\build\cgnsTest.exe&quot; /link /MACHINE:x64 /LIBPATH:&quot;C:\libraries\lib&quot; cgns.lib hdf5.lib msvcrt.lib libcmt.lib
.\build\cgnsTest.exe" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #6A9955"># clean up before building</span></span>
<span class="line"><span style="color: #DCDCAA">Remove-Item</span><span style="color: #D4D4D4"> .\build -Force -Recurse</span></span>
<span class="line"><span style="color: #DCDCAA">New-Item</span><span style="color: #D4D4D4"> -Name </span><span style="color: #CE9178">&quot;build&quot;</span><span style="color: #D4D4D4"> -ItemType </span><span style="color: #CE9178">&quot;directory&quot;</span></span>
<span class="line"><span style="color: #DCDCAA">Copy-Item</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">&quot;C:\libraries\bin\hdf5.dll&quot;</span><span style="color: #D4D4D4"> -Destination .\build</span></span>
<span class="line"><span style="color: #DCDCAA">Copy-Item</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">&quot;C:\libraries\bin\zlib.dll&quot;</span><span style="color: #D4D4D4"> -Destination .\build</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955"># compile source files into object files</span></span>
<span class="line"><span style="color: #DCDCAA">cl.exe</span><span style="color: #D4D4D4"> /nologo /EHsc /std:c+</span><span style="color: #B5CEA8">+20</span><span style="color: #D4D4D4"> /I. /I </span><span style="color: #CE9178">&quot;C:\libraries\include&quot;</span><span style="color: #D4D4D4"> /c /O2 /DCOMPILELIB .\meshReaderLib\src\readMeshBase.cpp /Fo</span><span style="color: #CE9178">&quot;.\build\readMeshBase.obj&quot;</span></span>
<span class="line"><span style="color: #DCDCAA">cl.exe</span><span style="color: #D4D4D4"> /nologo /EHsc /std:c+</span><span style="color: #B5CEA8">+20</span><span style="color: #D4D4D4"> /I. /I </span><span style="color: #CE9178">&quot;C:\libraries\include&quot;</span><span style="color: #D4D4D4"> /c /O2 /DCOMPILELIB .\meshReaderLib\src\readStructuredMesh.cpp /Fo</span><span style="color: #CE9178">&quot;.\build\readStructuredMesh.obj&quot;</span></span>
<span class="line"><span style="color: #DCDCAA">cl.exe</span><span style="color: #D4D4D4"> /nologo /EHsc /std:c+</span><span style="color: #B5CEA8">+20</span><span style="color: #D4D4D4"> /I. /I </span><span style="color: #CE9178">&quot;C:\libraries\include&quot;</span><span style="color: #D4D4D4"> /c /O2 /DCOMPILELIB .\meshReaderLib\src\readUnstructuredMesh.cpp /Fo</span><span style="color: #CE9178">&quot;.\build\readUnstructuredMesh.obj&quot;</span></span>
<span class="line"><span style="color: #DCDCAA">cl.exe</span><span style="color: #D4D4D4"> /nologo /EHsc /std:c+</span><span style="color: #B5CEA8">+20</span><span style="color: #D4D4D4"> /I. /I </span><span style="color: #CE9178">&quot;C:\libraries\include&quot;</span><span style="color: #D4D4D4"> /c /O2 /DCOMPILELIB .\main.cpp /Fo</span><span style="color: #CE9178">&quot;.\build\main.obj&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955"># link object files against CGNS library and its dependencies</span></span>
<span class="line"><span style="color: #DCDCAA">cl.exe</span><span style="color: #D4D4D4"> /nologo /EHsc /std:c+</span><span style="color: #B5CEA8">+20</span><span style="color: #D4D4D4"> .\build\main.obj .\build\readMeshBase.obj .\build\readStructuredMesh.obj .\build\readUnstructuredMesh.obj /Fe</span><span style="color: #CE9178">&quot;.\build\cgnsTest.exe&quot;</span><span style="color: #D4D4D4"> /link /MACHINE:x64 /LIBPATH:</span><span style="color: #CE9178">&quot;C:\libraries\lib&quot;</span><span style="color: #D4D4D4"> cgns.lib hdf5.lib msvcrt.lib libcmt.lib</span></span>
<span class="line"><span style="color: #D4D4D4">.\build\</span><span style="color: #DCDCAA">cgnsTest.exe</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-unix">UNIX</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In a similar manner, we update the UNIX bash script <code>buildAndRun.sh</code> to build our executable. Line 9 was added to compile the unstructured mesh reading class and line 13 was modified to include the compiled object file of the unstructured mesh reading class.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#!/bin/bash\n\nrm -rf build\nmkdir -p build\n\n# compile source files into object files\ng++ -std=c++20 -I. -I ~/libs/include -c ./meshReaderLib/src/readMeshBase.cpp -o ./build/readMeshBase.o\ng++ -std=c++20 -I. -I ~/libs/include -c ./meshReaderLib/src/readStructuredMesh.cpp -o ./build/readStructuredMesh.o\ng++ -std=c++20 -I. -I ~/libs/include -c ./meshReaderLib/src/readUnstructuredMesh.cpp -o ./build/readUnstructuredMesh.o\ng++ -std=c++20 -I. -I ~/libs/include -c ./main.cpp -o ./build/main.o\n\n# link object files against CGNS library and its dependencies\ng++ -std=c++20 ./build/main.o ./build/readMeshBase.o ./build/readStructuredMesh.o ./build/readUnstructuredMesh.o -o ./build/cgnsTest -L~/libs/lib -lcgns\n\n# run executable\n./build/cgnsTest","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e#!/bin/bash\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003erm\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-rf\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003ebuild\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emkdir\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-p\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003ebuild\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# compile source files into object files\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eg++\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-std=c++20\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-I.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-I\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e~/libs/include\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-c\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./meshReaderLib/src/readMeshBase.cpp\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-o\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./build/readMeshBase.o\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eg++\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-std=c++20\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-I.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-I\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e~/libs/include\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-c\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./meshReaderLib/src/readStructuredMesh.cpp\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-o\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./build/readStructuredMesh.o\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eg++\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-std=c++20\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-I.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-I\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e~/libs/include\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-c\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./meshReaderLib/src/readUnstructuredMesh.cpp\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-o\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./build/readUnstructuredMesh.o\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eg++\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-std=c++20\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-I.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-I\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e~/libs/include\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-c\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./main.cpp\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-o\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./build/main.o\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# link object files against CGNS library and its dependencies\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eg++\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-std=c++20\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./build/main.o\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./build/readMeshBase.o\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./build/readStructuredMesh.o\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./build/readUnstructuredMesh.o\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-o\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e./build/cgnsTest\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-L~/libs/lib\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-lcgns\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# run executable\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003e./build/cgnsTest\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":16,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="#!/bin/bash

rm -rf build
mkdir -p build

# compile source files into object files
g++ -std=c++20 -I. -I ~/libs/include -c ./meshReaderLib/src/readMeshBase.cpp -o ./build/readMeshBase.o
g++ -std=c++20 -I. -I ~/libs/include -c ./meshReaderLib/src/readStructuredMesh.cpp -o ./build/readStructuredMesh.o
g++ -std=c++20 -I. -I ~/libs/include -c ./meshReaderLib/src/readUnstructuredMesh.cpp -o ./build/readUnstructuredMesh.o
g++ -std=c++20 -I. -I ~/libs/include -c ./main.cpp -o ./build/main.o

# link object files against CGNS library and its dependencies
g++ -std=c++20 ./build/main.o ./build/readMeshBase.o ./build/readStructuredMesh.o ./build/readUnstructuredMesh.o -o ./build/cgnsTest -L~/libs/lib -lcgns

# run executable
./build/cgnsTest" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #6A9955">#!/bin/bash</span></span>
<span class="line"></span>
<span class="line"><span style="color: #DCDCAA">rm</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-rf</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">build</span></span>
<span class="line"><span style="color: #DCDCAA">mkdir</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-p</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">build</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955"># compile source files into object files</span></span>
<span class="line"><span style="color: #DCDCAA">g++</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-std=c++20</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-I.</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-I</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">~/libs/include</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-c</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./meshReaderLib/src/readMeshBase.cpp</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-o</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./build/readMeshBase.o</span></span>
<span class="line"><span style="color: #DCDCAA">g++</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-std=c++20</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-I.</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-I</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">~/libs/include</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-c</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./meshReaderLib/src/readStructuredMesh.cpp</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-o</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./build/readStructuredMesh.o</span></span>
<span class="line"><span style="color: #DCDCAA">g++</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-std=c++20</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-I.</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-I</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">~/libs/include</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-c</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./meshReaderLib/src/readUnstructuredMesh.cpp</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-o</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./build/readUnstructuredMesh.o</span></span>
<span class="line"><span style="color: #DCDCAA">g++</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-std=c++20</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-I.</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-I</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">~/libs/include</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-c</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./main.cpp</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-o</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./build/main.o</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955"># link object files against CGNS library and its dependencies</span></span>
<span class="line"><span style="color: #DCDCAA">g++</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-std=c++20</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./build/main.o</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./build/readMeshBase.o</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./build/readStructuredMesh.o</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./build/readUnstructuredMesh.o</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-o</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">./build/cgnsTest</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-L~/libs/lib</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-lcgns</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955"># run executable</span></span>
<span class="line"><span style="color: #DCDCAA">./build/cgnsTest</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-header-files">Header files</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>As we did for the structured grid class, we have to add the unstructured mesh reading class to our header include file, i.e. the <code>meshReaderLib/meshReader.hpp</code> file. This is done on line 3 below.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#include \u0022meshReaderLib/include/readMeshBase.hpp\u0022\n#include \u0022meshReaderLib/include/readStructuredMesh.hpp\u0022\n#include \u0022meshReaderLib/include/readUnstructuredMesh.hpp\u0022\n#include \u0022meshReaderLib/include/types.hpp\u0022","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;meshReaderLib/include/readMeshBase.hpp\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;meshReaderLib/include/readStructuredMesh.hpp\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;meshReaderLib/include/readUnstructuredMesh.hpp\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;meshReaderLib/include/types.hpp\u0026quot;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":4,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="#include &quot;meshReaderLib/include/readMeshBase.hpp&quot;
#include &quot;meshReaderLib/include/readStructuredMesh.hpp&quot;
#include &quot;meshReaderLib/include/readUnstructuredMesh.hpp&quot;
#include &quot;meshReaderLib/include/types.hpp&quot;" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;meshReaderLib/include/readMeshBase.hpp&quot;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;meshReaderLib/include/readStructuredMesh.hpp&quot;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;meshReaderLib/include/readUnstructuredMesh.hpp&quot;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;meshReaderLib/include/types.hpp&quot;</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-main-cpp-for-testing">main.cpp for testing</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Finally, we create a similar test for reading unstructured grids in the <code>main.cpp</code> file. In the file shown below, we essentially copy and paste the code for reading a structured mesh on lines 9-13 and copy that afterwards. Replacing the class to <code>ReadUnstructuredMesh</code> and reading one of the unstructured CGNS files, we now have a quick test for reading unstructured grids. Any errors during development may then be detected if this call produces an error.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#include \u0026lt;iostream\u003e\n#include \u0026lt;filesystem\u003e\n#include \u0026lt;cmath\u003e\n#include \u0026lt;string\u003e\n\n#include \u0022meshReaderLib/meshReader.hpp\u0022\n\nint main() {\n  auto structuredMeshPathFamily = std::filesystem::path(\u0022mesh/structured2D.cgns\u0022);\n  ReadStructuredMesh structuredMeshFamily(structuredMeshPathFamily);\n  structuredMeshFamily.readMesh();\n\n  std::cout \u0026lt;\u0026lt; \u0022structured mesh was read\u0022 \u0026lt;\u0026lt; std::endl;\n\n  auto unstructuredMeshPathNoFamily = std::filesystem::path(\u0022mesh/unstructured2DNoFamily.cgns\u0022);\n  ReadUnstructuredMesh unstructuredMeshNoFamily(unstructuredMeshPathNoFamily);\n  unstructuredMeshNoFamily.readMesh();\n\n  std::cout \u0026lt;\u0026lt; \u0022unstructured mesh was read\u0022 \u0026lt;\u0026lt; std::endl;\n\n  return 0;\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;filesystem\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;meshReaderLib/meshReader.hpp\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emain\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e structuredMeshPathFamily = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003efilesystem\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epath\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;mesh/structured2D.cgns\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  ReadStructuredMesh \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003estructuredMeshFamily\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(structuredMeshPathFamily);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003estructuredMeshFamily\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;structured mesh was read\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e unstructuredMeshPathNoFamily = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003efilesystem\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epath\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;mesh/unstructured2DNoFamily.cgns\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  ReadUnstructuredMesh \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eunstructuredMeshNoFamily\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(unstructuredMeshPathNoFamily);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eunstructuredMeshNoFamily\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;unstructured mesh was read\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":22,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="#include &lt;iostream&gt;
#include &lt;filesystem&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;

#include &quot;meshReaderLib/meshReader.hpp&quot;

int main() {
  auto structuredMeshPathFamily = std::filesystem::path(&quot;mesh/structured2D.cgns&quot;);
  ReadStructuredMesh structuredMeshFamily(structuredMeshPathFamily);
  structuredMeshFamily.readMesh();

  std::cout &lt;&lt; &quot;structured mesh was read&quot; &lt;&lt; std::endl;

  auto unstructuredMeshPathNoFamily = std::filesystem::path(&quot;mesh/unstructured2DNoFamily.cgns&quot;);
  ReadUnstructuredMesh unstructuredMeshNoFamily(unstructuredMeshPathNoFamily);
  unstructuredMeshNoFamily.readMesh();

  std::cout &lt;&lt; &quot;unstructured mesh was read&quot; &lt;&lt; std::endl;

  return 0;
}" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;iostream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;filesystem&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;cmath&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;string&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;meshReaderLib/meshReader.hpp&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">main</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> structuredMeshPathFamily = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">filesystem</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">path</span><span style="color: #D4D4D4">(</span><span style="color: #CE9178">&quot;mesh/structured2D.cgns&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">  ReadStructuredMesh </span><span style="color: #DCDCAA">structuredMeshFamily</span><span style="color: #D4D4D4">(structuredMeshPathFamily);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">structuredMeshFamily</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">readMesh</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;structured mesh was read&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> unstructuredMeshPathNoFamily = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">filesystem</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">path</span><span style="color: #D4D4D4">(</span><span style="color: #CE9178">&quot;mesh/unstructured2DNoFamily.cgns&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">  ReadUnstructuredMesh </span><span style="color: #DCDCAA">unstructuredMeshNoFamily</span><span style="color: #D4D4D4">(unstructuredMeshPathNoFamily);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">unstructuredMeshNoFamily</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">readMesh</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;unstructured mesh was read&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-structure-of-a">What information is stored in an unstructured grid?</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Before we jump into the code, I thought it would be good to have a look at the unstructured grid that we are trying to read, so that we have a clear idea of what information an unstructured grid exposes. Below is a schematic drawing of the unstructured grid that we will be reading with our implementation (located in the <code>mesh/</code> folder) :</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":2665,"sizeSlug":"large","linkDestination":"none"} -->
<figure class="wp-block-image size-large"><img src="https://cfd.university/wp-content/uploads/2024/01/unstructured_grid_details-1024x642.png" alt="" class="wp-image-2665"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>There are similarities to the structured grid example that we looked at in our <a href="https://cfd.university/learn/the-complete-guide-to-structured-and-unstructured-mesh-reading-using-cgns/how-to-read-a-multi-block-structured-mesh-from-a-cgns-file" target="_blank" rel="noopener" title="">previous article</a>. We have two zones, the bounding box is from <code>0,0</code> to <code>2,1</code> (i.e. each edge for either of the zones is exactly 1 unit in length, here meters), and we have the same boundary conditions assigned. The interface is at the same location, albeit with fewer vertices that connect it now.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We see a couple of indices in the unstructured grid, the job of the mesh reading library is to read all of that information. The first task is to read all the vertices. Each vertex will have a coordinate for x and y. The vertices shown above show the zone they belong to with a superscript, and the current index within that zone with their subscript (again, indices in CGNS are Fortran-based and start at 1). With the knowledge of the bounding box being <code>0,0</code> to <code>2,1</code>, we can then read the coordinates for the different vertices. For example, we have [katex]v_2^1=(0.5,0)[/katex], [katex]v_{11}^1=(0.75,0.25)[/katex], and [katex]v_9^2=(1.5,0.5)[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>During the coordinate reading, we will read the coordinates of these vertices into 1D arrays. Having the coordinates does not provide any information about the cells they belong to, though, and this information is provided by the element connectivity array (sometimes also called an element/cell lookup table). The element connectivity array will store the indices of the vertices that make up a cell. These cells are shown above using the identifier [katex]C_{index}^{zone}[/katex]. The subscript and superscript are defined the same as for vertices.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>An example of element connectivity that makes up a cell is [katex]C_8^1=[v_1^1, v_2^1, v_{12}^1][/katex] and [katex]C_3^2=[v_2^2, v_3^2, v_4^2, v_9^2][/katex]. We can see that each cell simply stores the indices of each vertex. Should we now need to construct cell information such as the cell's centroid, its volume or one of its face area and normal vector, we simply go into the coordinate array and query the coordinates for each of the vertices in the element connectivity array for that specific cell. There are a few more steps here to get the information we need, but that is the nature of an unstructured grid that we have to accept to facilitate easier handling of complex geometries.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Interfaces and boundaries are similar to a structured grid, where we store indices in the interface or boundary, now as a 1D array of indices, rather than 2D arrays of <code>i,j</code> index pairs as we did for structured grids. As long as you feel comfortable with this discussion, the remaining write-up of how to read an unstructured grid should not be too difficult.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-creating-a-derived-class-for-unstructured-grids">Creating a derived class for unstructured grids</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>With an overview of unstructured grids in general and the updating of existing files out of the way, let's then have a look at the <code>ReadUnstructuredMesh</code> class which has its interface implemented in the header file at <code>meshReaderLib/include/readUnstructuredMesh.hpp</code> and its source file located at <code>meshReaderLib/src/readUnstructuredMesh.cpp</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-creating-the-class-interface">Creating the class interface</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The interface or class definition is provided below for the <code>ReadUnstructuredMesh</code> class. As we did for the structured grid mesh reading class, we'll break this into different components and discuss them in turn below.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#pragma once\n\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\n  #if defined(COMPILEDLL)\n    #define MESHREADERLIB_EXPORT __declspec(dllexport)\n  #elif defined(COMPILELIB)\n    #define MESHREADERLIB_EXPORT\n  #else\n    #define MESHREADERLIB_EXPORT __declspec(dllimport)\n  #endif\n#else\n  #define MESHREADERLIB_EXPORT\n#endif\n\n#include \u0026lt;filesystem\u003e\n#include \u0026lt;iostream\u003e\n#include \u0026lt;vector\u003e\n#include \u0026lt;string\u003e\n#include \u0026lt;cmath\u003e\n#include \u0026lt;unordered_map\u003e\n#include \u0026lt;algorithm\u003e\n#include \u0026lt;stdexcept\u003e\n#include \u0026lt;tuple\u003e\n\n#include \u0022cgnslib.h\u0022\n\n#include \u0022meshReaderLib/include/readMeshBase.hpp\u0022\n#include \u0022meshReaderLib/include/types.hpp\u0022\n\nclass MESHREADERLIB_EXPORT ReadUnstructuredMesh : public ReadMeshBase {\npublic:\n  using CoordinateType = typename std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;double\u003e\u003e\u003e;\n  using IndexType = std::vector\u0026lt;cgsize_t\u003e;\n  using InterfaceConnectivityType = typename std::vector\u0026lt;std::vector\u0026lt;InterfaceConnectivity\u0026lt;IndexType\u003e\u003e\u003e;\n  using BoundaryConditionInformationType = typename std::vector\u0026lt;std::vector\u0026lt;BoundaryConditionInformation\u0026lt;IndexType\u003e\u003e\u003e;\n  \n  using InternalElementConnectivityType = typename std::vector\u0026lt;std::vector\u0026lt;IndexType\u003e\u003e;\n  using InterfaceElementConnectivityType = typename std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;IndexType\u003e\u003e\u003e;\n  using BoundaryElementConnectivityType = typename std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;IndexType\u003e\u003e\u003e;\n  using StartLocationType = typename std::vector\u0026lt;IndexType\u003e;\n  using StartLocationForElementConnectivityType = typename std::tuple\u0026lt;std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e,\n    std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e, std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e\u003e;\n\npublic:\n  ReadUnstructuredMesh(std::filesystem::path cgnsFilePath);\n  void readMesh() override final;\n\n  const CoordinateType\u0026amp; getCoordinates() const { return _coordinates; };\n  const InternalElementConnectivityType\u0026amp; getInternalCells() const { return _internalElementConnectivity; };\n  const InterfaceConnectivityType getInterfaceConnectivity() const { return _interfaceConnectivity; };\n  const BoundaryConditionInformationType\u0026amp; getBoundaryConditions() const { return _boundaryConditions; };\n\nprotected:\n  void readCoorinates() override final;\n  void readInterfaceConnectivity() override final;\n  void readBoundaries() override final;\n\nprivate:\n  void readCellConnectivity();\n  StartLocationForElementConnectivityType getStartLocationForElementConnectivity() const;\n\nprivate:\n  CoordinateType _coordinates;\n  InterfaceConnectivityType _interfaceConnectivity;\n  BoundaryConditionInformationType _boundaryConditions;\n\n  InternalElementConnectivityType _internalElementConnectivity;\n  InterfaceElementConnectivityType _interfaceElementConnectivity;\n  BoundaryElementConnectivityType _boundaryElementConnectivity;\n};","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#pragma\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eonce\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#if\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(WIN32) \u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e||\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(_WIN32) \u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e||\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(__WIN32__) \u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e||\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(__NT__)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#if\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(COMPILEDLL)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#define\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e MESHREADERLIB_EXPORT __declspec(dllexport)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e  #elif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(COMPILELIB)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#define\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e MESHREADERLIB_EXPORT\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e  #else\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#define\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e MESHREADERLIB_EXPORT __declspec(dllimport)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e  #endif\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#else\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#define\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e MESHREADERLIB_EXPORT\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#endif\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;filesystem\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;unordered_map\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;stdexcept\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;tuple\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;cgnslib.h\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;meshReaderLib/include/readMeshBase.hpp\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;meshReaderLib/include/types.hpp\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eclass\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e MESHREADERLIB_EXPORT \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e : \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003epublic\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadMeshBase\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003epublic:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eCoordinateType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInterfaceConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInterfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eBoundaryConditionInformationType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eBoundaryConditionInformation\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInternalElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInterfaceElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eBoundaryElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eStartLocationType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eStartLocationForElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::tuple\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;, \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003epublic:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003efilesystem\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003epath\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ecgnsFilePath\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eoverride\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efinal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eCoordinateType\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetCoordinates\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e { \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e _coordinates; };\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInternalElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetInternalCells\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e { \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e _internalElementConnectivity; };\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInterfaceConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetInterfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e { \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e _interfaceConnectivity; };\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eBoundaryConditionInformationType\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetBoundaryConditions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e { \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e _boundaryConditions; };\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eprotected:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadCoorinates\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eoverride\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efinal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadInterfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eoverride\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efinal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadBoundaries\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eoverride\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efinal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eprivate:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadCellConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eStartLocationForElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetStartLocationForElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eprivate:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  CoordinateType _coordinates;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  InterfaceConnectivityType _interfaceConnectivity;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  BoundaryConditionInformationType _boundaryConditions;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  InternalElementConnectivityType _internalElementConnectivity;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  InterfaceElementConnectivityType _interfaceElementConnectivity;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  BoundaryElementConnectivityType _boundaryElementConnectivity;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e};\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":70,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="#pragma once

#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
  #if defined(COMPILEDLL)
    #define MESHREADERLIB_EXPORT __declspec(dllexport)
  #elif defined(COMPILELIB)
    #define MESHREADERLIB_EXPORT
  #else
    #define MESHREADERLIB_EXPORT __declspec(dllimport)
  #endif
#else
  #define MESHREADERLIB_EXPORT
#endif

#include &lt;filesystem&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;tuple&gt;

#include &quot;cgnslib.h&quot;

#include &quot;meshReaderLib/include/readMeshBase.hpp&quot;
#include &quot;meshReaderLib/include/types.hpp&quot;

class MESHREADERLIB_EXPORT ReadUnstructuredMesh : public ReadMeshBase {
public:
  using CoordinateType = typename std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;;
  using IndexType = std::vector&lt;cgsize_t&gt;;
  using InterfaceConnectivityType = typename std::vector&lt;std::vector&lt;InterfaceConnectivity&lt;IndexType&gt;&gt;&gt;;
  using BoundaryConditionInformationType = typename std::vector&lt;std::vector&lt;BoundaryConditionInformation&lt;IndexType&gt;&gt;&gt;;
  
  using InternalElementConnectivityType = typename std::vector&lt;std::vector&lt;IndexType&gt;&gt;;
  using InterfaceElementConnectivityType = typename std::vector&lt;std::vector&lt;std::vector&lt;IndexType&gt;&gt;&gt;;
  using BoundaryElementConnectivityType = typename std::vector&lt;std::vector&lt;std::vector&lt;IndexType&gt;&gt;&gt;;
  using StartLocationType = typename std::vector&lt;IndexType&gt;;
  using StartLocationForElementConnectivityType = typename std::tuple&lt;std::vector&lt;std::vector&lt;cgsize_t&gt;&gt;,
    std::vector&lt;std::vector&lt;cgsize_t&gt;&gt;, std::vector&lt;std::vector&lt;cgsize_t&gt;&gt;&gt;;

public:
  ReadUnstructuredMesh(std::filesystem::path cgnsFilePath);
  void readMesh() override final;

  const CoordinateType&amp; getCoordinates() const { return _coordinates; };
  const InternalElementConnectivityType&amp; getInternalCells() const { return _internalElementConnectivity; };
  const InterfaceConnectivityType getInterfaceConnectivity() const { return _interfaceConnectivity; };
  const BoundaryConditionInformationType&amp; getBoundaryConditions() const { return _boundaryConditions; };

protected:
  void readCoorinates() override final;
  void readInterfaceConnectivity() override final;
  void readBoundaries() override final;

private:
  void readCellConnectivity();
  StartLocationForElementConnectivityType getStartLocationForElementConnectivity() const;

private:
  CoordinateType _coordinates;
  InterfaceConnectivityType _interfaceConnectivity;
  BoundaryConditionInformationType _boundaryConditions;

  InternalElementConnectivityType _internalElementConnectivity;
  InterfaceElementConnectivityType _interfaceElementConnectivity;
  BoundaryElementConnectivityType _boundaryElementConnectivity;
};" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#pragma</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">once</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#if</span><span style="color: #569CD6"> </span><span style="color: #C586C0">defined</span><span style="color: #569CD6">(WIN32) </span><span style="color: #D4D4D4">||</span><span style="color: #569CD6"> </span><span style="color: #C586C0">defined</span><span style="color: #569CD6">(_WIN32) </span><span style="color: #D4D4D4">||</span><span style="color: #569CD6"> </span><span style="color: #C586C0">defined</span><span style="color: #569CD6">(__WIN32__) </span><span style="color: #D4D4D4">||</span><span style="color: #569CD6"> </span><span style="color: #C586C0">defined</span><span style="color: #569CD6">(__NT__)</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">#if</span><span style="color: #569CD6"> </span><span style="color: #C586C0">defined</span><span style="color: #569CD6">(COMPILEDLL)</span></span>
<span class="line"><span style="color: #569CD6">    </span><span style="color: #C586C0">#define</span><span style="color: #569CD6"> MESHREADERLIB_EXPORT __declspec(dllexport)</span></span>
<span class="line"><span style="color: #C586C0">  #elif</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">defined</span><span style="color: #D4D4D4">(COMPILELIB)</span></span>
<span class="line"><span style="color: #569CD6">    </span><span style="color: #C586C0">#define</span><span style="color: #569CD6"> MESHREADERLIB_EXPORT</span></span>
<span class="line"><span style="color: #C586C0">  #else</span></span>
<span class="line"><span style="color: #569CD6">    </span><span style="color: #C586C0">#define</span><span style="color: #569CD6"> MESHREADERLIB_EXPORT __declspec(dllimport)</span></span>
<span class="line"><span style="color: #C586C0">  #endif</span></span>
<span class="line"><span style="color: #C586C0">#else</span></span>
<span class="line"><span style="color: #569CD6">  </span><span style="color: #C586C0">#define</span><span style="color: #569CD6"> MESHREADERLIB_EXPORT</span></span>
<span class="line"><span style="color: #C586C0">#endif</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;filesystem&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;iostream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;vector&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;string&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;cmath&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;unordered_map&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;algorithm&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;stdexcept&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;tuple&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;cgnslib.h&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;meshReaderLib/include/readMeshBase.hpp&quot;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;meshReaderLib/include/types.hpp&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">class</span><span style="color: #D4D4D4"> MESHREADERLIB_EXPORT </span><span style="color: #4EC9B0">ReadUnstructuredMesh</span><span style="color: #D4D4D4"> : </span><span style="color: #569CD6">public</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">ReadMeshBase</span><span style="color: #D4D4D4"> {</span></span>
<span class="line"><span style="color: #569CD6">public:</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">CoordinateType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4"> = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">InterfaceConnectivityType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">InterfaceConnectivity</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">BoundaryConditionInformationType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">BoundaryConditionInformation</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">InternalElementConnectivityType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;&gt;;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">InterfaceElementConnectivityType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">BoundaryElementConnectivityType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">StartLocationType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">StartLocationForElementConnectivityType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::tuple&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt;,</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt;, </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">public:</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">ReadUnstructuredMesh</span><span style="color: #D4D4D4">(</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">filesystem</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">path</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">cgnsFilePath</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">readMesh</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">override</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">final</span><span style="color: #D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">CoordinateType</span><span style="color: #569CD6">&amp;</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">getCoordinates</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> { </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> _coordinates; };</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">InternalElementConnectivityType</span><span style="color: #569CD6">&amp;</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">getInternalCells</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> { </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> _internalElementConnectivity; };</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">InterfaceConnectivityType</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">getInterfaceConnectivity</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> { </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> _interfaceConnectivity; };</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">BoundaryConditionInformationType</span><span style="color: #569CD6">&amp;</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">getBoundaryConditions</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> { </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> _boundaryConditions; };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">protected:</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">readCoorinates</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">override</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">final</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">readInterfaceConnectivity</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">override</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">final</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">readBoundaries</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">override</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">final</span><span style="color: #D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">private:</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">readCellConnectivity</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">StartLocationForElementConnectivityType</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">getStartLocationForElementConnectivity</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">private:</span></span>
<span class="line"><span style="color: #D4D4D4">  CoordinateType _coordinates;</span></span>
<span class="line"><span style="color: #D4D4D4">  InterfaceConnectivityType _interfaceConnectivity;</span></span>
<span class="line"><span style="color: #D4D4D4">  BoundaryConditionInformationType _boundaryConditions;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  InternalElementConnectivityType _internalElementConnectivity;</span></span>
<span class="line"><span style="color: #D4D4D4">  InterfaceElementConnectivityType _interfaceElementConnectivity;</span></span>
<span class="line"><span style="color: #D4D4D4">  BoundaryElementConnectivityType _boundaryElementConnectivity;</span></span>
<span class="line"><span style="color: #D4D4D4">};</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-preprocessor">Preprocessor directives</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's concentrate on the preprocessor directives first. I'll also include header include statements here.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#pragma once\n\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\n  #if defined(COMPILEDLL)\n    #define MESHREADERLIB_EXPORT __declspec(dllexport)\n  #elif defined(COMPILELIB)\n    #define MESHREADERLIB_EXPORT\n  #else\n    #define MESHREADERLIB_EXPORT __declspec(dllimport)\n  #endif\n#else\n  #define MESHREADERLIB_EXPORT\n#endif\n\n#include \u0026lt;filesystem\u003e\n#include \u0026lt;iostream\u003e\n#include \u0026lt;vector\u003e\n#include \u0026lt;string\u003e\n#include \u0026lt;cmath\u003e\n#include \u0026lt;unordered_map\u003e\n#include \u0026lt;algorithm\u003e\n#include \u0026lt;stdexcept\u003e\n#include \u0026lt;tuple\u003e\n\n#include \u0022cgnslib.h\u0022\n\n#include \u0022meshReaderLib/include/readMeshBase.hpp\u0022\n#include \u0022meshReaderLib/include/types.hpp\u0022","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#pragma\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eonce\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#if\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(WIN32) \u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e||\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(_WIN32) \u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e||\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(__WIN32__) \u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e||\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(__NT__)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#if\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(COMPILEDLL)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#define\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e MESHREADERLIB_EXPORT __declspec(dllexport)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e  #elif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003edefined\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(COMPILELIB)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#define\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e MESHREADERLIB_EXPORT\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e  #else\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#define\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e MESHREADERLIB_EXPORT __declspec(dllimport)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e  #endif\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#else\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#define\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e MESHREADERLIB_EXPORT\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#endif\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;filesystem\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;cmath\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;unordered_map\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;stdexcept\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;tuple\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;cgnslib.h\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;meshReaderLib/include/readMeshBase.hpp\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;meshReaderLib/include/types.hpp\u0026quot;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":28,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="#pragma once

#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
  #if defined(COMPILEDLL)
    #define MESHREADERLIB_EXPORT __declspec(dllexport)
  #elif defined(COMPILELIB)
    #define MESHREADERLIB_EXPORT
  #else
    #define MESHREADERLIB_EXPORT __declspec(dllimport)
  #endif
#else
  #define MESHREADERLIB_EXPORT
#endif

#include &lt;filesystem&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;tuple&gt;

#include &quot;cgnslib.h&quot;

#include &quot;meshReaderLib/include/readMeshBase.hpp&quot;
#include &quot;meshReaderLib/include/types.hpp&quot;" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#pragma</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">once</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#if</span><span style="color: #569CD6"> </span><span style="color: #C586C0">defined</span><span style="color: #569CD6">(WIN32) </span><span style="color: #D4D4D4">||</span><span style="color: #569CD6"> </span><span style="color: #C586C0">defined</span><span style="color: #569CD6">(_WIN32) </span><span style="color: #D4D4D4">||</span><span style="color: #569CD6"> </span><span style="color: #C586C0">defined</span><span style="color: #569CD6">(__WIN32__) </span><span style="color: #D4D4D4">||</span><span style="color: #569CD6"> </span><span style="color: #C586C0">defined</span><span style="color: #569CD6">(__NT__)</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">#if</span><span style="color: #569CD6"> </span><span style="color: #C586C0">defined</span><span style="color: #569CD6">(COMPILEDLL)</span></span>
<span class="line"><span style="color: #569CD6">    </span><span style="color: #C586C0">#define</span><span style="color: #569CD6"> MESHREADERLIB_EXPORT __declspec(dllexport)</span></span>
<span class="line"><span style="color: #C586C0">  #elif</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">defined</span><span style="color: #D4D4D4">(COMPILELIB)</span></span>
<span class="line"><span style="color: #569CD6">    </span><span style="color: #C586C0">#define</span><span style="color: #569CD6"> MESHREADERLIB_EXPORT</span></span>
<span class="line"><span style="color: #C586C0">  #else</span></span>
<span class="line"><span style="color: #569CD6">    </span><span style="color: #C586C0">#define</span><span style="color: #569CD6"> MESHREADERLIB_EXPORT __declspec(dllimport)</span></span>
<span class="line"><span style="color: #C586C0">  #endif</span></span>
<span class="line"><span style="color: #C586C0">#else</span></span>
<span class="line"><span style="color: #569CD6">  </span><span style="color: #C586C0">#define</span><span style="color: #569CD6"> MESHREADERLIB_EXPORT</span></span>
<span class="line"><span style="color: #C586C0">#endif</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;filesystem&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;iostream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;vector&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;string&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;cmath&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;unordered_map&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;algorithm&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;stdexcept&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;tuple&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;cgnslib.h&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;meshReaderLib/include/readMeshBase.hpp&quot;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;meshReaderLib/include/types.hpp&quot;</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>We see the same dynamic library import/export statements on lines 3-13 that we have discussed at length previously. However, we see also the include statements on lines 15-28, which are a bit longer than before. We'll make use of the <code>tuple</code> header here which allows us to return more than one argument from a function. We'll make use of that during the element connectivity reading.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-specified-types">Specified types</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Lines 32-42 define a few types which are listed below.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"using CoordinateType = typename std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;double\u003e\u003e\u003e;\nusing IndexType = std::vector\u0026lt;cgsize_t\u003e;\nusing InterfaceConnectivityType = typename std::vector\u0026lt;std::vector\u0026lt;InterfaceConnectivity\u0026lt;IndexType\u003e\u003e\u003e;\nusing BoundaryConditionInformationType = typename std::vector\u0026lt;std::vector\u0026lt;BoundaryConditionInformation\u0026lt;IndexType\u003e\u003e\u003e;\n\nusing InternalElementConnectivityType = typename std::vector\u0026lt;std::vector\u0026lt;IndexType\u003e\u003e;\nusing InterfaceElementConnectivityType = typename std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;IndexType\u003e\u003e\u003e;\nusing BoundaryElementConnectivityType = typename std::vector\u0026lt;std::vector\u0026lt;std::vector\u0026lt;IndexType\u003e\u003e\u003e;\nusing StartLocationType = typename std::vector\u0026lt;IndexType\u003e;\nusing StartLocationForElementConnectivityType = typename std::tuple\u0026lt;std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e,\n  std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e, std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e\u003e;","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eCoordinateType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInterfaceConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInterfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eBoundaryConditionInformationType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eBoundaryConditionInformation\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInternalElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInterfaceElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eBoundaryElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eStartLocationType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eStartLocationForElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etypename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::tuple\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;, \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":11,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="using CoordinateType = typename std::vector&lt;std::vector&lt;std::vector&lt;double&gt;&gt;&gt;;
using IndexType = std::vector&lt;cgsize_t&gt;;
using InterfaceConnectivityType = typename std::vector&lt;std::vector&lt;InterfaceConnectivity&lt;IndexType&gt;&gt;&gt;;
using BoundaryConditionInformationType = typename std::vector&lt;std::vector&lt;BoundaryConditionInformation&lt;IndexType&gt;&gt;&gt;;

using InternalElementConnectivityType = typename std::vector&lt;std::vector&lt;IndexType&gt;&gt;;
using InterfaceElementConnectivityType = typename std::vector&lt;std::vector&lt;std::vector&lt;IndexType&gt;&gt;&gt;;
using BoundaryElementConnectivityType = typename std::vector&lt;std::vector&lt;std::vector&lt;IndexType&gt;&gt;&gt;;
using StartLocationType = typename std::vector&lt;IndexType&gt;;
using StartLocationForElementConnectivityType = typename std::tuple&lt;std::vector&lt;std::vector&lt;cgsize_t&gt;&gt;,
  std::vector&lt;std::vector&lt;cgsize_t&gt;&gt;, std::vector&lt;std::vector&lt;cgsize_t&gt;&gt;&gt;;" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">CoordinateType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4"> = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;;</span></span>
<span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">InterfaceConnectivityType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">InterfaceConnectivity</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">BoundaryConditionInformationType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">BoundaryConditionInformation</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">InternalElementConnectivityType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;&gt;;</span></span>
<span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">InterfaceElementConnectivityType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">BoundaryElementConnectivityType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span>
<span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">StartLocationType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt;;</span></span>
<span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">StartLocationForElementConnectivityType</span><span style="color: #D4D4D4"> = </span><span style="color: #569CD6">typename</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::tuple&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt;,</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt;, </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt;&gt;;</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>The coordinate type on line 1 is now a 3D array rather than a 4D array as it was for structured grids since we are storing now an unstructured list of coordinates. To index these, we only need to know the zone, vertex, and if it is the x or y coordinate. Hence we only need 3 dimensions. The  index type set on line 2 is something we saw for the structured grid as well, where it was set to <code>std::array&lt;unsigned, 2&gt;</code>, as we need an index pair of <code>i,j</code> indices to find a vertex in our grid. For unstructured grids, this is going to be a single index to find a specific vertex, no need for a second index.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The interface connectivity and boundary condition information type specified on lines 3-4 are the same as for the structured grid, but this time we store single vertex indices instead of <code>i,j</code> index pairs in these <code>struct</code>s, and this is reflected by the template argument to these two <code>struct</code>s, which uses the index type defined on line 2. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Lines 6-8 define element connectivity array types. We discussed above that the element connectivity array will hold information about which vertices make up a cell. We differentiate here between internal, interface, and boundary cells. Internal element connectivity information is stored in a 3D array where the indices index the zone, cell, and then the vertices in that cell. Interface and boundary connectivity data has one more dimension, as we need to be able to index for each zone potentially more than one interface or boundary. Thus, the 4D indices go over zones, interfaces/boundaries, cells, and then vertices within that cell.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Lines 9-10 define additional types that we will need later. The way CGNS stores element connectivity is by placing all information in one large 1D array. We need to figure out where in the 1D array we have to start reading our element connectivity for a specific cell type, for example. The type defined on line 10 will be used to store the start index for the internal, interface, and boundary element connectivity into the global 1D element connectivity array per zone.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-function-declarations">Function declarations</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The functions defined in the ReadUnstructuredMesh are similar to the ones defined in the structured mesh reading class, with a few additions to read the element connectivity data, as well as to return the element connectivity data. The function declarations are listed below again for convenience:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"public:\n  ReadUnstructuredMesh(std::filesystem::path cgnsFilePath);\n  void readMesh() override final;\n\n  const CoordinateType\u0026amp; getCoordinates() const { return _coordinates; };\n  const InternalElementConnectivityType\u0026amp; getInternalCells() const { return _internalElementConnectivity; };\n  const InterfaceConnectivityType getInterfaceConnectivity() const { return _interfaceConnectivity; };\n  const BoundaryConditionInformationType\u0026amp; getBoundaryConditions() const { return _boundaryConditions; };\n\nprotected:\n  void readCoorinates() override final;\n  void readInterfaceConnectivity() override final;\n  void readBoundaries() override final;\n\nprivate:\n  void readCellConnectivity();\n  StartLocationForElementConnectivityType getStartLocationForElementConnectivity() const;","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003epublic:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003efilesystem\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::path cgnsFilePath);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eoverride\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efinal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eCoordinateType\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetCoordinates\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e { \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e _coordinates; };\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInternalElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetInternalCells\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e { \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e _internalElementConnectivity; };\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eInterfaceConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetInterfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e { \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e _interfaceConnectivity; };\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eBoundaryConditionInformationType\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetBoundaryConditions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e { \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e _boundaryConditions; };\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eprotected:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadCoorinates\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eoverride\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efinal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadInterfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eoverride\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efinal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadBoundaries\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eoverride\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efinal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eprivate:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadCellConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eStartLocationForElementConnectivityType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetStartLocationForElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":17,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="public:
  ReadUnstructuredMesh(std::filesystem::path cgnsFilePath);
  void readMesh() override final;

  const CoordinateType&amp; getCoordinates() const { return _coordinates; };
  const InternalElementConnectivityType&amp; getInternalCells() const { return _internalElementConnectivity; };
  const InterfaceConnectivityType getInterfaceConnectivity() const { return _interfaceConnectivity; };
  const BoundaryConditionInformationType&amp; getBoundaryConditions() const { return _boundaryConditions; };

protected:
  void readCoorinates() override final;
  void readInterfaceConnectivity() override final;
  void readBoundaries() override final;

private:
  void readCellConnectivity();
  StartLocationForElementConnectivityType getStartLocationForElementConnectivity() const;" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #569CD6">public:</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">ReadUnstructuredMesh</span><span style="color: #D4D4D4">(</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">filesystem</span><span style="color: #D4D4D4">::path cgnsFilePath);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">readMesh</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">override</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">final</span><span style="color: #D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">CoordinateType</span><span style="color: #569CD6">&amp;</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">getCoordinates</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> { </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> _coordinates; };</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">InternalElementConnectivityType</span><span style="color: #569CD6">&amp;</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">getInternalCells</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> { </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> _internalElementConnectivity; };</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">InterfaceConnectivityType</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">getInterfaceConnectivity</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> { </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> _interfaceConnectivity; };</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">BoundaryConditionInformationType</span><span style="color: #569CD6">&amp;</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">getBoundaryConditions</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> { </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> _boundaryConditions; };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">protected:</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">readCoorinates</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">override</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">final</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">readInterfaceConnectivity</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">override</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">final</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">readBoundaries</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">override</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">final</span><span style="color: #D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">private:</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">readCellConnectivity</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">StartLocationForElementConnectivityType</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">getStartLocationForElementConnectivity</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4">;</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>We can see on lines 3 and 11-13 that we are implementing here our pure virtual functions defined in the base class. We can also see the different getters on lines 5-8, where we now have one additional getter on line 6 which will return the cell structure of internal cells. We did not have that getter for the structured grid case, as it is not needed (cells can be identified based on <code>i,j</code> index pairs alone). We also see that the type is different and because of these differences, we have not made any getter a pure virtual function in the base class.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are two additional functions now, which are listed in the <code>private</code> section of the class on lines 16-17, i.e. they are only visible to functions within this class. Both these functions will help us read the entire element connectivity arrays for the internal, interface, and boundary cells. This will be discussed below.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-implementing-the-interface">Implementing the interface</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now that we have the interface defined, let's go through the code and see how we implement the various functions defined in the interface.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-constructor">Constructor</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The constructor is pretty much identical to the structured mesh reading class. We receive the filename and path to the CGNS file, which we then directly pass to the base class constructor. The base class will then store this value and open the CGNS file for us (as well as read the number of bases and assert that we only have a single base).</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#include \u0022meshReaderLib/include/readUnstructuredMesh.hpp\u0022\n\nReadUnstructuredMesh::ReadUnstructuredMesh(std::filesystem::path cgnsFilePath) : ReadMeshBase(cgnsFilePath) { }","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;meshReaderLib/include/readUnstructuredMesh.hpp\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003efilesystem\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::path cgnsFilePath) : \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eReadMeshBase\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(cgnsFilePath) { }\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":3,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="#include &quot;meshReaderLib/include/readUnstructuredMesh.hpp&quot;

ReadUnstructuredMesh::ReadUnstructuredMesh(std::filesystem::path cgnsFilePath) : ReadMeshBase(cgnsFilePath) { }" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&quot;meshReaderLib/include/readUnstructuredMesh.hpp&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #4EC9B0">ReadUnstructuredMesh</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">ReadUnstructuredMesh</span><span style="color: #D4D4D4">(</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">filesystem</span><span style="color: #D4D4D4">::path cgnsFilePath) : </span><span style="color: #DCDCAA">ReadMeshBase</span><span style="color: #D4D4D4">(cgnsFilePath) { }</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-implementing-the-readmesh-function">Implementing the readMesh() function</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The <code>readMesh()</code> function is pretty similar to the structured mesh reading class again, with two small changes; first, we call the <code>readZones()</code> function defined in the base class passing the <code>Unstructured</code> zone type as an argument. Secondly, on line 4, after reading the coordinates, we read the element connectivity as an additional step, which we did not have to do for structured grids.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"void ReadUnstructuredMesh::readMesh() {\n  readZones(CGNS_ENUMV(Unstructured));\n  readCoorinates();\n  readCellConnectivity();\n  readInterfaceConnectivity();\n  readBoundaries();\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadZones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eCGNS_ENUMV\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(Unstructured));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadCoorinates\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadCellConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadInterfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadBoundaries\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":7,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="void ReadUnstructuredMesh::readMesh() {
  readZones(CGNS_ENUMV(Unstructured));
  readCoorinates();
  readCellConnectivity();
  readInterfaceConnectivity();
  readBoundaries();
}" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">ReadUnstructuredMesh</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">readMesh</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">readZones</span><span style="color: #D4D4D4">(</span><span style="color: #DCDCAA">CGNS_ENUMV</span><span style="color: #D4D4D4">(Unstructured));</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">readCoorinates</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">readCellConnectivity</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">readInterfaceConnectivity</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">readBoundaries</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-reading-coordinates-from-a-cgns-file">Reading coordinates from a CGNS file</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Even reading unstructured grid information is very similar to structured grid information. However, I'd argue that coordinate reading in a CGNS file is always easier for unstructured coordinates, as we always receive our coordinates in a 1D array from the CGNS library, which makes it easier to handle on unstructured grids. In the structured coordinate reading case, we had to then reconstruct a 2D array based on the 1D coordinate array received. We do not need to do this for unstructured grids and can simply copy the coordinates into the global coordinate array. Below is the entire code for reading coordinates and we will discuss it below in greater detail.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"void ReadUnstructuredMesh::readCoorinates() {\n  DataType_t type; char coordname[128];\n  int numberOfDimensions = _zoneSizesMax[0].size();\n\n  // resize the coordinates array, we store one per zone for both x and y\n  _coordinates.resize(_numberOfZones);\n  \n  for (int zone = 0; zone \u0026lt; _numberOfZones; ++zone) {\n    // set the number of max vertices for x and y. Coordinate reading will require this data structure later.\n    cgsize_t maxVertices = _zoneSizesMax[zone][0];\n    cgsize_t minVertices = _zoneSizesMin[zone][0];\n\n    // based on the max vertices, resize the coordinates array.\n    _coordinates[zone].resize(maxVertices);\n    for (int i = 0; i \u0026lt; maxVertices; ++i) {\n      _coordinates[zone][i].resize(numberOfDimensions);\n    }\n\n    // loop over each direction, e.g. x and y (numberOfDimensions should be 2)\n    for (int dimension = 0; dimension \u0026lt; numberOfDimensions; ++dimension) {\n      // get the coordinates information, mainly the type and name. The type is either single or double preciosion and\n      // the coordname is a SIDS-compliant identification, e.g. 'CoordinateX' and 'CoordinateY'      \n      if (cg_coord_info(_fileIndex, 1, zone + 1, dimension + 1, \u0026amp;type, coordname)) cg_error_exit();\n\n      // temporary (1D) coordinate array to store coordinates in\n      std::vector\u0026lt;double\u003e temp(maxVertices);      \n      if (cg_coord_read(_fileIndex, 1, zone + 1, coordname, type, \u0026amp;minVertices, \u0026amp;maxVertices, \u0026amp;temp[0]))\n        cg_error_exit();\n\n      // store temporary coordinates in final coordinates array\n      for (int vertex = 0; vertex \u0026lt; maxVertices; ++vertex) {\n        _coordinates[zone][vertex][dimension] = temp[vertex];\n      }\n    }\n  }\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadCoorinates\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eDataType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e type; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ecoordname\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e128\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfDimensions = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_zoneSizesMax\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // resize the coordinates array, we store one per zone for both x and y\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_coordinates\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_numberOfZones);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e zone = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; zone \u0026lt; _numberOfZones; ++zone) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // set the number of max vertices for x and y. Coordinate reading will require this data structure later.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e maxVertices = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_zoneSizesMax\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e minVertices = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_zoneSizesMin\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // based on the max vertices, resize the coordinates array.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_coordinates\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(maxVertices);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; maxVertices; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_coordinates\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][i].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfDimensions);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // loop over each direction, e.g. x and y (numberOfDimensions should be 2)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e dimension = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; dimension \u0026lt; numberOfDimensions; ++dimension) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // get the coordinates information, mainly the type and name. The type is either single or double preciosion and\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // the coordname is a SIDS-compliant identification, e.g. \u0026#39;CoordinateX\u0026#39; and \u0026#39;CoordinateY\u0026#39;      \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_coord_info\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, dimension + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;type, coordname)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // temporary (1D) coordinate array to store coordinates in\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003etemp\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(maxVertices);      \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_coord_read\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, coordname, type, \u0026amp;minVertices, \u0026amp;maxVertices, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etemp\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e]))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // store temporary coordinates in final coordinates array\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e vertex = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; vertex \u0026lt; maxVertices; ++vertex) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_coordinates\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][vertex][dimension] = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etemp\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[vertex];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":36,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="void ReadUnstructuredMesh::readCoorinates() {
  DataType_t type; char coordname[128];
  int numberOfDimensions = _zoneSizesMax[0].size();

  // resize the coordinates array, we store one per zone for both x and y
  _coordinates.resize(_numberOfZones);
  
  for (int zone = 0; zone &lt; _numberOfZones; ++zone) {
    // set the number of max vertices for x and y. Coordinate reading will require this data structure later.
    cgsize_t maxVertices = _zoneSizesMax[zone][0];
    cgsize_t minVertices = _zoneSizesMin[zone][0];

    // based on the max vertices, resize the coordinates array.
    _coordinates[zone].resize(maxVertices);
    for (int i = 0; i &lt; maxVertices; ++i) {
      _coordinates[zone][i].resize(numberOfDimensions);
    }

    // loop over each direction, e.g. x and y (numberOfDimensions should be 2)
    for (int dimension = 0; dimension &lt; numberOfDimensions; ++dimension) {
      // get the coordinates information, mainly the type and name. The type is either single or double preciosion and
      // the coordname is a SIDS-compliant identification, e.g. 'CoordinateX' and 'CoordinateY'      
      if (cg_coord_info(_fileIndex, 1, zone + 1, dimension + 1, &amp;type, coordname)) cg_error_exit();

      // temporary (1D) coordinate array to store coordinates in
      std::vector&lt;double&gt; temp(maxVertices);      
      if (cg_coord_read(_fileIndex, 1, zone + 1, coordname, type, &amp;minVertices, &amp;maxVertices, &amp;temp[0]))
        cg_error_exit();

      // store temporary coordinates in final coordinates array
      for (int vertex = 0; vertex &lt; maxVertices; ++vertex) {
        _coordinates[zone][vertex][dimension] = temp[vertex];
      }
    }
  }
}" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">ReadUnstructuredMesh</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">readCoorinates</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">DataType_t</span><span style="color: #D4D4D4"> type; </span><span style="color: #569CD6">char</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">coordname</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">128</span><span style="color: #D4D4D4">];</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfDimensions = </span><span style="color: #9CDCFE">_zoneSizesMax</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">].</span><span style="color: #DCDCAA">size</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">  // resize the coordinates array, we store one per zone for both x and y</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">_coordinates</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(_numberOfZones);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> zone = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; zone &lt; _numberOfZones; ++zone) {</span></span>
<span class="line"><span style="color: #6A9955">    // set the number of max vertices for x and y. Coordinate reading will require this data structure later.</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4"> maxVertices = </span><span style="color: #9CDCFE">_zoneSizesMax</span><span style="color: #D4D4D4">[zone][</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">];</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4"> minVertices = </span><span style="color: #9CDCFE">_zoneSizesMin</span><span style="color: #D4D4D4">[zone][</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // based on the max vertices, resize the coordinates array.</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">_coordinates</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(maxVertices);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; maxVertices; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">_coordinates</span><span style="color: #D4D4D4">[zone][i].</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(numberOfDimensions);</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // loop over each direction, e.g. x and y (numberOfDimensions should be 2)</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> dimension = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; dimension &lt; numberOfDimensions; ++dimension) {</span></span>
<span class="line"><span style="color: #6A9955">      // get the coordinates information, mainly the type and name. The type is either single or double preciosion and</span></span>
<span class="line"><span style="color: #6A9955">      // the coordname is a SIDS-compliant identification, e.g. &#39;CoordinateX&#39; and &#39;CoordinateY&#39;      </span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_coord_info</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, dimension + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;type, coordname)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">      // temporary (1D) coordinate array to store coordinates in</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">temp</span><span style="color: #D4D4D4">(maxVertices);      </span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_coord_read</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, coordname, type, &amp;minVertices, &amp;maxVertices, &amp;</span><span style="color: #9CDCFE">temp</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">]))</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">      // store temporary coordinates in final coordinates array</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> vertex = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; vertex &lt; maxVertices; ++vertex) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">_coordinates</span><span style="color: #D4D4D4">[zone][vertex][dimension] = </span><span style="color: #9CDCFE">temp</span><span style="color: #D4D4D4">[vertex];</span></span>
<span class="line"><span style="color: #D4D4D4">      }</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">  }</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Lines 2-6 are identical to the structured mesh reading case, we simply define some variables we need later and make space in our global coordinate array by allocation space for each zone. We then loop over each zone on line 8, where we now simply get the minimum and maximum number of coordinates. For structured grids, we had to get the minimum and maximum for both the x and y direction and thus this was an array with 2 entries.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We resize the global coordinates yet again to make space for all vertices and for both the x and y directions on lines 14-17 and then read the coordinates for both the x and y directions on lines 20-34. Specifically, we read the coordinate information on line 23 (e.g. are coordinates stored as single or double precision, and what is the name of the coordinate array) and then use this information to read the coordinates on line 27 into a temporary array (defined on line 26 for the number of coordinates we are going to read). As alluded to above, we then simply copy the content of the temporary array into the global coordinate array on line 32.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There is not much more to it, we discussed the coordinate reading in more depth for the structured grid class, so again, if this was too quick, I'd suggest having a look at the previous article to make sense of the above code should it not be clear.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-getting-start-location-for-elements-in-connectivity-array">Getting start location for elements in connectivity array</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We saw in the <code>readMesh()</code> function that after reading the coordinates, we read the element connectivity next. Within that function, we make a call early on to the <code>getStartLocationForElementConnectivity()</code>, in-fact, it is one of the first things we do. Thus, I want to discuss this helper function first and then look at the element connectivity reading itself.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" id="aioseo-why-we-need-the-start-location-in-the-first-place">Why we need the start location in the first place</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>So let's discuss why we need to find a start location in the element connectivity array first. As with pretty much all other CGNS functions (certainly the ones I have used thus far), whenever we request some form of an array, it is returned to us as a 1D array. If we know the precise structure (e.g. a 2D, 3 by 3 array), then we can also allocate memory for that array, pass it into CGNS, and get it returned with the correct values. We saw that when we were reading zone sizes in the base class.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This works as a 1D, 9-element array will allocate the same chunk of memory compared to a 2D, 3 by 3 array (as long as we use C-style arrays, not C++ containers!). So we just made our lives a bit easier by providing the correct dimensions during the zone reading, but we could have also passed in a 1D, 9-element array. Most of the time, though, we simply pass in a 1D allocated array of the correct size, read the information and then afterwards map it to our C++ data structure or container we want to use to permanently store that information.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With the element connectivity, things get a bit more complicated. When we receive the element connectivity, we need to know 2 things; the number of cells we are reading connectivity information for, and the number of vertices per cell, so that we can correctly size the connectivity array. If we think this through, this means that each cell type has to be stored separately and so when we are reading element connectivity information in the first zone (where we have both triangle and quad elements), we have to read element connectivity twice, one per element type (as they have different number of vertices).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Furthermore, interfaces and boundaries also need element connectivity data, and this information is also stored within each zone. Thus, we need to read several element connectivity arrays per zone. Interfaces and boundaries have helper routines that allow to distinguish interface and boundary connectivity data from other element connectivity arrays, but internal cells don't. So, we need to come up with a way to be able to distinguish each element connectivity array that we read.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We are not just getting the element connectivity, but a bunch of other information as well when we are reading this data. One of the data we are getting is the start and end index of each cell, as if all of the connectivity information was written into one large connectivity array. In the unstructured grid shown above, we saw that for zone 1, we had 8 triangles and 4 quads. So, the element connectivity may be read for the triangles first, in which case we would have <code>start=1</code> and <code>end=8</code>. Afterwards, we may read the element connectivity for the quad cells, for which we would have <code>start=9</code> and <code>end=12</code>. Then we also have interfaces and boundaries, all with their own set of start and end indices.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So you see, if we were to put all element connectivity into one large array per zone, we would need to know the start and end location for each element connectivity data. I follow a slightly different approach here, in that I want to keep all if these connectivity information separately. I want to have on for all internal cells, one for interface cells, and one for boundary cells. I may have more than 1 element type in these but I am keeping internal, interface, and boundary cells separate.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Practically speaking, this means that later when I read the actual connectivity data, I need to know if I have just read internal, interface, or boundary cells. The way for me to distinguish between these is by looking at the start location and then based on the start location infer which type I have just read. Therefore, the helper function we look at below will provide me with that information, i.e. a map between the type of element connectivity and its corresponding start location(s) in the global element connectivity array. So let's look at the code then.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" id="aioseo-implementation-of-reading-the-element-connectivity-start-locations">Implementation of reading the element connectivity start locations</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Have a look through the code below and then we'll discuss it afterwards in greater detail.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"std::tuple\u0026lt;std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e, std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e, std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e\u003e\n  ReadUnstructuredMesh::getStartLocationForElementConnectivity() const {\n\n  std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e internalElementStart(_numberOfZones);\n  std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e interfaceElementStart(_numberOfZones);\n  std::vector\u0026lt;std::vector\u0026lt;cgsize_t\u003e\u003e boundaryElementStart(_numberOfZones);\n\n  // for each zone, read the starting location of the element connectivity for internal, interface, and boundary cells\n  unsigned totalNumberOfInterfaces = 0;\n  for (int zone = 0; zone \u0026lt; _numberOfZones; ++zone) {\n    // read interface connectivity \n    int numberOfInterfaces = 0;\n    if (cg_nconns(_fileIndex, 1, zone + 1, \u0026amp;numberOfInterfaces)) cg_error_exit();\n    for (int interface = 0; interface \u0026lt; numberOfInterfaces; ++interface) {\n      char interfaceName[128], donorName[128]; GridLocation_t location; GridConnectivityType_t connectType;\n      cgsize_t donorData, numberOfPoints, numberOfDonorCells, start; DataType_t donorDataType; ZoneType_t donorZoneType;\n      PointSetType_t pointSet, donorPointSet; \n\n      if (cg_conn_info(_fileIndex, 1, zone + 1, interface + 1, interfaceName, \u0026amp;location, \u0026amp;connectType, \u0026amp;pointSet,\n        \u0026amp;numberOfPoints, donorName, \u0026amp;donorZoneType, \u0026amp;donorPointSet, \u0026amp;donorDataType, \u0026amp;numberOfDonorCells))\n        cg_error_exit();\n\n      if (cg_conn_read(_fileIndex, 1, zone + 1, interface + 1, \u0026amp;start, donorDataType, \u0026amp;donorData)) cg_error_exit();\n      interfaceElementStart[zone].push_back(start);\n      totalNumberOfInterfaces++;\n    }\n\n    // read boundary connectivity \n    int numberOfBoundaries = 0;\n    if (cg_nbocos(_fileIndex, 1, zone + 1, \u0026amp;numberOfBoundaries)) cg_error_exit();\n    for (int boundary = 0; boundary \u0026lt; numberOfBoundaries; ++boundary) {\n      int normalList; cgsize_t start;\n      if (cg_boco_read(_fileIndex, 1, zone + 1, boundary + 1, \u0026amp;start, \u0026amp;normalList)) cg_error_exit();\n      boundaryElementStart[zone].push_back(start);\n    }\n\n    // read all connectivity. we can't directly read only connectivity of internal cells but instead have to read all of\n    // them, which will include the interface and boundary connectivity, as they are all stored under the same node (we \n    // just happen to have separate functions to read boundary and interface connectivity but not for internal cells).\n    // Once we have all connectivity read, we simple remove the interface and boundary connectivity from it and are left\n    // with internal connectivity information only.\n    int numberOfSections = 0;\n    if (cg_nsections(_fileIndex, 1, zone + 1, \u0026amp;numberOfSections)) cg_error_exit();\n    for (int section = 0; section \u0026lt; numberOfSections; ++section) {\n      char sectionName[128]; ElementType_t elementType; cgsize_t start, end; int nbndry, parentFlag;\n      if (cg_section_read(_fileIndex, 1, zone + 1, section + 1, sectionName, \u0026amp;elementType, \u0026amp;start, \u0026amp;end, \u0026amp;nbndry,\n        \u0026amp;parentFlag)) cg_error_exit();\n      internalElementStart[zone].push_back(start);\n    }\n    // erase all boundary connectivity start locations from internal elements\n    for (const auto \u0026amp;boundary : boundaryElementStart[zone]) {\n      internalElementStart[zone].erase(std::remove(internalElementStart[zone].begin(), internalElementStart[zone].end(),\n        boundary), internalElementStart[zone].end());\n    }\n    // erase all interface connectivity start locations from internal elements\n    for (const auto \u0026amp;interface : interfaceElementStart[zone]) {\n      internalElementStart[zone].erase(std::remove(internalElementStart[zone].begin(), internalElementStart[zone].end(),\n        interface), internalElementStart[zone].end());\n    }\n  }\n  assert(totalNumberOfInterfaces % 2 == 0 \u0026amp;\u0026amp; \u0022Expected an even number of interface pairs\u0022);\n\n  return {internalElementStart, interfaceElementStart, boundaryElementStart};\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::tuple\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;, \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;, \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetStartLocationForElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_numberOfZones);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003einterfaceElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_numberOfZones);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eboundaryElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_numberOfZones);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // for each zone, read the starting location of the element connectivity for internal, interface, and boundary cells\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e totalNumberOfInterfaces = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e zone = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; zone \u0026lt; _numberOfZones; ++zone) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // read interface connectivity \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfInterfaces = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_nconns\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;numberOfInterfaces)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e interface = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; interface \u0026lt; numberOfInterfaces; ++interface) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceName\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e128\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e], \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edonorName\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e128\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e]; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eGridLocation_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e location; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eGridConnectivityType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e connectType;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e donorData, numberOfPoints, numberOfDonorCells, start; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eDataType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e donorDataType; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eZoneType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e donorZoneType;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ePointSetType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e pointSet, donorPointSet; \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_conn_info\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, interface + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, interfaceName, \u0026amp;location, \u0026amp;connectType, \u0026amp;pointSet,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u0026amp;numberOfPoints, donorName, \u0026amp;donorZoneType, \u0026amp;donorPointSet, \u0026amp;donorDataType, \u0026amp;numberOfDonorCells))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_conn_read\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, interface + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;start, donorDataType, \u0026amp;donorData)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epush_back\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(start);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      totalNumberOfInterfaces++;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // read boundary connectivity \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfBoundaries = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_nbocos\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;numberOfBoundaries)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e boundary = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; boundary \u0026lt; numberOfBoundaries; ++boundary) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e normalList; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e start;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_boco_read\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, boundary + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;start, \u0026amp;normalList)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundaryElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epush_back\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(start);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // read all connectivity. we can\u0026#39;t directly read only connectivity of internal cells but instead have to read all of\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // them, which will include the interface and boundary connectivity, as they are all stored under the same node (we \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // just happen to have separate functions to read boundary and interface connectivity but not for internal cells).\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // Once we have all connectivity read, we simple remove the interface and boundary connectivity from it and are left\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // with internal connectivity information only.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfSections = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_nsections\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;numberOfSections)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e section = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; section \u0026lt; numberOfSections; ++section) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003esectionName\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e128\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e]; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eElementType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e elementType; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e start, end; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e nbndry, parentFlag;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_section_read\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, section + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, sectionName, \u0026amp;elementType, \u0026amp;start, \u0026amp;end, \u0026amp;nbndry,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u0026amp;parentFlag)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epush_back\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(start);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // erase all boundary connectivity start locations from internal elements\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;boundary : \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundaryElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone]) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eerase\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eremove\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ebegin\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(),\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        boundary), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e());\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // erase all interface connectivity start locations from internal elements\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;interface : \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone]) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eerase\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eremove\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ebegin\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(),\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        interface), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e());\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eassert\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(totalNumberOfInterfaces % \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e == \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;\u0026amp; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Expected an even number of interface pairs\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e {internalElementStart, interfaceElementStart, boundaryElementStart};\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":64,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="std::tuple&lt;std::vector&lt;std::vector&lt;cgsize_t&gt;&gt;, std::vector&lt;std::vector&lt;cgsize_t&gt;&gt;, std::vector&lt;std::vector&lt;cgsize_t&gt;&gt;&gt;
  ReadUnstructuredMesh::getStartLocationForElementConnectivity() const {

  std::vector&lt;std::vector&lt;cgsize_t&gt;&gt; internalElementStart(_numberOfZones);
  std::vector&lt;std::vector&lt;cgsize_t&gt;&gt; interfaceElementStart(_numberOfZones);
  std::vector&lt;std::vector&lt;cgsize_t&gt;&gt; boundaryElementStart(_numberOfZones);

  // for each zone, read the starting location of the element connectivity for internal, interface, and boundary cells
  unsigned totalNumberOfInterfaces = 0;
  for (int zone = 0; zone &lt; _numberOfZones; ++zone) {
    // read interface connectivity 
    int numberOfInterfaces = 0;
    if (cg_nconns(_fileIndex, 1, zone + 1, &amp;numberOfInterfaces)) cg_error_exit();
    for (int interface = 0; interface &lt; numberOfInterfaces; ++interface) {
      char interfaceName[128], donorName[128]; GridLocation_t location; GridConnectivityType_t connectType;
      cgsize_t donorData, numberOfPoints, numberOfDonorCells, start; DataType_t donorDataType; ZoneType_t donorZoneType;
      PointSetType_t pointSet, donorPointSet; 

      if (cg_conn_info(_fileIndex, 1, zone + 1, interface + 1, interfaceName, &amp;location, &amp;connectType, &amp;pointSet,
        &amp;numberOfPoints, donorName, &amp;donorZoneType, &amp;donorPointSet, &amp;donorDataType, &amp;numberOfDonorCells))
        cg_error_exit();

      if (cg_conn_read(_fileIndex, 1, zone + 1, interface + 1, &amp;start, donorDataType, &amp;donorData)) cg_error_exit();
      interfaceElementStart[zone].push_back(start);
      totalNumberOfInterfaces++;
    }

    // read boundary connectivity 
    int numberOfBoundaries = 0;
    if (cg_nbocos(_fileIndex, 1, zone + 1, &amp;numberOfBoundaries)) cg_error_exit();
    for (int boundary = 0; boundary &lt; numberOfBoundaries; ++boundary) {
      int normalList; cgsize_t start;
      if (cg_boco_read(_fileIndex, 1, zone + 1, boundary + 1, &amp;start, &amp;normalList)) cg_error_exit();
      boundaryElementStart[zone].push_back(start);
    }

    // read all connectivity. we can't directly read only connectivity of internal cells but instead have to read all of
    // them, which will include the interface and boundary connectivity, as they are all stored under the same node (we 
    // just happen to have separate functions to read boundary and interface connectivity but not for internal cells).
    // Once we have all connectivity read, we simple remove the interface and boundary connectivity from it and are left
    // with internal connectivity information only.
    int numberOfSections = 0;
    if (cg_nsections(_fileIndex, 1, zone + 1, &amp;numberOfSections)) cg_error_exit();
    for (int section = 0; section &lt; numberOfSections; ++section) {
      char sectionName[128]; ElementType_t elementType; cgsize_t start, end; int nbndry, parentFlag;
      if (cg_section_read(_fileIndex, 1, zone + 1, section + 1, sectionName, &amp;elementType, &amp;start, &amp;end, &amp;nbndry,
        &amp;parentFlag)) cg_error_exit();
      internalElementStart[zone].push_back(start);
    }
    // erase all boundary connectivity start locations from internal elements
    for (const auto &amp;boundary : boundaryElementStart[zone]) {
      internalElementStart[zone].erase(std::remove(internalElementStart[zone].begin(), internalElementStart[zone].end(),
        boundary), internalElementStart[zone].end());
    }
    // erase all interface connectivity start locations from internal elements
    for (const auto &amp;interface : interfaceElementStart[zone]) {
      internalElementStart[zone].erase(std::remove(internalElementStart[zone].begin(), internalElementStart[zone].end(),
        interface), internalElementStart[zone].end());
    }
  }
  assert(totalNumberOfInterfaces % 2 == 0 &amp;&amp; &quot;Expected an even number of interface pairs&quot;);

  return {internalElementStart, interfaceElementStart, boundaryElementStart};
}" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::tuple&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt;, </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt;, </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt;&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">ReadUnstructuredMesh</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">getStartLocationForElementConnectivity</span><span style="color: #D4D4D4">() </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> {</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt; </span><span style="color: #DCDCAA">internalElementStart</span><span style="color: #D4D4D4">(_numberOfZones);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt; </span><span style="color: #DCDCAA">interfaceElementStart</span><span style="color: #D4D4D4">(_numberOfZones);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt;&gt; </span><span style="color: #DCDCAA">boundaryElementStart</span><span style="color: #D4D4D4">(_numberOfZones);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">  // for each zone, read the starting location of the element connectivity for internal, interface, and boundary cells</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> totalNumberOfInterfaces = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> zone = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; zone &lt; _numberOfZones; ++zone) {</span></span>
<span class="line"><span style="color: #6A9955">    // read interface connectivity </span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfInterfaces = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_nconns</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;numberOfInterfaces)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> interface = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; interface &lt; numberOfInterfaces; ++interface) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">char</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">interfaceName</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">128</span><span style="color: #D4D4D4">], </span><span style="color: #9CDCFE">donorName</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">128</span><span style="color: #D4D4D4">]; </span><span style="color: #4EC9B0">GridLocation_t</span><span style="color: #D4D4D4"> location; </span><span style="color: #4EC9B0">GridConnectivityType_t</span><span style="color: #D4D4D4"> connectType;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4"> donorData, numberOfPoints, numberOfDonorCells, start; </span><span style="color: #4EC9B0">DataType_t</span><span style="color: #D4D4D4"> donorDataType; </span><span style="color: #4EC9B0">ZoneType_t</span><span style="color: #D4D4D4"> donorZoneType;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #4EC9B0">PointSetType_t</span><span style="color: #D4D4D4"> pointSet, donorPointSet; </span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_conn_info</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, interface + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, interfaceName, &amp;location, &amp;connectType, &amp;pointSet,</span></span>
<span class="line"><span style="color: #D4D4D4">        &amp;numberOfPoints, donorName, &amp;donorZoneType, &amp;donorPointSet, &amp;donorDataType, &amp;numberOfDonorCells))</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_conn_read</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, interface + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;start, donorDataType, &amp;donorData)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">interfaceElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">push_back</span><span style="color: #D4D4D4">(start);</span></span>
<span class="line"><span style="color: #D4D4D4">      totalNumberOfInterfaces++;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // read boundary connectivity </span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfBoundaries = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_nbocos</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;numberOfBoundaries)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> boundary = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; boundary &lt; numberOfBoundaries; ++boundary) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> normalList; </span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4"> start;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_boco_read</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, boundary + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;start, &amp;normalList)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">boundaryElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">push_back</span><span style="color: #D4D4D4">(start);</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // read all connectivity. we can&#39;t directly read only connectivity of internal cells but instead have to read all of</span></span>
<span class="line"><span style="color: #6A9955">    // them, which will include the interface and boundary connectivity, as they are all stored under the same node (we </span></span>
<span class="line"><span style="color: #6A9955">    // just happen to have separate functions to read boundary and interface connectivity but not for internal cells).</span></span>
<span class="line"><span style="color: #6A9955">    // Once we have all connectivity read, we simple remove the interface and boundary connectivity from it and are left</span></span>
<span class="line"><span style="color: #6A9955">    // with internal connectivity information only.</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfSections = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_nsections</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;numberOfSections)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> section = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; section &lt; numberOfSections; ++section) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">char</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">sectionName</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">128</span><span style="color: #D4D4D4">]; </span><span style="color: #4EC9B0">ElementType_t</span><span style="color: #D4D4D4"> elementType; </span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4"> start, end; </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> nbndry, parentFlag;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_section_read</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, section + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, sectionName, &amp;elementType, &amp;start, &amp;end, &amp;nbndry,</span></span>
<span class="line"><span style="color: #D4D4D4">        &amp;parentFlag)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">internalElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">push_back</span><span style="color: #D4D4D4">(start);</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #6A9955">    // erase all boundary connectivity start locations from internal elements</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;boundary : </span><span style="color: #9CDCFE">boundaryElementStart</span><span style="color: #D4D4D4">[zone]) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">internalElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">erase</span><span style="color: #D4D4D4">(</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">remove</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">internalElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">begin</span><span style="color: #D4D4D4">(), </span><span style="color: #9CDCFE">internalElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">(),</span></span>
<span class="line"><span style="color: #D4D4D4">        boundary), </span><span style="color: #9CDCFE">internalElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">());</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #6A9955">    // erase all interface connectivity start locations from internal elements</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;interface : </span><span style="color: #9CDCFE">interfaceElementStart</span><span style="color: #D4D4D4">[zone]) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">internalElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">erase</span><span style="color: #D4D4D4">(</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">remove</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">internalElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">begin</span><span style="color: #D4D4D4">(), </span><span style="color: #9CDCFE">internalElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">(),</span></span>
<span class="line"><span style="color: #D4D4D4">        interface), </span><span style="color: #9CDCFE">internalElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">());</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">  }</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">assert</span><span style="color: #D4D4D4">(totalNumberOfInterfaces % </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> == </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4"> &amp;&amp; </span><span style="color: #CE9178">&quot;Expected an even number of interface pairs&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> {internalElementStart, interfaceElementStart, boundaryElementStart};</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Lines 4-9 are a bit of housekeeping, allocating space for each zone and initialising variables. We define here <code>internalElementStart</code>, <code>interfaceElementStart</code>, and <code>boundaryElementStart</code>, which are 2D <code>std::vector</code>s that store the start location into the element connectivity array for each zone. Between lines 10-60, we loop over all zones and then fill these arrays.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On lines 13-26, we read the start location for interface element connectivity data. Line 13 checks if there is any interface at all in the current zone and if so, we loop over all interfaces in that zone on lines 14-26. Line 19 reads a bunch of interface information that we largely don't care about (for now), we only care about the donorDataType variable, as we need that on line 23 to read the interface data. We get the start location within the global element connectivity array from that call. We store that start location in the <code>interfaceElementStart</code> array and increase the number of interfaces by 1.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Lines 29-35 are doing the same thing, this time just for boundary connectivity data. On line 33, we read the start location for boundary connectivity data and push that into our <code>boundaryElementStart</code> array.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Similarly, we do the same on lines 42-49 but this time for all sections. Sections will contain not just internal cells, but also interfaces and boundaries. Remember, for the 2D grid we saw above, we had a square domain for each zone, meaning we have 4 sides and thus the number of interfaces and boundaries is going to be 4. With two additional element types on the internal domain (for which we need to store separate element connectivity data), this means we are going to get 6 sections here. We read all the start locations, even if they are for interfaces or boundaries, and store that, for the moment, in the <code>internalElementStart</code> array.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The next thing we want to do is to remove both the interface's and the boundary's start locations from the <code>internalElementStart</code> array. This is what we are doing on lines 51-54 and 56-59 for the boundary and interface start locations, respectively. We make use here of the <a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Erase-Remove" target="_blank" rel="noopener" title="">erase/remove idiom</a> and this will require you to have a good grasp of C++'s standard template library (STL), which we discussed <a href="https://cfd.university/learn/what-every-cfd-developer-needs-to-know-about-c/the-power-of-the-standard-template-library-stl-in-c/" target="_blank" rel="noopener" title="">previously on this site</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In a nutshell, the STL algorithm <code>std::remove</code> will only identify which items should be removed from the container, but it does not have the authority (or knowledge of how) to do so. Removing elements is the responsibility of the container, but it does not have any specific implementation for that. Remember, the goal of the STL is to write algorithms once and use them for all containers, this means we can't implement them in container classes themselves. Thus, we first identify the items that need to be removed and then erase them from the container.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Line 61 checks if an even number of interfaces was processed and read. If we have an uneven number, we are missing an interface somewhere. Annoyingly, this behaviour is different from reading structured grids, at least the way that Pointwise is writing CGNS files, where structured grids store global interface information and unstructured grids local interface information, i.e. for each zone. Other mesh generators may differ.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On line 63, we return all start locations using a brace initialised list. In this case, the function returns a <code>std::tuple</code>, whose property it is that it can pack different variables together into a list, essentially. It's an easy way to return more than a single variable from functions, instead of passing them by reference. In this case, we can create and allocate memory within the function (as we did on lines 4-6) and then simply pass the end product out of the function, no need to allocate memory before entering the function.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-reading-cell-connectivity">Reading cell connectivity</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now that we have the start locations read for internal, interface, and boundary element connectivity data, we are able to go ahead and read the element connectivity data and store that in our class variables. The code for that is given below, we'll look at it line by line below the code.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"void ReadUnstructuredMesh::readCellConnectivity() {\n  _internalElementConnectivity.resize(_numberOfZones);\n  _interfaceElementConnectivity.resize(_numberOfZones);\n  _boundaryElementConnectivity.resize(_numberOfZones);\n\n  // the element connectivity contains the internal, interface, and boundary cells. First, we need to find out what the\n  // starting location is for each cell type so that we no which part of the connectivy array to start reading from to\n  // get internal, interface, or boudnary cell connectivity.\n  auto [internalElementStart, interfaceElementStart, boundaryElementStart] = getStartLocationForElementConnectivity();\n\n  // go through all zones and read the connectivity\n  for (int zone = 0; zone \u0026lt; _numberOfZones; ++zone) {\n    int numberOfSections;\n    if (cg_nsections(_fileIndex, 1, zone + 1, \u0026amp;numberOfSections)) cg_error_exit();\n\n    _interfaceElementConnectivity[zone].resize(interfaceElementStart[zone].size());\n    _boundaryElementConnectivity[zone].resize(boundaryElementStart[zone].size());\n    \n    unsigned internalElementIndex = 0;\n    unsigned interfaceElementIndex = 0;\n    unsigned boundaryElementIndex = 0;\n\n    // for each zone, go through all sections and read the element connectivity information\n    for (int section = 0; section \u0026lt; numberOfSections; ++section) {\n      char sectionName[128]; ElementType_t elementType; cgsize_t start, end, parentData, elementDataSize;\n      int boundaryFlag, parentFlag, numberOfVerticesPerElement;\n\n      // this routine provides us with the variable 'start', which tells us where to start reading element connectivity\n      // from. We use this value later together with the above received start locations for internal, interface, and\n      // boundary start locations to figure out what element connectivity we have just read\n      if (cg_section_read(_fileIndex, 1, zone + 1, section + 1, sectionName, \u0026amp;elementType, \u0026amp;start, \u0026amp;end, \u0026amp;boundaryFlag,\n        \u0026amp;parentFlag)) cg_error_exit();\n\n      // the number of elements in the element connectivity array\n      if (cg_ElementDataSize(_fileIndex, 1, zone + 1, section + 1, \u0026amp;elementDataSize)) cg_error_exit();\n\n      // this temporary array will hold all element connectivity information in this section\n      std::vector\u0026lt;cgsize_t\u003e elements1D(elementDataSize);\n      if (cg_elements_read(_fileIndex, 1, zone + 1, section + 1, \u0026amp;elements1D[0], \u0026amp;parentData)) cg_error_exit();\n      if (cg_npe(elementType, \u0026amp;numberOfVerticesPerElement)) cg_error_exit();\n\n      assert(elementDataSize % numberOfVerticesPerElement == 0 \u0026amp;\u0026amp;\n        \u0022The number of elements in the section is not a multiple of the number of vertices per element\u0022);\n      \n      unsigned numberOfElements = elementDataSize / numberOfVerticesPerElement;\n\n      // the element connectivity is received from CGNS in a 1D array. It has a total size of\n      // size = [numberOfElements * numberOfVerticesPerElement]. What we want, for easier indexing, is a 2D array where\n      // each dimension will have a size of [numberOfElements][numberOfVerticesPerElement]. This lambda expression does\n      // that for us. We use a lambda here because we want to use this routine 3 time (interal, interface, and boundary)\n      // cells. \n      auto map1DElementsto2DVector = [numberOfVerticesPerElement, numberOfElements, \u0026amp;elements1D]\n        (std::vector\u0026lt;ReadUnstructuredMesh::IndexType\u003e \u0026amp;target) {\n        unsigned counter = 0;\n        unsigned elementStartLocation = target.size();\n        target.resize(elementStartLocation + numberOfElements);\n        for (int element = 0; element \u0026lt; numberOfElements; ++element) {\n          unsigned elementIndex = elementStartLocation + element;\n          target[elementIndex].resize(numberOfVerticesPerElement);\n          for (int vertex = 0; vertex \u0026lt; numberOfVerticesPerElement; ++vertex) {\n            target[elementIndex][vertex] = elements1D[counter++] - 1;\n          }\n        }\n      };\n\n      auto \u0026amp;internal = internalElementStart[zone];\n      auto \u0026amp;interface = interfaceElementStart[zone];\n      auto \u0026amp;boundary = boundaryElementStart[zone];\n\n      // now we make use of the variable 'start' and the starting location for the internal, interface, and boundary\n      // cells. We go through all of them and check if they contain the value for 'start'. If so, then we know that\n      // we have read the connectivity for the internal, interface, or boundary cells. We then map the 1D connectivity\n      // array to the 2D element connectivity array using our above defined lambda expression.\n      if (std::find(internal.begin(), internal.end(), start) != internal.end()) {\n        map1DElementsto2DVector(_internalElementConnectivity[zone]);\n        internalElementIndex++;\n      } else if (std::find(interface.begin(), interface.end(), start) != interface.end()) {\n        map1DElementsto2DVector(_interfaceElementConnectivity[zone][interfaceElementIndex]);\n        interfaceElementIndex++;\n      } else if (std::find(boundary.begin(), boundary.end(), start) != boundary.end()) {\n        map1DElementsto2DVector(_boundaryElementConnectivity[zone][boundaryElementIndex]);\n        boundaryElementIndex++;\n      } else {\n        throw std::runtime_error(\u0022Could not itendify which element connectivity was read\u0022);\n      }\n    }\n    int totalSectionsProcessed = internalElementIndex + interfaceElementIndex + boundaryElementIndex;\n    assert(numberOfSections == totalSectionsProcessed \u0026amp;\u0026amp; \u0022Did not process all sections, some information is lost\u0022);\n  }\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadCellConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_internalElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_numberOfZones);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_numberOfZones);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_numberOfZones);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // the element connectivity contains the internal, interface, and boundary cells. First, we need to find out what the\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // starting location is for each cell type so that we no which part of the connectivy array to start reading from to\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // get internal, interface, or boudnary cell connectivity.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e [internalElementStart, interfaceElementStart, boundaryElementStart] = \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetStartLocationForElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // go through all zones and read the connectivity\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e zone = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; zone \u0026lt; _numberOfZones; ++zone) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfSections;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_nsections\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;numberOfSections)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e());\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundaryElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e());\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e internalElementIndex = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e interfaceElementIndex = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e boundaryElementIndex = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // for each zone, go through all sections and read the element connectivity information\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e section = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; section \u0026lt; numberOfSections; ++section) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003esectionName\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e128\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e]; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eElementType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e elementType; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e start, end, parentData, elementDataSize;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e boundaryFlag, parentFlag, numberOfVerticesPerElement;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // this routine provides us with the variable \u0026#39;start\u0026#39;, which tells us where to start reading element connectivity\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // from. We use this value later together with the above received start locations for internal, interface, and\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // boundary start locations to figure out what element connectivity we have just read\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_section_read\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, section + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, sectionName, \u0026amp;elementType, \u0026amp;start, \u0026amp;end, \u0026amp;boundaryFlag,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u0026amp;parentFlag)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // the number of elements in the element connectivity array\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_ElementDataSize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, section + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;elementDataSize)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // this temporary array will hold all element connectivity information in this section\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eelements1D\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(elementDataSize);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_elements_read\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, section + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eelements1D\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e], \u0026amp;parentData)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_npe\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(elementType, \u0026amp;numberOfVerticesPerElement)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eassert\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(elementDataSize % numberOfVerticesPerElement == \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;\u0026amp;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;The number of elements in the section is not a multiple of the number of vertices per element\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfElements = elementDataSize / numberOfVerticesPerElement;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // the element connectivity is received from CGNS in a 1D array. It has a total size of\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // size = [numberOfElements * numberOfVerticesPerElement]. What we want, for easier indexing, is a 2D array where\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // each dimension will have a size of [numberOfElements][numberOfVerticesPerElement]. This lambda expression does\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // that for us. We use a lambda here because we want to use this routine 3 time (interal, interface, and boundary)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // cells. \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e map1DElementsto2DVector = [\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfVerticesPerElement\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfElements\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eelements1D\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e]\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        (\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etarget\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e counter = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e elementStartLocation = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etarget\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etarget\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(elementStartLocation + numberOfElements);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e element = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; element \u0026lt; numberOfElements; ++element) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e          \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e elementIndex = elementStartLocation + element;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e          \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etarget\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[elementIndex].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfVerticesPerElement);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e          \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e vertex = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; vertex \u0026lt; numberOfVerticesPerElement; ++vertex) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etarget\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[elementIndex][vertex] = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eelements1D\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[counter++] - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e          }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      };\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;internal = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternalElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;interface = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;boundary = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundaryElementStart\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // now we make use of the variable \u0026#39;start\u0026#39; and the starting location for the internal, interface, and boundary\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // cells. We go through all of them and check if they contain the value for \u0026#39;start\u0026#39;. If so, then we know that\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // we have read the connectivity for the internal, interface, or boundary cells. We then map the 1D connectivity\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // array to the 2D element connectivity array using our above defined lambda expression.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ebegin\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), start) != \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e()) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emap1DElementsto2DVector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_internalElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone]);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        internalElementIndex++;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      } \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eelse\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterface\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ebegin\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterface\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), start) != \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterface\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e()) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emap1DElementsto2DVector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][interfaceElementIndex]);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        interfaceElementIndex++;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      } \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eelse\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundary\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ebegin\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundary\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), start) != \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundary\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e()) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emap1DElementsto2DVector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][boundaryElementIndex]);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        boundaryElementIndex++;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      } \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eelse\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ethrow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eruntime_error\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Could not itendify which element connectivity was read\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e totalSectionsProcessed = internalElementIndex + interfaceElementIndex + boundaryElementIndex;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eassert\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfSections == totalSectionsProcessed \u0026amp;\u0026amp; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Did not process all sections, some information is lost\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":90,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="void ReadUnstructuredMesh::readCellConnectivity() {
  _internalElementConnectivity.resize(_numberOfZones);
  _interfaceElementConnectivity.resize(_numberOfZones);
  _boundaryElementConnectivity.resize(_numberOfZones);

  // the element connectivity contains the internal, interface, and boundary cells. First, we need to find out what the
  // starting location is for each cell type so that we no which part of the connectivy array to start reading from to
  // get internal, interface, or boudnary cell connectivity.
  auto [internalElementStart, interfaceElementStart, boundaryElementStart] = getStartLocationForElementConnectivity();

  // go through all zones and read the connectivity
  for (int zone = 0; zone &lt; _numberOfZones; ++zone) {
    int numberOfSections;
    if (cg_nsections(_fileIndex, 1, zone + 1, &amp;numberOfSections)) cg_error_exit();

    _interfaceElementConnectivity[zone].resize(interfaceElementStart[zone].size());
    _boundaryElementConnectivity[zone].resize(boundaryElementStart[zone].size());
    
    unsigned internalElementIndex = 0;
    unsigned interfaceElementIndex = 0;
    unsigned boundaryElementIndex = 0;

    // for each zone, go through all sections and read the element connectivity information
    for (int section = 0; section &lt; numberOfSections; ++section) {
      char sectionName[128]; ElementType_t elementType; cgsize_t start, end, parentData, elementDataSize;
      int boundaryFlag, parentFlag, numberOfVerticesPerElement;

      // this routine provides us with the variable 'start', which tells us where to start reading element connectivity
      // from. We use this value later together with the above received start locations for internal, interface, and
      // boundary start locations to figure out what element connectivity we have just read
      if (cg_section_read(_fileIndex, 1, zone + 1, section + 1, sectionName, &amp;elementType, &amp;start, &amp;end, &amp;boundaryFlag,
        &amp;parentFlag)) cg_error_exit();

      // the number of elements in the element connectivity array
      if (cg_ElementDataSize(_fileIndex, 1, zone + 1, section + 1, &amp;elementDataSize)) cg_error_exit();

      // this temporary array will hold all element connectivity information in this section
      std::vector&lt;cgsize_t&gt; elements1D(elementDataSize);
      if (cg_elements_read(_fileIndex, 1, zone + 1, section + 1, &amp;elements1D[0], &amp;parentData)) cg_error_exit();
      if (cg_npe(elementType, &amp;numberOfVerticesPerElement)) cg_error_exit();

      assert(elementDataSize % numberOfVerticesPerElement == 0 &amp;&amp;
        &quot;The number of elements in the section is not a multiple of the number of vertices per element&quot;);
      
      unsigned numberOfElements = elementDataSize / numberOfVerticesPerElement;

      // the element connectivity is received from CGNS in a 1D array. It has a total size of
      // size = [numberOfElements * numberOfVerticesPerElement]. What we want, for easier indexing, is a 2D array where
      // each dimension will have a size of [numberOfElements][numberOfVerticesPerElement]. This lambda expression does
      // that for us. We use a lambda here because we want to use this routine 3 time (interal, interface, and boundary)
      // cells. 
      auto map1DElementsto2DVector = [numberOfVerticesPerElement, numberOfElements, &amp;elements1D]
        (std::vector&lt;ReadUnstructuredMesh::IndexType&gt; &amp;target) {
        unsigned counter = 0;
        unsigned elementStartLocation = target.size();
        target.resize(elementStartLocation + numberOfElements);
        for (int element = 0; element &lt; numberOfElements; ++element) {
          unsigned elementIndex = elementStartLocation + element;
          target[elementIndex].resize(numberOfVerticesPerElement);
          for (int vertex = 0; vertex &lt; numberOfVerticesPerElement; ++vertex) {
            target[elementIndex][vertex] = elements1D[counter++] - 1;
          }
        }
      };

      auto &amp;internal = internalElementStart[zone];
      auto &amp;interface = interfaceElementStart[zone];
      auto &amp;boundary = boundaryElementStart[zone];

      // now we make use of the variable 'start' and the starting location for the internal, interface, and boundary
      // cells. We go through all of them and check if they contain the value for 'start'. If so, then we know that
      // we have read the connectivity for the internal, interface, or boundary cells. We then map the 1D connectivity
      // array to the 2D element connectivity array using our above defined lambda expression.
      if (std::find(internal.begin(), internal.end(), start) != internal.end()) {
        map1DElementsto2DVector(_internalElementConnectivity[zone]);
        internalElementIndex++;
      } else if (std::find(interface.begin(), interface.end(), start) != interface.end()) {
        map1DElementsto2DVector(_interfaceElementConnectivity[zone][interfaceElementIndex]);
        interfaceElementIndex++;
      } else if (std::find(boundary.begin(), boundary.end(), start) != boundary.end()) {
        map1DElementsto2DVector(_boundaryElementConnectivity[zone][boundaryElementIndex]);
        boundaryElementIndex++;
      } else {
        throw std::runtime_error(&quot;Could not itendify which element connectivity was read&quot;);
      }
    }
    int totalSectionsProcessed = internalElementIndex + interfaceElementIndex + boundaryElementIndex;
    assert(numberOfSections == totalSectionsProcessed &amp;&amp; &quot;Did not process all sections, some information is lost&quot;);
  }
}" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">ReadUnstructuredMesh</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">readCellConnectivity</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">_internalElementConnectivity</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(_numberOfZones);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">_interfaceElementConnectivity</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(_numberOfZones);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">_boundaryElementConnectivity</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(_numberOfZones);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">  // the element connectivity contains the internal, interface, and boundary cells. First, we need to find out what the</span></span>
<span class="line"><span style="color: #6A9955">  // starting location is for each cell type so that we no which part of the connectivy array to start reading from to</span></span>
<span class="line"><span style="color: #6A9955">  // get internal, interface, or boudnary cell connectivity.</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> [internalElementStart, interfaceElementStart, boundaryElementStart] = </span><span style="color: #DCDCAA">getStartLocationForElementConnectivity</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">  // go through all zones and read the connectivity</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> zone = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; zone &lt; _numberOfZones; ++zone) {</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfSections;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_nsections</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;numberOfSections)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">_interfaceElementConnectivity</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">interfaceElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">size</span><span style="color: #D4D4D4">());</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">_boundaryElementConnectivity</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">boundaryElementStart</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">size</span><span style="color: #D4D4D4">());</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> internalElementIndex = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> interfaceElementIndex = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> boundaryElementIndex = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // for each zone, go through all sections and read the element connectivity information</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> section = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; section &lt; numberOfSections; ++section) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">char</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">sectionName</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">128</span><span style="color: #D4D4D4">]; </span><span style="color: #4EC9B0">ElementType_t</span><span style="color: #D4D4D4"> elementType; </span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4"> start, end, parentData, elementDataSize;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> boundaryFlag, parentFlag, numberOfVerticesPerElement;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">      // this routine provides us with the variable &#39;start&#39;, which tells us where to start reading element connectivity</span></span>
<span class="line"><span style="color: #6A9955">      // from. We use this value later together with the above received start locations for internal, interface, and</span></span>
<span class="line"><span style="color: #6A9955">      // boundary start locations to figure out what element connectivity we have just read</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_section_read</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, section + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, sectionName, &amp;elementType, &amp;start, &amp;end, &amp;boundaryFlag,</span></span>
<span class="line"><span style="color: #D4D4D4">        &amp;parentFlag)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">      // the number of elements in the element connectivity array</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_ElementDataSize</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, section + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;elementDataSize)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">      // this temporary array will hold all element connectivity information in this section</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">elements1D</span><span style="color: #D4D4D4">(elementDataSize);</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_elements_read</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, section + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;</span><span style="color: #9CDCFE">elements1D</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">], &amp;parentData)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_npe</span><span style="color: #D4D4D4">(elementType, &amp;numberOfVerticesPerElement)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #DCDCAA">assert</span><span style="color: #D4D4D4">(elementDataSize % numberOfVerticesPerElement == </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4"> &amp;&amp;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #CE9178">&quot;The number of elements in the section is not a multiple of the number of vertices per element&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">      </span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> numberOfElements = elementDataSize / numberOfVerticesPerElement;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">      // the element connectivity is received from CGNS in a 1D array. It has a total size of</span></span>
<span class="line"><span style="color: #6A9955">      // size = [numberOfElements * numberOfVerticesPerElement]. What we want, for easier indexing, is a 2D array where</span></span>
<span class="line"><span style="color: #6A9955">      // each dimension will have a size of [numberOfElements][numberOfVerticesPerElement]. This lambda expression does</span></span>
<span class="line"><span style="color: #6A9955">      // that for us. We use a lambda here because we want to use this routine 3 time (interal, interface, and boundary)</span></span>
<span class="line"><span style="color: #6A9955">      // cells. </span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> map1DElementsto2DVector = [</span><span style="color: #9CDCFE">numberOfVerticesPerElement</span><span style="color: #D4D4D4">, </span><span style="color: #9CDCFE">numberOfElements</span><span style="color: #D4D4D4">, &amp;</span><span style="color: #9CDCFE">elements1D</span><span style="color: #D4D4D4">]</span></span>
<span class="line"><span style="color: #D4D4D4">        (</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">ReadUnstructuredMesh</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt; </span><span style="color: #569CD6">&amp;</span><span style="color: #9CDCFE">target</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> counter = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> elementStartLocation = </span><span style="color: #9CDCFE">target</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">size</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">target</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(elementStartLocation + numberOfElements);</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> element = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; element &lt; numberOfElements; ++element) {</span></span>
<span class="line"><span style="color: #D4D4D4">          </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> elementIndex = elementStartLocation + element;</span></span>
<span class="line"><span style="color: #D4D4D4">          </span><span style="color: #9CDCFE">target</span><span style="color: #D4D4D4">[elementIndex].</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(numberOfVerticesPerElement);</span></span>
<span class="line"><span style="color: #D4D4D4">          </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> vertex = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; vertex &lt; numberOfVerticesPerElement; ++vertex) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #9CDCFE">target</span><span style="color: #D4D4D4">[elementIndex][vertex] = </span><span style="color: #9CDCFE">elements1D</span><span style="color: #D4D4D4">[counter++] - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">          }</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">      };</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;internal = </span><span style="color: #9CDCFE">internalElementStart</span><span style="color: #D4D4D4">[zone];</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;interface = </span><span style="color: #9CDCFE">interfaceElementStart</span><span style="color: #D4D4D4">[zone];</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;boundary = </span><span style="color: #9CDCFE">boundaryElementStart</span><span style="color: #D4D4D4">[zone];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">      // now we make use of the variable &#39;start&#39; and the starting location for the internal, interface, and boundary</span></span>
<span class="line"><span style="color: #6A9955">      // cells. We go through all of them and check if they contain the value for &#39;start&#39;. If so, then we know that</span></span>
<span class="line"><span style="color: #6A9955">      // we have read the connectivity for the internal, interface, or boundary cells. We then map the 1D connectivity</span></span>
<span class="line"><span style="color: #6A9955">      // array to the 2D element connectivity array using our above defined lambda expression.</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">internal</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">begin</span><span style="color: #D4D4D4">(), </span><span style="color: #9CDCFE">internal</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">(), start) != </span><span style="color: #9CDCFE">internal</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">()) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #DCDCAA">map1DElementsto2DVector</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">_internalElementConnectivity</span><span style="color: #D4D4D4">[zone]);</span></span>
<span class="line"><span style="color: #D4D4D4">        internalElementIndex++;</span></span>
<span class="line"><span style="color: #D4D4D4">      } </span><span style="color: #C586C0">else</span><span style="color: #D4D4D4"> </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">interface</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">begin</span><span style="color: #D4D4D4">(), </span><span style="color: #9CDCFE">interface</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">(), start) != </span><span style="color: #9CDCFE">interface</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">()) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #DCDCAA">map1DElementsto2DVector</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">_interfaceElementConnectivity</span><span style="color: #D4D4D4">[zone][interfaceElementIndex]);</span></span>
<span class="line"><span style="color: #D4D4D4">        interfaceElementIndex++;</span></span>
<span class="line"><span style="color: #D4D4D4">      } </span><span style="color: #C586C0">else</span><span style="color: #D4D4D4"> </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">boundary</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">begin</span><span style="color: #D4D4D4">(), </span><span style="color: #9CDCFE">boundary</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">(), start) != </span><span style="color: #9CDCFE">boundary</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">()) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #DCDCAA">map1DElementsto2DVector</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">_boundaryElementConnectivity</span><span style="color: #D4D4D4">[zone][boundaryElementIndex]);</span></span>
<span class="line"><span style="color: #D4D4D4">        boundaryElementIndex++;</span></span>
<span class="line"><span style="color: #D4D4D4">      } </span><span style="color: #C586C0">else</span><span style="color: #D4D4D4"> {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">throw</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">runtime_error</span><span style="color: #D4D4D4">(</span><span style="color: #CE9178">&quot;Could not itendify which element connectivity was read&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">      }</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> totalSectionsProcessed = internalElementIndex + interfaceElementIndex + boundaryElementIndex;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">assert</span><span style="color: #D4D4D4">(numberOfSections == totalSectionsProcessed &amp;&amp; </span><span style="color: #CE9178">&quot;Did not process all sections, some information is lost&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">  }</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" id="aioseo-setting-up-element-connectivity-reading">Setting up element connectivity reading</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Lines 2-4 allocate sufficient memory for our element connectivity arrays and then on line 9 we receive the starting locations for internal, interface, and boundary element connectivity from the <code>getStartLocationForElementConnectivity()</code>, which we discussed just before this section. You can see that we need to use the <code>auto []</code> syntax here to receive the elements of a <code>std::tuple</code> returned by this function, where we have as many entries within the square brackets as there are variables returned by the tuple. With this information available, we start looping over all zones on line 12.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On line 14, we see that we call <code>cg_nsections()</code>, which we also called in <code>getStartLocationForElementConnectivity()</code>. There will be an overlap of functions we have to call now as trying to get the start location for each element connectivity data will use the same CGNS mid-level library calls.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On lines 16-17, we allocate memory for the interface and boundary element connectivity data, but not for the internal cells. We may have several interfaces and/or boundaries per zone and we want to store the element connectivity data for each interface/boundary separately, hence we need to make space for as many entries as we have in the start location array. Say we have 3 entries in the start location array for the boundary element connectivity data, then we know that this corresponds to 3 different boundary conditions and so we want to create element connectivity data for each separately.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Internal cells only have a single-element connectivity array for each zone, which may contain more than one cell type, so we don't need to allocate any memory here for the connectivity data. If you look back at how the internal element connectivity data was defined in the class header/interface, you'll see that it has one dimension less than the interface and boundary element connectivity data.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" id="aioseo-reading-element-connectivity-data-for-internal-interface-and-boundary-cells">Reading element connectivity data for internal, interface, and boundary cells</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>On line 24, we start looping over all sections and remember that each section may store element connectivity data for the internal, interface, or boundary cells. We define some required CGNS variables on lines 25-26 and then start reading the information for the current section on lines 31-32. This call has the start value into the global element connectivity array, so we can compare this value later against the start locations we received on line 9 to see which type of element connectivity we have just read.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Line 35 returns to us the total number of entries in the 1D element connectivity array that we are about to read. We can use this to allocate memory for a temporary array into which we will read the element connectivity array of the current section, which we do on line 38. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On line 39, we then read the element connectivity data into our temporary array and we follow up this call by <code>cg_npe()</code>, which tells us how many vertices there are per cell for the current element. For example, for a triangle, we get 3 and for a quad element, we get 4. If we are on the boundaries or an interface, we get 2 vertices per cell, which is now of type bar (i.e. a line/edge).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Line 42 is a sanity check, we make sure that the size of the 1D element connectivity we read into the temporary array is divisible by the number of vertices per cell. If it is not, something went wrong during mesh generation and export. If this test passes, we can calculate the number of elements using line 45, i.e. take the size of the element connectivity data and divide it by the number of vertices. Since we checked that this is divisible and returns a modulus of <code>0</code>, we can be assured that this integer division will not spring up any nasty surprises.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" id="aioseo-a-lambda-expression-to-map-1d-element-connectivity-data-to-2d">A lambda expression to map 1D element connectivity data to 2D</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Lines 52-64 require a bit more explanation, so let's copy the code and put it below so that we can easily refer to it. In the code below, we are defining a lambda expression and this is a good use case for why you want to use them. <a href="https://cfd.university/learn/what-every-cfd-developer-needs-to-know-about-c/understanding-lambda-expressions-and-how-to-use-them-in-c/" target="_blank" rel="noopener" title="">We looked at lambda expressions before</a>, so you may want to go back to that article first before continuing here if you don't feel comfortable with them yet.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"auto map1DElementsto2DVector = [numberOfVerticesPerElement, numberOfElements, \u0026amp;elements1D]\n(std::vector\u0026lt;ReadUnstructuredMesh::IndexType\u003e \u0026amp;target) {\n  unsigned counter = 0;\n  unsigned elementStartLocation = target.size();\n  target.resize(elementStartLocation + numberOfElements);\n  for (int element = 0; element \u0026lt; numberOfElements; ++element) {\n    unsigned elementIndex = elementStartLocation + element;\n    target[elementIndex].resize(numberOfVerticesPerElement);\n    for (int vertex = 0; vertex \u0026lt; numberOfVerticesPerElement; ++vertex) {\n      target[elementIndex][vertex] = elements1D[counter++] - 1;\n    }\n  }\n};","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e map1DElementsto2DVector = [\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfVerticesPerElement\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfElements\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eelements1D\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e]\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eIndexType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etarget\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e counter = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e elementStartLocation = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etarget\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etarget\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(elementStartLocation + numberOfElements);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e element = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; element \u0026lt; numberOfElements; ++element) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eunsigned\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e elementIndex = elementStartLocation + element;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etarget\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[elementIndex].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfVerticesPerElement);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e vertex = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; vertex \u0026lt; numberOfVerticesPerElement; ++vertex) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etarget\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[elementIndex][vertex] = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eelements1D\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[counter++] - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e};\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":13,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="auto map1DElementsto2DVector = [numberOfVerticesPerElement, numberOfElements, &amp;elements1D]
(std::vector&lt;ReadUnstructuredMesh::IndexType&gt; &amp;target) {
  unsigned counter = 0;
  unsigned elementStartLocation = target.size();
  target.resize(elementStartLocation + numberOfElements);
  for (int element = 0; element &lt; numberOfElements; ++element) {
    unsigned elementIndex = elementStartLocation + element;
    target[elementIndex].resize(numberOfVerticesPerElement);
    for (int vertex = 0; vertex &lt; numberOfVerticesPerElement; ++vertex) {
      target[elementIndex][vertex] = elements1D[counter++] - 1;
    }
  }
};" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> map1DElementsto2DVector = [</span><span style="color: #9CDCFE">numberOfVerticesPerElement</span><span style="color: #D4D4D4">, </span><span style="color: #9CDCFE">numberOfElements</span><span style="color: #D4D4D4">, &amp;</span><span style="color: #9CDCFE">elements1D</span><span style="color: #D4D4D4">]</span></span>
<span class="line"><span style="color: #D4D4D4">(</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">ReadUnstructuredMesh</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">IndexType</span><span style="color: #D4D4D4">&gt; </span><span style="color: #569CD6">&amp;</span><span style="color: #9CDCFE">target</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> counter = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> elementStartLocation = </span><span style="color: #9CDCFE">target</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">size</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">target</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(elementStartLocation + numberOfElements);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> element = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; element &lt; numberOfElements; ++element) {</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">unsigned</span><span style="color: #D4D4D4"> elementIndex = elementStartLocation + element;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">target</span><span style="color: #D4D4D4">[elementIndex].</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(numberOfVerticesPerElement);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> vertex = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; vertex &lt; numberOfVerticesPerElement; ++vertex) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">target</span><span style="color: #D4D4D4">[elementIndex][vertex] = </span><span style="color: #9CDCFE">elements1D</span><span style="color: #D4D4D4">[counter++] - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">  }</span></span>
<span class="line"><span style="color: #D4D4D4">};</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>We create a lambda expression here because we intend to use the same function (lambda expression) for the internal, interface, and boundary cells. The job of the <code>map1DElementsto2DVector[]()</code> lambda expression is to take the 1D element connectivity that we read and then put it into either the internal, interface, or boundary element connectivity array. However, we don't just want to put the 1D array into our class variables, but rather transform the element connectivity data into a 2D array, so that we can loop over all cells and then query the vertices for that cell easily.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To do so, we first need to capture a few things in the lambda capture block, i.e. between the square brackets <code>[]</code>. We need the number of vertices per element, the number of elements, and then the temporary array that holds the 1D connectivity data. Capturing this in the lambda means we don't have to pass it as an argument. So the only argument we are passing is the internal, interface, or boundary element connectivity array, which we call <code>target</code> here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On line 4, we define an element start location. This will read the size of either the internal, interface, or boundary element connectivity data we pass into this function. For interfaces and boundaries, this will always be zero, but not necessarily for internal cells. We said that for internal cells we want to store all different types of element types in the same connectivity array.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, say we have already stored element connectivity data for triangles in our internal element connectivity array, by the time we get into this function and want to write quad element connectivity data, we need to know how much data is already in our internal element connectivity data (which is called <code>target</code> here). We then use that size and the number of elements that we calculated before and captured in this lambda to resize our target array (i.e. to allocate additional memory on top of what was already allocated, if anything).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Then, we loop over the number of elements (for which we just made space) on line 6, the following line 7 defines an element index which takes the offset into account that we discussed above (we are skipping over elements that we have already written to the <code>target</code> array), allocate enough memory to hold as many indices as we have vertices for the current element type, and then loop over the number of vertices per element.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Line 10 allows us, then, to store the 1D element connectivity data in the current <code>target</code> as a 2D array. We use the <code>counter</code> variable here defined previously on line 3 to monotonically increase the index we read. We use a little trick here in that we specify the index as <code>counter++</code>. This means that we read the value of <code>counter</code> (which is going to be <code>0</code> the first time we read it) and then we increment it by one with the <code>++</code> syntax. The next time we read the value for <code>counter</code>, it is going to be <code>1</code>, after which we increment it again, and the cycle continues.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Since CGNS uses Fortran-based indexing where the first index starts at 1, we have to subtract 1 from all of the element connectivity information we write into our internal, interface, or boundary element connectivity arrays.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" id="aioseo-writing-element-connectivity-data-into-class-variables">Writing element connectivity data into class variables</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Returning to the code printed above the lambda expression, we have arrived at lines 66-68, which are just simple helper variables that will help to reduce the code we have to write (i.e. our lines will get shorter using a variable name with fewer characters, that's all that we are trying to achieve here).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But let's look at lines 70-85, which I have copied below again for convenience:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"// now we make use of the variable 'start' and the starting location for the internal, interface, and boundary\n// cells. We go through all of them and check if they contain the value for 'start'. If so, then we know that\n// we have read the connectivity for the internal, interface, or boundary cells. We then map the 1D connectivity\n// array to the 2D element connectivity array using our above defined lambda expression.\nif (std::find(internal.begin(), internal.end(), start) != internal.end()) {\n  map1DElementsto2DVector(_internalElementConnectivity[zone]);\n  internalElementIndex++;\n} else if (std::find(interface.begin(), interface.end(), start) != interface.end()) {\n  map1DElementsto2DVector(_interfaceElementConnectivity[zone][interfaceElementIndex]);\n  interfaceElementIndex++;\n} else if (std::find(boundary.begin(), boundary.end(), start) != boundary.end()) {\n  map1DElementsto2DVector(_boundaryElementConnectivity[zone][boundaryElementIndex]);\n  boundaryElementIndex++;\n} else {\n  throw std::runtime_error(\u0022Could not itendify which element connectivity was read\u0022);\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e// now we make use of the variable \u0026#39;start\u0026#39; and the starting location for the internal, interface, and boundary\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e// cells. We go through all of them and check if they contain the value for \u0026#39;start\u0026#39;. If so, then we know that\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e// we have read the connectivity for the internal, interface, or boundary cells. We then map the 1D connectivity\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e// array to the 2D element connectivity array using our above defined lambda expression.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ebegin\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), start) != \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einternal\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e()) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emap1DElementsto2DVector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_internalElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone]);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  internalElementIndex++;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e} \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eelse\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterface\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ebegin\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterface\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), start) != \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterface\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e()) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emap1DElementsto2DVector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][interfaceElementIndex]);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  interfaceElementIndex++;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e} \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eelse\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundary\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ebegin\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundary\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), start) != \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundary\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e()) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emap1DElementsto2DVector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][boundaryElementIndex]);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  boundaryElementIndex++;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e} \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eelse\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ethrow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eruntime_error\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Could not itendify which element connectivity was read\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":16,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="// now we make use of the variable 'start' and the starting location for the internal, interface, and boundary
// cells. We go through all of them and check if they contain the value for 'start'. If so, then we know that
// we have read the connectivity for the internal, interface, or boundary cells. We then map the 1D connectivity
// array to the 2D element connectivity array using our above defined lambda expression.
if (std::find(internal.begin(), internal.end(), start) != internal.end()) {
  map1DElementsto2DVector(_internalElementConnectivity[zone]);
  internalElementIndex++;
} else if (std::find(interface.begin(), interface.end(), start) != interface.end()) {
  map1DElementsto2DVector(_interfaceElementConnectivity[zone][interfaceElementIndex]);
  interfaceElementIndex++;
} else if (std::find(boundary.begin(), boundary.end(), start) != boundary.end()) {
  map1DElementsto2DVector(_boundaryElementConnectivity[zone][boundaryElementIndex]);
  boundaryElementIndex++;
} else {
  throw std::runtime_error(&quot;Could not itendify which element connectivity was read&quot;);
}" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #6A9955">// now we make use of the variable &#39;start&#39; and the starting location for the internal, interface, and boundary</span></span>
<span class="line"><span style="color: #6A9955">// cells. We go through all of them and check if they contain the value for &#39;start&#39;. If so, then we know that</span></span>
<span class="line"><span style="color: #6A9955">// we have read the connectivity for the internal, interface, or boundary cells. We then map the 1D connectivity</span></span>
<span class="line"><span style="color: #6A9955">// array to the 2D element connectivity array using our above defined lambda expression.</span></span>
<span class="line"><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">internal</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">begin</span><span style="color: #D4D4D4">(), </span><span style="color: #9CDCFE">internal</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">(), start) != </span><span style="color: #9CDCFE">internal</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">()) {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">map1DElementsto2DVector</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">_internalElementConnectivity</span><span style="color: #D4D4D4">[zone]);</span></span>
<span class="line"><span style="color: #D4D4D4">  internalElementIndex++;</span></span>
<span class="line"><span style="color: #D4D4D4">} </span><span style="color: #C586C0">else</span><span style="color: #D4D4D4"> </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">interface</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">begin</span><span style="color: #D4D4D4">(), </span><span style="color: #9CDCFE">interface</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">(), start) != </span><span style="color: #9CDCFE">interface</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">()) {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">map1DElementsto2DVector</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">_interfaceElementConnectivity</span><span style="color: #D4D4D4">[zone][interfaceElementIndex]);</span></span>
<span class="line"><span style="color: #D4D4D4">  interfaceElementIndex++;</span></span>
<span class="line"><span style="color: #D4D4D4">} </span><span style="color: #C586C0">else</span><span style="color: #D4D4D4"> </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">boundary</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">begin</span><span style="color: #D4D4D4">(), </span><span style="color: #9CDCFE">boundary</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">(), start) != </span><span style="color: #9CDCFE">boundary</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">()) {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">map1DElementsto2DVector</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">_boundaryElementConnectivity</span><span style="color: #D4D4D4">[zone][boundaryElementIndex]);</span></span>
<span class="line"><span style="color: #D4D4D4">  boundaryElementIndex++;</span></span>
<span class="line"><span style="color: #D4D4D4">} </span><span style="color: #C586C0">else</span><span style="color: #D4D4D4"> {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">throw</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">runtime_error</span><span style="color: #D4D4D4">(</span><span style="color: #CE9178">&quot;Could not itendify which element connectivity was read&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>We define here an <code>if/else</code> statement and the goal of this <code>if/else</code> statement is to go through all of our element start location arrays (which we call now <code>internal</code>, <code>interface</code>, and <code>boundary</code> on lines 66-68 before) and check if the start location that we read for the current section (some time ago on line 31) does occur in any of the start location arrays we read at the beginning of the function on line 9. If there is a match, we then know which type we have (i.e. element connectivity data for internal, interface, or boundary cells). If there is no match, something went wrong and we terminate with a runtime exception.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The way that we look for the start location we read before is with the <code>std::find</code> algorithm. Since we defined our start location arrays as <code>std::vector</code>s, we can now go through them and find specific entries. The inputs to the <code>std::find</code> algorithm are the start and end iterator of the container, typically obtained with the <code>begin()</code> and <code>end()</code> function if the container has a directional iterator type defined. The third argument is the value we are trying to find, in the case of the start location that we read before.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We look for the start location in all three arrays, i.e. the internal, interface, and boundary start location arrays (lines 5, 8, and 11 above). If we have found the <code>start</code> value in either of them, then the <code>std::find</code> algorithm will return the iterator to the starting location array, which we don't actually care about. However, if we don't find the <code>start</code> value in any of these arrays, then the <code>std::find</code> algorithm will return the iterator which is one unit past the last value. This is what the <code>end()</code> function returns as well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, all we have to do is use the <code>std::find</code> algorithm and check if the value found is not equal to the last iterator returned by the <code>end()</code> function. If the <code>start</code> value is found in any of the arrays, we return the iterator to that value, which is going to be somewhere within the array and so by definition it is not going to be the same value as the iterator returned by <code>end()</code>. Therefore, if it is not the <code>end()</code> iterator, we know that the <code>start</code> location is in the current array and the <code>if</code> statement will be evaluated as true.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Within either of the <code>if/else</code> statements, we then go ahead and call the lambda expression defined before which will then write the current temporary 1D element connectivity data into the array passed into the lambda expression. You may notice that for internal cells we only pass <code>_internalElementConnectivity[zone]</code> whereas for interfaces and boundaries, we pass <code>_interfaceElementConnectivity[zone][interfaceElementIndex]</code> and <code>_boundaryElementConnectivity[zone][boundaryElementIndex]</code> to the lambda expression.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This has to do, again, with internal cells only storing a single connectivity array per zone, whereas interface and boundary element connectivity data is stored separately for each interface and boundary for each zone. The <code>interfaceElementIndex</code> and <code>boundaryElementIndex</code> were initially set to 0 and we are using a similar trick to what we did with the <code>counter</code> variable in the lambda, where we are just increasing this index every time we visit this if/else statement.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Incidentally, if it is the first time you are hearing about iterators, they allow us to simply loop over data in a data structure, like a <code>std::vector</code> in the above-discussed case. We looked at iterators, containers, and algorithms in <a href="https://cfd.university/learn/what-every-cfd-developer-needs-to-know-about-c/the-power-of-the-standard-template-library-stl-in-c/" target="_blank" rel="noopener" title="">my article about the C++ standard template library</a>, or the STL in short, have a look if you need a refresher.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To finish off this section, in the original code posted at the top of this section, on lines 87-88 we check that once we have processed all element connectivity data, we have visited the internal, interface, and boundary element connectivity writing routines as many times as there are sections, or, with other words, that we have not missed reading any data. Should there have been any issues before, we likely would have thrown an exception already in the <code>if/else</code> statement before, but this is one more check we can do to save us from unwanted behaviour.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-reading-interface-connectivity-for-multi-block-unstructured-grids-from-a-cgns-file">Reading interface connectivity for multi-block unstructured grids from a CGNS file</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Reading interfaces for unstructured grids is slightly different to reading interfaces on structured grids, or at least if using Pointwise. However, I'd argue that from an educational point of view, this is a good thing. We can see how to read interface information in two different ways and should you use a different mesh generator, you may have either of these forms and should be able to adapt your code. From an end-user point of view, though, it would have been nice to have a consistent interface reading implementation, but there may be good reasons why Pointwise had to implement it this way that I am unaware of.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When we were reading the interface connectivity information on the structured grid, we were reading global interface connectivity, meaning it is stored under the CGNS base node and not for each zone. If you need a refresher, have a look at the <a href="https://cfd.university/learn/the-complete-guide-to-structured-and-unstructured-mesh-reading-using-cgns/how-to-read-a-multi-block-structured-mesh-from-a-cgns-file" target="_blank" rel="noopener" title="">structured mesh reading article</a>. For unstructured meshes, Pointwise does store the information under each zone so we can simply loop over all zones and then read the interfaces as we would read boundary conditions. This is shown in the code below, which we will, as usual, discuss afterwards.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"void ReadUnstructuredMesh::readInterfaceConnectivity() {\n  char interfaceName[128], donorName[128]; GridLocation_t location; GridConnectivityType_t connectType;\n  PointSetType_t pointSet, donorPointSet; cgsize_t numberOfPoints, numberOfDonorCells;\n  ZoneType_t donorZoneType; DataType_t donorDataType;\n\n  // create map that stores, for each interface (identified by name), the zones that it connects\n  std::unordered_map\u0026lt;std::string, std::vector\u0026lt;std::array\u0026lt;int, 2\u003e\u003e\u003e interfaceNameToZone;\n  for (int zone = 0; zone \u0026lt; _numberOfZones; ++zone) {\n    int numberOfInterfaces;\n    if (cg_nconns(_fileIndex, 1, zone + 1, \u0026amp;numberOfInterfaces)) cg_error_exit();\n    for (int interface = 0; interface \u0026lt; numberOfInterfaces; ++interface) {\n      if (cg_conn_info(_fileIndex, 1, zone + 1, interface + 1, interfaceName, \u0026amp;location, \u0026amp;connectType, \u0026amp;pointSet,\n        \u0026amp;numberOfPoints, donorName, \u0026amp;donorZoneType, \u0026amp;donorPointSet, \u0026amp;donorDataType, \u0026amp;numberOfDonorCells))\n        cg_error_exit();\n      \n      if (interfaceNameToZone.find(interfaceName) == interfaceNameToZone.end())\n        interfaceNameToZone.emplace(interfaceName, std::vector\u0026lt;std::array\u0026lt;int, 2\u003e\u003e{{zone, interface}});\n      else\n        interfaceNameToZone[interfaceName].push_back({zone, interface});\n    }\n  }\n\n  // read interface connectivity for each zone\n  _interfaceConnectivity.resize(_numberOfZones);\n  for (int zone = 0; zone \u0026lt; _numberOfZones; ++zone) {    \n    int numberOfInterfaces;\n    if (cg_nconns(_fileIndex, 1, zone + 1, \u0026amp;numberOfInterfaces)) cg_error_exit();\n    assert(numberOfInterfaces == _interfaceElementConnectivity[zone].size() \u0026amp;\u0026amp; \u0022The number of interfaces should be the\u0022\n      \u0022 same as the number of interfaces for which elements have been read\u0022);\n\n    // for each zone, go through all interfaces stored in this zone and store the connectivity information\n    _interfaceConnectivity[zone].resize(numberOfInterfaces);\n    for (int interface = 0; interface \u0026lt; numberOfInterfaces; ++interface) {\n      if (cg_conn_info(_fileIndex, 1, zone + 1, interface + 1, interfaceName, \u0026amp;location, \u0026amp;connectType, \u0026amp;pointSet,\n        \u0026amp;numberOfPoints, donorName, \u0026amp;donorZoneType, \u0026amp;donorPointSet, \u0026amp;donorDataType, \u0026amp;numberOfDonorCells))\n        cg_error_exit();\n        \n      assert(donorZoneType == CGNS_ENUMV(Unstructured) \u0026amp;\u0026amp; \u0022Expected unstructured interface\u0022);\n\n      auto zones = interfaceNameToZone[interfaceName];\n      assert(zones.size() == 2 \u0026amp;\u0026amp; \u0022Expected 2 zones per interface\u0022);\n\n      const auto \u0026amp;zoneOwner = zones[0][0];\n      const auto \u0026amp;interfaceOwner = zones[0][1];\n      const auto \u0026amp;zoneNeighbour = zones[1][0];\n      const auto \u0026amp;interfaceNeighbour = zones[1][1];\n\n      _interfaceConnectivity[zone][interface].zones = {zoneOwner, zoneNeighbour};\n      _interfaceConnectivity[zone][interface].ownerIndex = _interfaceElementConnectivity[zoneOwner][interfaceOwner];\n      _interfaceConnectivity[zone][interface].neighbourIndex =\n        _interfaceElementConnectivity[zoneNeighbour][interfaceNeighbour];\n    }\n  }\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadInterfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceName\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e128\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e], \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edonorName\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e128\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e]; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eGridLocation_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e location; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eGridConnectivityType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e connectType;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ePointSetType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e pointSet, donorPointSet; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfPoints, numberOfDonorCells;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eZoneType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e donorZoneType; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eDataType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e donorDataType;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // create map that stores, for each interface (identified by name), the zones that it connects\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::unordered_map\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::string, \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::array\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt; interfaceNameToZone;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e zone = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; zone \u0026lt; _numberOfZones; ++zone) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfInterfaces;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_nconns\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;numberOfInterfaces)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e interface = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; interface \u0026lt; numberOfInterfaces; ++interface) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_conn_info\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, interface + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, interfaceName, \u0026amp;location, \u0026amp;connectType, \u0026amp;pointSet,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u0026amp;numberOfPoints, donorName, \u0026amp;donorZoneType, \u0026amp;donorPointSet, \u0026amp;donorDataType, \u0026amp;numberOfDonorCells))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceNameToZone\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(interfaceName) == \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceNameToZone\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e())\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceNameToZone\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eemplace\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(interfaceName, \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::array\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;{{zone, interface}});\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eelse\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceNameToZone\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[interfaceName].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epush_back\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e({zone, interface});\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // read interface connectivity for each zone\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_numberOfZones);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e zone = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; zone \u0026lt; _numberOfZones; ++zone) {    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfInterfaces;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_nconns\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;numberOfInterfaces)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eassert\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfInterfaces == \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u0026amp;\u0026amp; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;The number of interfaces should be the\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot; same as the number of interfaces for which elements have been read\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // for each zone, go through all interfaces stored in this zone and store the connectivity information\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfInterfaces);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e interface = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; interface \u0026lt; numberOfInterfaces; ++interface) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_conn_info\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, interface + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, interfaceName, \u0026amp;location, \u0026amp;connectType, \u0026amp;pointSet,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u0026amp;numberOfPoints, donorName, \u0026amp;donorZoneType, \u0026amp;donorPointSet, \u0026amp;donorDataType, \u0026amp;numberOfDonorCells))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eassert\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(donorZoneType == \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eCGNS_ENUMV\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(Unstructured) \u0026amp;\u0026amp; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Expected unstructured interface\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e zones = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceNameToZone\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[interfaceName];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eassert\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() == \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;\u0026amp; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Expected 2 zones per interface\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;zoneOwner = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e][\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;interfaceOwner = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e][\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;zoneNeighbour = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e][\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;interfaceNeighbour = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e][\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][interface].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = {zoneOwner, zoneNeighbour};\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][interface].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eownerIndex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zoneOwner][interfaceOwner];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][interface].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eneighbourIndex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e =\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zoneNeighbour][interfaceNeighbour];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":54,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="void ReadUnstructuredMesh::readInterfaceConnectivity() {
  char interfaceName[128], donorName[128]; GridLocation_t location; GridConnectivityType_t connectType;
  PointSetType_t pointSet, donorPointSet; cgsize_t numberOfPoints, numberOfDonorCells;
  ZoneType_t donorZoneType; DataType_t donorDataType;

  // create map that stores, for each interface (identified by name), the zones that it connects
  std::unordered_map&lt;std::string, std::vector&lt;std::array&lt;int, 2&gt;&gt;&gt; interfaceNameToZone;
  for (int zone = 0; zone &lt; _numberOfZones; ++zone) {
    int numberOfInterfaces;
    if (cg_nconns(_fileIndex, 1, zone + 1, &amp;numberOfInterfaces)) cg_error_exit();
    for (int interface = 0; interface &lt; numberOfInterfaces; ++interface) {
      if (cg_conn_info(_fileIndex, 1, zone + 1, interface + 1, interfaceName, &amp;location, &amp;connectType, &amp;pointSet,
        &amp;numberOfPoints, donorName, &amp;donorZoneType, &amp;donorPointSet, &amp;donorDataType, &amp;numberOfDonorCells))
        cg_error_exit();
      
      if (interfaceNameToZone.find(interfaceName) == interfaceNameToZone.end())
        interfaceNameToZone.emplace(interfaceName, std::vector&lt;std::array&lt;int, 2&gt;&gt;{{zone, interface}});
      else
        interfaceNameToZone[interfaceName].push_back({zone, interface});
    }
  }

  // read interface connectivity for each zone
  _interfaceConnectivity.resize(_numberOfZones);
  for (int zone = 0; zone &lt; _numberOfZones; ++zone) {    
    int numberOfInterfaces;
    if (cg_nconns(_fileIndex, 1, zone + 1, &amp;numberOfInterfaces)) cg_error_exit();
    assert(numberOfInterfaces == _interfaceElementConnectivity[zone].size() &amp;&amp; &quot;The number of interfaces should be the&quot;
      &quot; same as the number of interfaces for which elements have been read&quot;);

    // for each zone, go through all interfaces stored in this zone and store the connectivity information
    _interfaceConnectivity[zone].resize(numberOfInterfaces);
    for (int interface = 0; interface &lt; numberOfInterfaces; ++interface) {
      if (cg_conn_info(_fileIndex, 1, zone + 1, interface + 1, interfaceName, &amp;location, &amp;connectType, &amp;pointSet,
        &amp;numberOfPoints, donorName, &amp;donorZoneType, &amp;donorPointSet, &amp;donorDataType, &amp;numberOfDonorCells))
        cg_error_exit();
        
      assert(donorZoneType == CGNS_ENUMV(Unstructured) &amp;&amp; &quot;Expected unstructured interface&quot;);

      auto zones = interfaceNameToZone[interfaceName];
      assert(zones.size() == 2 &amp;&amp; &quot;Expected 2 zones per interface&quot;);

      const auto &amp;zoneOwner = zones[0][0];
      const auto &amp;interfaceOwner = zones[0][1];
      const auto &amp;zoneNeighbour = zones[1][0];
      const auto &amp;interfaceNeighbour = zones[1][1];

      _interfaceConnectivity[zone][interface].zones = {zoneOwner, zoneNeighbour};
      _interfaceConnectivity[zone][interface].ownerIndex = _interfaceElementConnectivity[zoneOwner][interfaceOwner];
      _interfaceConnectivity[zone][interface].neighbourIndex =
        _interfaceElementConnectivity[zoneNeighbour][interfaceNeighbour];
    }
  }
}" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">ReadUnstructuredMesh</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">readInterfaceConnectivity</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">char</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">interfaceName</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">128</span><span style="color: #D4D4D4">], </span><span style="color: #9CDCFE">donorName</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">128</span><span style="color: #D4D4D4">]; </span><span style="color: #4EC9B0">GridLocation_t</span><span style="color: #D4D4D4"> location; </span><span style="color: #4EC9B0">GridConnectivityType_t</span><span style="color: #D4D4D4"> connectType;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">PointSetType_t</span><span style="color: #D4D4D4"> pointSet, donorPointSet; </span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4"> numberOfPoints, numberOfDonorCells;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">ZoneType_t</span><span style="color: #D4D4D4"> donorZoneType; </span><span style="color: #4EC9B0">DataType_t</span><span style="color: #D4D4D4"> donorDataType;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">  // create map that stores, for each interface (identified by name), the zones that it connects</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::unordered_map&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::string, </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::array&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4">&gt;&gt;&gt; interfaceNameToZone;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> zone = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; zone &lt; _numberOfZones; ++zone) {</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfInterfaces;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_nconns</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;numberOfInterfaces)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> interface = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; interface &lt; numberOfInterfaces; ++interface) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_conn_info</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, interface + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, interfaceName, &amp;location, &amp;connectType, &amp;pointSet,</span></span>
<span class="line"><span style="color: #D4D4D4">        &amp;numberOfPoints, donorName, &amp;donorZoneType, &amp;donorPointSet, &amp;donorDataType, &amp;numberOfDonorCells))</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">      </span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #9CDCFE">interfaceNameToZone</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(interfaceName) == </span><span style="color: #9CDCFE">interfaceNameToZone</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">end</span><span style="color: #D4D4D4">())</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">interfaceNameToZone</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">emplace</span><span style="color: #D4D4D4">(interfaceName, </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::array&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4">&gt;&gt;{{zone, interface}});</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">else</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">interfaceNameToZone</span><span style="color: #D4D4D4">[interfaceName].</span><span style="color: #DCDCAA">push_back</span><span style="color: #D4D4D4">({zone, interface});</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">  // read interface connectivity for each zone</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">_interfaceConnectivity</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(_numberOfZones);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> zone = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; zone &lt; _numberOfZones; ++zone) {    </span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfInterfaces;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_nconns</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;numberOfInterfaces)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">assert</span><span style="color: #D4D4D4">(numberOfInterfaces == </span><span style="color: #9CDCFE">_interfaceElementConnectivity</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">size</span><span style="color: #D4D4D4">() &amp;&amp; </span><span style="color: #CE9178">&quot;The number of interfaces should be the&quot;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #CE9178">&quot; same as the number of interfaces for which elements have been read&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // for each zone, go through all interfaces stored in this zone and store the connectivity information</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">_interfaceConnectivity</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(numberOfInterfaces);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> interface = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; interface &lt; numberOfInterfaces; ++interface) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_conn_info</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, interface + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, interfaceName, &amp;location, &amp;connectType, &amp;pointSet,</span></span>
<span class="line"><span style="color: #D4D4D4">        &amp;numberOfPoints, donorName, &amp;donorZoneType, &amp;donorPointSet, &amp;donorDataType, &amp;numberOfDonorCells))</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">        </span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #DCDCAA">assert</span><span style="color: #D4D4D4">(donorZoneType == </span><span style="color: #DCDCAA">CGNS_ENUMV</span><span style="color: #D4D4D4">(Unstructured) &amp;&amp; </span><span style="color: #CE9178">&quot;Expected unstructured interface&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> zones = </span><span style="color: #9CDCFE">interfaceNameToZone</span><span style="color: #D4D4D4">[interfaceName];</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #DCDCAA">assert</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">size</span><span style="color: #D4D4D4">() == </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> &amp;&amp; </span><span style="color: #CE9178">&quot;Expected 2 zones per interface&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;zoneOwner = </span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">][</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">];</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;interfaceOwner = </span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">][</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">];</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;zoneNeighbour = </span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">][</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">];</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;interfaceNeighbour = </span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">][</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">_interfaceConnectivity</span><span style="color: #D4D4D4">[zone][interface].</span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4"> = {zoneOwner, zoneNeighbour};</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">_interfaceConnectivity</span><span style="color: #D4D4D4">[zone][interface].</span><span style="color: #9CDCFE">ownerIndex</span><span style="color: #D4D4D4"> = </span><span style="color: #9CDCFE">_interfaceElementConnectivity</span><span style="color: #D4D4D4">[zoneOwner][interfaceOwner];</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">_interfaceConnectivity</span><span style="color: #D4D4D4">[zone][interface].</span><span style="color: #9CDCFE">neighbourIndex</span><span style="color: #D4D4D4"> =</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">_interfaceElementConnectivity</span><span style="color: #D4D4D4">[zoneNeighbour][interfaceNeighbour];</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">  }</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" id="aioseo-creating-a-zone-index-lookup-table">Creating a zone index lookup table</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>As we have seen before, CGNS is not always providing us with all the information we need. I'm not sure if this is by choice or if the steering committee did overlook some vital information its functions should be returning. It seems odd, given that the CGNS routines return so many different variables, most of which don't even have data, but are there just in case someone wants to implement and consume it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When it comes to an interface, the most important part that we want to know is which two zones are connected. Without that information, we don't have an interface, yet the CGNS standard does not require it. This is why we have to generate yet another look-up table that we will use to store all zones that are connected to the same interface, identified by the interface name. There should only ever be 2, and exactly 2, zones attached to the same interface.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is what is done between lines 7-21. On line 7, we define a <code>std::unordered_map</code> called <code>interfaceNameToZone</code>, which will be our lookup table, i.e. where we store, for each interface name, all zones that attach to it. We have to store to information, the zone index, and the interface index. We will use these later to uniquely identify interfaces with a zone that belong connect to interfaces on a different zone. We store this informationin a <code>std::vector</code>, which itself stores a <code>std::array</code> with two entries (one for the zone and one for the interface index).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Line 8 loops over all zones, and subsequently we check the total number of interfaces for that zone and loop over all interfaces in that zone on line 11.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On line 12, we call <code>cg_conn_info()</code>, which will provide us with the interface name, i.e. the variable <code>interfaceName</code>. We know the zone that is attached to this interface from our loop variable <code>zone</code> defined in the <code>for</code> loop on line 8.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Line 16 checks if we already have an entry in the lookup table, i.e. the <code>interfaceNameToZone</code> variable. We are using the same <code>std::find()</code> algorithm here discussed above in the element connectivity reading and we are checking again if the algorithm returns the <code>end()</code> iterator, meaning that the interface name is not yet in our lookup table. If that is the case, we create a new entry for it on line 17, where we tie the name of the interface with the zone and interface that we are currently in.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We initialise a <code>std::vector</code> as the second argument and we add one entry using the brace initialiser list. Since the entry into the <code>std::vector</code> is itself a <code>std::array</code>, which also needs to be brace initialised, we have the double brace syntax, i.e. {{zone, interface}}. So the outer braces contain one element for the <code>std::vector</code>, and the inner braces contain two elements for the <code>std::array</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we have written the interface name to the lookup table and we loop over the remaining zones and interfaces, eventually we will reach the other side of the interface in a different zone. Once that is the case, the <code>interfaceName</code> variable read on line 12 in the <code>cg_conn_info()</code> function is going to be the same as for the interface information we were writing earlier.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When we now get to line 16, we check if the interface name is in our lookup variable, which it is, so the iterator returned will not be equal to the last iterator returned by the <code>end()</code> function. Thus, we jump straight to line 18 and execute the <code>else</code> statement, where we simply add the current zone and interface to the <code>std::vector</code>, which should now hold two <code>std::arrays</code> with the different zone and interface indices.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":5} -->
<h5 class="wp-block-heading" id="aioseo-reading-interface-connectivity-data">Reading interface connectivity data</h5>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>To be fair, quite a lot of the heavy lifting has already been done. We have the lookup table and know which interface name connects to which zones, and we have read the interface element connectivity data, so the remaining steps are rather straightforward with that information at hand. This is done in the code above between lines 24-53. The <code>_interfaceConnectivity</code> variable will contain all of the interface data so we first allocate sufficient memory for all zones, and then find the number of interfaces, allocate memory for each interface per zone, and then loop over all interfaces in the current zone on line 33.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It is perhaps worth pointing out that we do some sanity checks here on line 28, i.e. we are testing the number of element connectivities we have available. Remember, we are storing this information for each interface separately, so if we have 2 interfaces in one zone, we expect 2 separate element connectivity arrays.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Between lines 33-52, we are now reading the interface data and storing the already processed interface data in this part. For simplicity, I have copied the code again below so we don't have to scroll up and down:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"for (int interface = 0; interface \u0026lt; numberOfInterfaces; ++interface) {\n  if (cg_conn_info(_fileIndex, 1, zone + 1, interface + 1, interfaceName, \u0026amp;location, \u0026amp;connectType, \u0026amp;pointSet,\n    \u0026amp;numberOfPoints, donorName, \u0026amp;donorZoneType, \u0026amp;donorPointSet, \u0026amp;donorDataType, \u0026amp;numberOfDonorCells))\n    cg_error_exit();\n    \n  assert(donorZoneType == CGNS_ENUMV(Unstructured) \u0026amp;\u0026amp; \u0022Expected unstructured interface\u0022);\n\n  auto zones = interfaceNameToZone[interfaceName];\n  assert(zones.size() == 2 \u0026amp;\u0026amp; \u0022Expected 2 zones per interface\u0022);\n\n  const auto \u0026amp;zoneOwner = zones[0][0];\n  const auto \u0026amp;interfaceOwner = zones[0][1];\n  const auto \u0026amp;zoneNeighbour = zones[1][0];\n  const auto \u0026amp;interfaceNeighbour = zones[1][1];\n\n  _interfaceConnectivity[zone][interface].zones = {zoneOwner, zoneNeighbour};\n  _interfaceConnectivity[zone][interface].ownerIndex = _interfaceElementConnectivity[zoneOwner][interfaceOwner];\n  _interfaceConnectivity[zone][interface].neighbourIndex =\n    _interfaceElementConnectivity[zoneNeighbour][interfaceNeighbour];\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e interface = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; interface \u0026lt; numberOfInterfaces; ++interface) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_conn_info\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, interface + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, interfaceName, \u0026amp;location, \u0026amp;connectType, \u0026amp;pointSet,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u0026amp;numberOfPoints, donorName, \u0026amp;donorZoneType, \u0026amp;donorPointSet, \u0026amp;donorDataType, \u0026amp;numberOfDonorCells))\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eassert\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(donorZoneType == \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eCGNS_ENUMV\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(Unstructured) \u0026amp;\u0026amp; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Expected unstructured interface\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e zones = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003einterfaceNameToZone\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[interfaceName];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eassert\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() == \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;\u0026amp; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Expected 2 zones per interface\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;zoneOwner = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e][\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;interfaceOwner = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e][\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;zoneNeighbour = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e][\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;interfaceNeighbour = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e][\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][interface].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ezones\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = {zoneOwner, zoneNeighbour};\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][interface].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eownerIndex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zoneOwner][interfaceOwner];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][interface].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eneighbourIndex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e =\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_interfaceElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zoneNeighbour][interfaceNeighbour];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":20,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="for (int interface = 0; interface &lt; numberOfInterfaces; ++interface) {
  if (cg_conn_info(_fileIndex, 1, zone + 1, interface + 1, interfaceName, &amp;location, &amp;connectType, &amp;pointSet,
    &amp;numberOfPoints, donorName, &amp;donorZoneType, &amp;donorPointSet, &amp;donorDataType, &amp;numberOfDonorCells))
    cg_error_exit();
    
  assert(donorZoneType == CGNS_ENUMV(Unstructured) &amp;&amp; &quot;Expected unstructured interface&quot;);

  auto zones = interfaceNameToZone[interfaceName];
  assert(zones.size() == 2 &amp;&amp; &quot;Expected 2 zones per interface&quot;);

  const auto &amp;zoneOwner = zones[0][0];
  const auto &amp;interfaceOwner = zones[0][1];
  const auto &amp;zoneNeighbour = zones[1][0];
  const auto &amp;interfaceNeighbour = zones[1][1];

  _interfaceConnectivity[zone][interface].zones = {zoneOwner, zoneNeighbour};
  _interfaceConnectivity[zone][interface].ownerIndex = _interfaceElementConnectivity[zoneOwner][interfaceOwner];
  _interfaceConnectivity[zone][interface].neighbourIndex =
    _interfaceElementConnectivity[zoneNeighbour][interfaceNeighbour];
}" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> interface = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; interface &lt; numberOfInterfaces; ++interface) {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_conn_info</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, interface + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, interfaceName, &amp;location, &amp;connectType, &amp;pointSet,</span></span>
<span class="line"><span style="color: #D4D4D4">    &amp;numberOfPoints, donorName, &amp;donorZoneType, &amp;donorPointSet, &amp;donorDataType, &amp;numberOfDonorCells))</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">assert</span><span style="color: #D4D4D4">(donorZoneType == </span><span style="color: #DCDCAA">CGNS_ENUMV</span><span style="color: #D4D4D4">(Unstructured) &amp;&amp; </span><span style="color: #CE9178">&quot;Expected unstructured interface&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> zones = </span><span style="color: #9CDCFE">interfaceNameToZone</span><span style="color: #D4D4D4">[interfaceName];</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">assert</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">size</span><span style="color: #D4D4D4">() == </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> &amp;&amp; </span><span style="color: #CE9178">&quot;Expected 2 zones per interface&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;zoneOwner = </span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">][</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">];</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;interfaceOwner = </span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">][</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">];</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;zoneNeighbour = </span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">][</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">];</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &amp;interfaceNeighbour = </span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">][</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">_interfaceConnectivity</span><span style="color: #D4D4D4">[zone][interface].</span><span style="color: #9CDCFE">zones</span><span style="color: #D4D4D4"> = {zoneOwner, zoneNeighbour};</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">_interfaceConnectivity</span><span style="color: #D4D4D4">[zone][interface].</span><span style="color: #9CDCFE">ownerIndex</span><span style="color: #D4D4D4"> = </span><span style="color: #9CDCFE">_interfaceElementConnectivity</span><span style="color: #D4D4D4">[zoneOwner][interfaceOwner];</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">_interfaceConnectivity</span><span style="color: #D4D4D4">[zone][interface].</span><span style="color: #9CDCFE">neighbourIndex</span><span style="color: #D4D4D4"> =</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">_interfaceElementConnectivity</span><span style="color: #D4D4D4">[zoneNeighbour][interfaceNeighbour];</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>We loop over all interfaces and then read the information for these interfaces on line 2, as we have done previously when creating the lookup table based on the interface name. Now, we use the <code>donorZoneType</code>, or the neighbouring zone type, to check that the interface data is written as an unstructured grid. It is possible to connect unstructured and structured grids at an interface (and certainly our grid arrangement would allow for that in our small test grid), but this would require a different data structure, essentially a combination of the structured and unstructured mesh reading class. While it is possible, it is uncommon for CFD solvers to do this.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Based on the interface name, we retrieve the owner and neighbour zone and interface indices on line 8 from the lookup table we created earlier. Now we check that we do have indeed only 2 entries for each side of the interface, otherwise it would be undefined. We then go ahead and create some more telling variable names on lines 11-14 and all that's left is to write all available information into our interface connectivity information array.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Line 16 stores both the owner and neighbouring zone index and for both the owner (line 17) and its neighbour (line 18), we store the element connectivity information. We use the zone and interface index from the lookup table, as well as the element connectivity data that we read in the previous section. With all of that information written to the array, we have finished creating the interface information and can move on to read boundaries, the last remaining step.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-reading-boundary-conditions-from-a-cgns-file">Reading boundary conditions from a CGNS file</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The boundary condition reading is pretty similar to the structured mesh reading. I'd argue it is actually simpler in this case, as we have already read the boundary element connectivity data. For the structured grid, we received the first and last index as a point range and then had to construct the indices for <code>i</code> and <code>j</code>. The code is given below with explanations to follow.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"void ReadUnstructuredMesh::readBoundaries() {\n  // go through all zones and check which boundary conditions are stored under each zone\n  _boundaryConditions.resize(_numberOfZones);\n  for (int zone = 0; zone \u0026lt; _numberOfZones; ++zone) {\n    int numberOfBoundaries;\n    if (cg_nbocos(_fileIndex, 1, zone + 1, \u0026amp;numberOfBoundaries)) cg_error_exit();\n    _boundaryConditions[zone].resize(numberOfBoundaries);\n\n    // for each zone, go through all boundaries stored in this zone and store the boundary information\n    for (int boundary = 0; boundary \u0026lt; numberOfBoundaries; ++boundary) {\n      char boundaryName[128]; int normalIndex, numberOfDataset; PointSetType_t pointSetType;\n      cgsize_t numberOfPointsInBoundary, normalListSize; DataType_t normalDataType; BCType_t boundaryType;\n\n      if (cg_boco_info(_fileIndex, 1, zone + 1, boundary + 1, boundaryName, \u0026amp;boundaryType, \u0026amp;pointSetType,\n        \u0026amp;numberOfPointsInBoundary, \u0026amp;normalIndex, \u0026amp;normalListSize, \u0026amp;normalDataType, \u0026amp;numberOfDataset)) cg_error_exit();\n\n      assert(pointSetType == CGNS_ENUMV(PointRange) \u0026amp;\u0026amp;\n        \u0022Expected to read a start and end location for boundary conditions only\u0022);\n\n      _boundaryConditions[zone][boundary].indices = _boundaryElementConnectivity[zone][boundary];\n\n      // Writing the boundary name and type to the boundary structure. We need to check if we need to get this\n      // information from a family node or if we can read this directly from the boundary node.\n      if (boundaryType == CGNS_ENUMV(FamilySpecified)) {\n        // go to the current boundary node within the ZoneBC_t node, which must be present for each zone\n        if (cg_goto(_fileIndex, 1, \u0022Zone_t\u0022, zone + 1, \u0022ZoneBC_t\u0022, 1, \u0022BC_t\u0022, boundary + 1, \u0022end\u0022)) cg_error_exit();\n      \n        // once we have navigated to the boundary node, read the family name, this will be checked against the family\n        // names we read previously. From the family name, we can get the boundary condition type through the map we set\n        // up earlier.\n        char familyName[128];\n        if (cg_famname_read(familyName)) cg_error_exit();\n\n        // store boundary condition name and type in the boundary condition structure\n        _boundaryConditions[zone][boundary].boundaryName = familyName;\n        _boundaryConditions[zone][boundary].boundaryType = getBoundaryConditionID(_boundaryConditionMap[familyName]);\n      } else {\n        // store boundary condition name and type in the boundary condition structure\n        _boundaryConditions[zone][boundary].boundaryName = boundaryName;\n        _boundaryConditions[zone][boundary].boundaryType = getBoundaryConditionID(boundaryType);\n      }\n    }\n  }\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eReadUnstructuredMesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ereadBoundaries\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // go through all zones and check which boundary conditions are stored under each zone\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryConditions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_numberOfZones);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e zone = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; zone \u0026lt; _numberOfZones; ++zone) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfBoundaries;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_nbocos\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u0026amp;numberOfBoundaries)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryConditions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone].\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfBoundaries);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // for each zone, go through all boundaries stored in this zone and store the boundary information\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e boundary = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; boundary \u0026lt; numberOfBoundaries; ++boundary) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundaryName\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e128\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e]; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e normalIndex, numberOfDataset; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ePointSetType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e pointSetType;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecgsize_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfPointsInBoundary, normalListSize; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eDataType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e normalDataType; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eBCType_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e boundaryType;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_boco_info\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, boundary + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, boundaryName, \u0026amp;boundaryType, \u0026amp;pointSetType,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u0026amp;numberOfPointsInBoundary, \u0026amp;normalIndex, \u0026amp;normalListSize, \u0026amp;normalDataType, \u0026amp;numberOfDataset)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eassert\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(pointSetType == \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eCGNS_ENUMV\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(PointRange) \u0026amp;\u0026amp;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Expected to read a start and end location for boundary conditions only\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryConditions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][boundary].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eindices\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryElementConnectivity\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][boundary];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // Writing the boundary name and type to the boundary structure. We need to check if we need to get this\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e      // information from a family node or if we can read this directly from the boundary node.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (boundaryType == \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eCGNS_ENUMV\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(FamilySpecified)) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // go to the current boundary node within the ZoneBC_t node, which must be present for each zone\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_goto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(_fileIndex, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Zone_t\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, zone + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;ZoneBC_t\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;BC_t\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, boundary + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;end\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // once we have navigated to the boundary node, read the family name, this will be checked against the family\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // names we read previously. From the family name, we can get the boundary condition type through the map we set\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // up earlier.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efamilyName\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e128\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e];\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_famname_read\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(familyName)) \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecg_error_exit\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // store boundary condition name and type in the boundary condition structure\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryConditions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][boundary].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundaryName\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = familyName;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryConditions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][boundary].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundaryType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetBoundaryConditionID\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryConditionMap\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[familyName]);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      } \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eelse\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // store boundary condition name and type in the boundary condition structure\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryConditions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][boundary].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundaryName\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = boundaryName;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e_boundaryConditions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[zone][boundary].\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eboundaryType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003egetBoundaryConditionID\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(boundaryType);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"highestLineNumber":44,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" data-code="void ReadUnstructuredMesh::readBoundaries() {
  // go through all zones and check which boundary conditions are stored under each zone
  _boundaryConditions.resize(_numberOfZones);
  for (int zone = 0; zone &lt; _numberOfZones; ++zone) {
    int numberOfBoundaries;
    if (cg_nbocos(_fileIndex, 1, zone + 1, &amp;numberOfBoundaries)) cg_error_exit();
    _boundaryConditions[zone].resize(numberOfBoundaries);

    // for each zone, go through all boundaries stored in this zone and store the boundary information
    for (int boundary = 0; boundary &lt; numberOfBoundaries; ++boundary) {
      char boundaryName[128]; int normalIndex, numberOfDataset; PointSetType_t pointSetType;
      cgsize_t numberOfPointsInBoundary, normalListSize; DataType_t normalDataType; BCType_t boundaryType;

      if (cg_boco_info(_fileIndex, 1, zone + 1, boundary + 1, boundaryName, &amp;boundaryType, &amp;pointSetType,
        &amp;numberOfPointsInBoundary, &amp;normalIndex, &amp;normalListSize, &amp;normalDataType, &amp;numberOfDataset)) cg_error_exit();

      assert(pointSetType == CGNS_ENUMV(PointRange) &amp;&amp;
        &quot;Expected to read a start and end location for boundary conditions only&quot;);

      _boundaryConditions[zone][boundary].indices = _boundaryElementConnectivity[zone][boundary];

      // Writing the boundary name and type to the boundary structure. We need to check if we need to get this
      // information from a family node or if we can read this directly from the boundary node.
      if (boundaryType == CGNS_ENUMV(FamilySpecified)) {
        // go to the current boundary node within the ZoneBC_t node, which must be present for each zone
        if (cg_goto(_fileIndex, 1, &quot;Zone_t&quot;, zone + 1, &quot;ZoneBC_t&quot;, 1, &quot;BC_t&quot;, boundary + 1, &quot;end&quot;)) cg_error_exit();
      
        // once we have navigated to the boundary node, read the family name, this will be checked against the family
        // names we read previously. From the family name, we can get the boundary condition type through the map we set
        // up earlier.
        char familyName[128];
        if (cg_famname_read(familyName)) cg_error_exit();

        // store boundary condition name and type in the boundary condition structure
        _boundaryConditions[zone][boundary].boundaryName = familyName;
        _boundaryConditions[zone][boundary].boundaryType = getBoundaryConditionID(_boundaryConditionMap[familyName]);
      } else {
        // store boundary condition name and type in the boundary condition structure
        _boundaryConditions[zone][boundary].boundaryName = boundaryName;
        _boundaryConditions[zone][boundary].boundaryType = getBoundaryConditionID(boundaryType);
      }
    }
  }
}" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">ReadUnstructuredMesh</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">readBoundaries</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #6A9955">  // go through all zones and check which boundary conditions are stored under each zone</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">_boundaryConditions</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(_numberOfZones);</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> zone = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; zone &lt; _numberOfZones; ++zone) {</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfBoundaries;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_nbocos</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, &amp;numberOfBoundaries)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">_boundaryConditions</span><span style="color: #D4D4D4">[zone].</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(numberOfBoundaries);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // for each zone, go through all boundaries stored in this zone and store the boundary information</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> boundary = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; boundary &lt; numberOfBoundaries; ++boundary) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #569CD6">char</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">boundaryName</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">128</span><span style="color: #D4D4D4">]; </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> normalIndex, numberOfDataset; </span><span style="color: #4EC9B0">PointSetType_t</span><span style="color: #D4D4D4"> pointSetType;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #4EC9B0">cgsize_t</span><span style="color: #D4D4D4"> numberOfPointsInBoundary, normalListSize; </span><span style="color: #4EC9B0">DataType_t</span><span style="color: #D4D4D4"> normalDataType; </span><span style="color: #4EC9B0">BCType_t</span><span style="color: #D4D4D4"> boundaryType;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_boco_info</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, boundary + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, boundaryName, &amp;boundaryType, &amp;pointSetType,</span></span>
<span class="line"><span style="color: #D4D4D4">        &amp;numberOfPointsInBoundary, &amp;normalIndex, &amp;normalListSize, &amp;normalDataType, &amp;numberOfDataset)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #DCDCAA">assert</span><span style="color: #D4D4D4">(pointSetType == </span><span style="color: #DCDCAA">CGNS_ENUMV</span><span style="color: #D4D4D4">(PointRange) &amp;&amp;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #CE9178">&quot;Expected to read a start and end location for boundary conditions only&quot;</span><span style="color: #D4D4D4">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">_boundaryConditions</span><span style="color: #D4D4D4">[zone][boundary].</span><span style="color: #9CDCFE">indices</span><span style="color: #D4D4D4"> = </span><span style="color: #9CDCFE">_boundaryElementConnectivity</span><span style="color: #D4D4D4">[zone][boundary];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">      // Writing the boundary name and type to the boundary structure. We need to check if we need to get this</span></span>
<span class="line"><span style="color: #6A9955">      // information from a family node or if we can read this directly from the boundary node.</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (boundaryType == </span><span style="color: #DCDCAA">CGNS_ENUMV</span><span style="color: #D4D4D4">(FamilySpecified)) {</span></span>
<span class="line"><span style="color: #6A9955">        // go to the current boundary node within the ZoneBC_t node, which must be present for each zone</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_goto</span><span style="color: #D4D4D4">(_fileIndex, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, </span><span style="color: #CE9178">&quot;Zone_t&quot;</span><span style="color: #D4D4D4">, zone + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, </span><span style="color: #CE9178">&quot;ZoneBC_t&quot;</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, </span><span style="color: #CE9178">&quot;BC_t&quot;</span><span style="color: #D4D4D4">, boundary + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, </span><span style="color: #CE9178">&quot;end&quot;</span><span style="color: #D4D4D4">)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">      </span></span>
<span class="line"><span style="color: #6A9955">        // once we have navigated to the boundary node, read the family name, this will be checked against the family</span></span>
<span class="line"><span style="color: #6A9955">        // names we read previously. From the family name, we can get the boundary condition type through the map we set</span></span>
<span class="line"><span style="color: #6A9955">        // up earlier.</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #569CD6">char</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">familyName</span><span style="color: #D4D4D4">[</span><span style="color: #B5CEA8">128</span><span style="color: #D4D4D4">];</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (</span><span style="color: #DCDCAA">cg_famname_read</span><span style="color: #D4D4D4">(familyName)) </span><span style="color: #DCDCAA">cg_error_exit</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">        // store boundary condition name and type in the boundary condition structure</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">_boundaryConditions</span><span style="color: #D4D4D4">[zone][boundary].</span><span style="color: #9CDCFE">boundaryName</span><span style="color: #D4D4D4"> = familyName;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">_boundaryConditions</span><span style="color: #D4D4D4">[zone][boundary].</span><span style="color: #9CDCFE">boundaryType</span><span style="color: #D4D4D4"> = </span><span style="color: #DCDCAA">getBoundaryConditionID</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">_boundaryConditionMap</span><span style="color: #D4D4D4">[familyName]);</span></span>
<span class="line"><span style="color: #D4D4D4">      } </span><span style="color: #C586C0">else</span><span style="color: #D4D4D4"> {</span></span>
<span class="line"><span style="color: #6A9955">        // store boundary condition name and type in the boundary condition structure</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">_boundaryConditions</span><span style="color: #D4D4D4">[zone][boundary].</span><span style="color: #9CDCFE">boundaryName</span><span style="color: #D4D4D4"> = boundaryName;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">_boundaryConditions</span><span style="color: #D4D4D4">[zone][boundary].</span><span style="color: #9CDCFE">boundaryType</span><span style="color: #D4D4D4"> = </span><span style="color: #DCDCAA">getBoundaryConditionID</span><span style="color: #D4D4D4">(boundaryType);</span></span>
<span class="line"><span style="color: #D4D4D4">      }</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">  }</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>After allocating memory for all zones and then looping over them on lines 3-4, we query the number of boundary conditions on line 6 and then allocate memory for all boundary conditions on the following line. Between lines 10-42, we loop over all boundaries to read their type, name, and write all of this information, together with the element connectivity data read before into our boundary condition array.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On line 14, we receive the boundary name and its type. We check on lines 17-18 that the points received by the CGNS call is of type <code>PointRange</code>, meaning we should only receive the start and end location. This is pretty inconsequential, though, as we are not actually proceeding to read this information. If you encounter issues at this point, you should be able to delete these two lines without consequence. What we do instead is to store the boundary element connectivity data that we already read on line 20. Our boundary condition array now has all the elements available on that boundary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We check on line 24 whether the boundary type is set to <code>FamilySpecified</code> or not. If it is, then we need to go ahead and read the boundary name and type from the family conditions that we created <a href="https://cfd.university/learn/the-complete-guide-to-structured-and-unstructured-mesh-reading-using-cgns/how-to-set-up-a-simple-cgns-based-mesh-reading-library" target="_blank" rel="noopener" title="">in the base class</a>. The way to retrieve the information requires pointing the CGNS file to the family node, which we do on line 26 with the <code>cg_goto()</code> function (if we think of nodes in a CGNS file as folders on a hard drive, then <code>cg_goto()</code> is equivalent to changing directories).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Pointing at the right node, we can read the family name on line 32 which we use to look up the information we need from our family lookup table (again, we created that in the base class, see the above-linked article for a description). First, we store the family name, which now is the name of the boundary condition, on line 35 and then proceed to look up the boundary condition stored in the boundary lookup table on line 36 and store its result in our boundary condition array.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If the boundary condition that we read earlier on line 14 is not of type <code>FamilySpecified</code>, then we have read the actual type and do not need to retrieve this information from a family node. In this case, we can directly store the boundary name and its type that we read on line 14 in our boundary condition array, which we do on lines 39-40.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you compare this implementation with that of the <a href="https://cfd.university/learn/the-complete-guide-to-structured-and-unstructured-mesh-reading-using-cgns/how-to-read-a-multi-block-structured-mesh-from-a-cgns-file" target="_blank" rel="noopener" title="">boundary condition reading on the structured mesh</a>, then you will that there are quite a few parallels as discussed above. I went through this description a bit faster as we have already covered most of the functionality in the aforementioned article. If you feel you need a bit more explanation, have a look at that article as well for additional explanations.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-summary">Summary</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>If you made it up to this point, and you read the previous 2 articles, you should have a firm grasp on how to read structured and unstructured grids. I have tried to be as general as possible (i.e. support multi-block/zone mesh reading for both structured and unstructured grids) and chances are you will be able to read pretty much any grid with this implementation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>CGNS is a complex library, allowing you to write the same information in many different ways. Most paths are standardised but some are left to the developers implementing the CGNS routines into their software. I have been using grids generated by Pointwise and thus you should be able to proceed with Pointwise-generated grids.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you use a different software, there should be enough fail-fast assert statements in place to point you in the right direction. Check which assert is failing and then read through the code to see which modifications you have to do. If there are modifications that I was able to foresee, I mentioned those in the text, so check the writeup here again and see if the solution is not already presented here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Even though we have limited ourselves to 2D grids only, going to 3D is not that much more complicated. The difference is mainly in the memory allocation and looping over data. If you understand the entire code up until this point, you should be able to extend this to 3D.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This finalised the development of this library. What is left to do for us is to turn this code into an actual library, i.e. compile it as a static or dynamic library, and, we hinted at that in earlier articles as well, create some form of tests that we can run to ensure the mesh reading was successful. This is what we deal with in the next article before closing this series.</p>
<!-- /wp:paragraph -->