<!-- How to implement boundary conditions in CFD -->
<!-- https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-implement-boundary-conditions-in-cfd/ -->

<!-- wp:paragraph -->
<p>In this series thus far, we have looked at the governing equations of CFD, how to discretise them and what their character is. We have looked at different numerical schemes and how they influence various properties, such as accuracy. Eventually, we need to talk about boundary conditions, as every simulation will have to truncate the simulation domain somewhere.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, in this article, we take a deep dive into the (fascinating?!) world of boundary conditions, and I promise you, you might think they are easy and straightforward (I've been there), but they are not. The devil is in the detail, and by the end of this article, you will have an appreciation for what common issues, solved and unsolved, exist when we have to deal with boundary conditions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the process, we will see that there really are only three different types of boundary conditions, and if you understand them, you can model any kind of boundary. In most cases, we don't even need the third, so just knowing two, really, is all you need. With these two (or three) fundamental types of boundary conditions, we can derive boundary conditions like walls, symmetry planes, inlets, outlets, and so on, which are just different combinations of these two fundamental types of boundary conditions for the flow variables we are solving for.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I can't make boundary conditions look sexy, but I can tell you about all of the dead bodies it has been hiding and its troubled past (and future), if that is something you are interested in, get the popcorn, we have a journey in front of us!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading">In this series</h2>
<!-- /wp:heading -->

<!-- wp:shortcode -->
[custom_category_posts_list category_slug="10-key-concepts-everyone-must-understand-in-cfd"]
<!-- /wp:shortcode -->

<!-- wp:heading -->
<h2 class="wp-block-heading">In this article</h2>
<!-- /wp:heading -->

<!-- wp:aioseo/table-of-contents {"mode":"standalone","headings":[{"content":"Introduction","level":2,"anchor":"aioseo-introduction","blockClientId":"f7c39d23-da7b-496e-9368-10c23a81d12c","hidden":false,"editedContent":"","editedOrder":1,"headings":[{"content":"The fundamental problem with boundary conditions","level":3,"anchor":"aioseo-the-fundamental-problem-with-boundary-conditions","blockClientId":"170e92cd-2ead-4167-bc19-062cf4866e7f","hidden":false,"editedContent":"","editedOrder":2,"headings":[]}]},{"content":"Three fundamental boundary conditions to rule them all","level":2,"anchor":"aioseo-different-types-of-boundary-conditions","blockClientId":"c4ea0a6e-8fea-47b7-864a-aef9bbaf18a3","hidden":false,"editedContent":"","editedOrder":3,"headings":[{"content":"Dirichlet-type boundary conditions","level":3,"anchor":"aioseo-dirichlet-type-boundary-conditions","blockClientId":"04789c1a-7b00-42e5-9923-3652bf4c0e84","hidden":false,"editedContent":"","editedOrder":4,"headings":[]},{"content":"Neumann-type boundary conditions","level":3,"anchor":"aioseo-neumann-type-boundary-conditions","blockClientId":"3c4b6b56-4850-4ef6-ae48-13066e9f5b6c","hidden":false,"editedContent":"","editedOrder":5,"headings":[]},{"content":"Robin-type boundary conditions","level":3,"anchor":"aioseo-robin-type-boundary-conditions","blockClientId":"56d9de69-eb14-4010-ab2d-a8f0d297f076","hidden":false,"editedContent":"","editedOrder":6,"headings":[]}]},{"content":"The two schools of thought on implementing boundary conditions","level":2,"anchor":"aioseo-two-schools-of-thought-on-implementing-boundary-conditions","blockClientId":"8551aed1-4314-414e-94a1-0d8b17fc7d7c","hidden":false,"editedContent":"","editedOrder":7,"headings":[{"content":"Implementing boundary conditions without mesh modifications","level":3,"anchor":"aioseo-strict-imposition-of-boundary-conditions","blockClientId":"d08df349-bae8-4413-a9bc-6ea64735f44a","hidden":false,"editedContent":"","editedOrder":8,"headings":[]},{"content":"Implementing boundary conditions using the ghost cell approach","level":3,"anchor":"aioseo-implementing-boundary-conditions-using-the-ghost-cell-approach","blockClientId":"1f43cecb-e302-4d10-8e7f-8931b12e1a5d","hidden":false,"editedContent":"","editedOrder":9,"headings":[]}]},{"content":"How to implement boundary conditions for implicit time integration","level":2,"anchor":"aioseo-how-to-implement-boundary-conditions-for-implicit-time-integration","blockClientId":"18d3107f-f06c-4b83-acfa-1e81045ae19a","hidden":false,"editedContent":"","editedOrder":10,"headings":[{"content":"Implicit time integration without mesh modifications","level":3,"anchor":"aioseo-implicit-time-integration-without-mesh-modifications","blockClientId":"9a5ad6d2-7c4d-47df-9179-4d18a9fd155b","hidden":false,"editedContent":"","editedOrder":11,"headings":[{"content":"Dirichlet boundary conditions","level":4,"anchor":"aioseo-dirichlet-boundary-conditions","blockClientId":"137b534b-eab6-4fad-8f66-a8152837d5f4","hidden":false,"editedContent":"","editedOrder":12,"headings":[]},{"content":"Neumann boundary conditions","level":4,"anchor":"aioseo-neumann-boundary-conditions","blockClientId":"6888722d-e183-4620-950a-a940829f3791","hidden":false,"editedContent":"","editedOrder":13,"headings":[]}]},{"content":"Implicit time integration with the ghost cell approach","level":3,"anchor":"aioseo-implicit-time-integration-with-the-ghost-cell-approach","blockClientId":"18797d13-cd23-44ce-b6b1-eb1a0512e4c9","hidden":false,"editedContent":"","editedOrder":14,"headings":[]}]},{"content":"Derived boundary conditions","level":2,"anchor":"aioseo-derived-boundary-conditions","blockClientId":"d2d0231f-9c98-464f-917a-3b1e2fabf223","hidden":false,"editedContent":"","editedOrder":15,"headings":[{"content":"Solid boundary conditions","level":3,"anchor":"aioseo-solid-boundary-conditions","blockClientId":"3f613194-1bef-4643-9653-91c7fa638cf2","hidden":false,"editedContent":"","editedOrder":16,"headings":[{"content":"Wall","level":4,"anchor":"aioseo-wall","blockClientId":"6dcc70bd-7898-4d47-a562-15b8b1a63858","hidden":false,"editedContent":"","editedOrder":17,"headings":[]},{"content":"Symmetry","level":4,"anchor":"aioseo-symmetry","blockClientId":"35f3a07d-30b6-4208-b8a4-57ba0b2a34b7","hidden":false,"editedContent":"","editedOrder":18,"headings":[]}]},{"content":"Open boundary conditions","level":3,"anchor":"aioseo-open-boundary-conditions","blockClientId":"f7bc3c06-38d7-406d-b132-a146d0e38ad7","hidden":false,"editedContent":"","editedOrder":19,"headings":[{"content":"Periodic or cyclic","level":4,"anchor":"aioseo-periodic","blockClientId":"691932e7-27bd-4c44-85dc-8aad793073d6","hidden":false,"editedContent":"","editedOrder":20,"headings":[]},{"content":"Differences in open boundary conditions based on the Mach number","level":4,"anchor":"aioseo-the-importance-of-characteristics-on-open-boundary-conditions","blockClientId":"19b470fe-429d-4b07-bc46-30a1ecb6b507","hidden":false,"editedContent":"","editedOrder":21,"headings":[]},{"content":"Freestream or farfield","level":4,"anchor":"aioseo-freestream-or-farfield","blockClientId":"f7926529-12dd-4857-916a-097fd66ec4ea","hidden":false,"editedContent":"","editedOrder":22,"headings":[]},{"content":"Pressure or velocity inlet","level":4,"anchor":"aioseo-inlet","blockClientId":"42ba8150-9b25-4986-bee2-0b7941f30cd3","hidden":false,"editedContent":"","editedOrder":23,"headings":[]},{"content":"Pressure or velocity outlet","level":4,"anchor":"aioseo-outlet","blockClientId":"4a7e2743-9343-47aa-b5a5-9372c9f157be","hidden":false,"editedContent":"","editedOrder":24,"headings":[]},{"content":"Advective outlet","level":4,"anchor":"aioseo-advective-outlet","blockClientId":"294ca6e4-f637-4388-88bc-84747100871d","hidden":false,"editedContent":"","editedOrder":25,"headings":[]},{"content":"Mass-based or volume-based inlets and outlets","level":4,"anchor":"aioseo-mass-flow","blockClientId":"e0f6fad5-6df8-4650-a3d3-c7f153496839","hidden":false,"editedContent":"","editedOrder":26,"headings":[]}]}]},{"content":"Summary","level":2,"anchor":"aioseo-summary","blockClientId":"4b6242b3-209d-4bbc-832b-70f3c8cda2f7","hidden":false,"editedContent":"","editedOrder":27,"headings":[]}]} -->
<div class="wp-block-aioseo-table-of-contents"><ul><li><a href="#aioseo-introduction">Introduction</a><ul><li><a href="#aioseo-the-fundamental-problem-with-boundary-conditions">The fundamental problem with boundary conditions</a></li></ul></li><li><a href="#aioseo-different-types-of-boundary-conditions">Three fundamental boundary conditions to rule them all</a><ul><li><a href="#aioseo-dirichlet-type-boundary-conditions">Dirichlet-type boundary conditions</a></li><li><a href="#aioseo-neumann-type-boundary-conditions">Neumann-type boundary conditions</a></li><li><a href="#aioseo-robin-type-boundary-conditions">Robin-type boundary conditions</a></li></ul></li><li><a href="#aioseo-two-schools-of-thought-on-implementing-boundary-conditions">The two schools of thought on implementing boundary conditions</a><ul><li><a href="#aioseo-strict-imposition-of-boundary-conditions">Implementing boundary conditions without mesh modifications</a></li><li><a href="#aioseo-implementing-boundary-conditions-using-the-ghost-cell-approach">Implementing boundary conditions using the ghost cell approach</a></li></ul></li><li><a href="#aioseo-how-to-implement-boundary-conditions-for-implicit-time-integration">How to implement boundary conditions for implicit time integration</a><ul><li><a href="#aioseo-implicit-time-integration-without-mesh-modifications">Implicit time integration without mesh modifications</a><ul><li><a href="#aioseo-dirichlet-boundary-conditions">Dirichlet boundary conditions</a></li><li><a href="#aioseo-neumann-boundary-conditions">Neumann boundary conditions</a></li></ul></li><li><a href="#aioseo-implicit-time-integration-with-the-ghost-cell-approach">Implicit time integration with the ghost cell approach</a></li></ul></li><li><a href="#aioseo-derived-boundary-conditions">Derived boundary conditions</a><ul><li><a href="#aioseo-solid-boundary-conditions">Solid boundary conditions</a><ul><li><a href="#aioseo-wall">Wall</a></li><li><a href="#aioseo-symmetry">Symmetry</a></li></ul></li><li><a href="#aioseo-open-boundary-conditions">Open boundary conditions</a><ul><li><a href="#aioseo-periodic">Periodic or cyclic</a></li><li><a href="#aioseo-the-importance-of-characteristics-on-open-boundary-conditions">Differences in open boundary conditions based on the Mach number</a></li><li><a href="#aioseo-freestream-or-farfield">Freestream or farfield</a></li><li><a href="#aioseo-inlet">Pressure or velocity inlet</a></li><li><a href="#aioseo-outlet">Pressure or velocity outlet</a></li><li><a href="#aioseo-advective-outlet">Advective outlet</a></li><li><a href="#aioseo-mass-flow">Mass-based or volume-based inlets and outlets</a></li></ul></li></ul></li><li><a href="#aioseo-summary">Summary</a></li></ul></div>
<!-- /wp:aioseo/table-of-contents -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-introduction">Introduction</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>When you performed your first CFD simulations, you probably simulated some kind of laminar or even turbulent flow using a commercial or open-source solver. You selected some boundary conditions, perhaps a combination of inlets and outlets, and sprinkled in some solid walls here and there. You solved this simulation, got results, and presumably, you were very happy with the results. If this describes you, then you would be forgiven for thinking that imposing boundary conditions is easy.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, a lot happens behind the scenes, which is abstracted away from you. Unless you deal with OpenFOAM (where the developers really want you to think long and hard about your boundary conditions, and, by extension, about your life choices (I could have used Fluent/StarCCM+ instead ...)), the end result you see is a combination of violated physics and some undisclosed black magic. Let's face it: we probably all go to hell for the way we treat boundaries. We don't want to admit it, but we know it to be true in our hearts. Or is it just me?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When I applied for my first PhD position on Large Eddy Simulations (LES) and Direct Numerical Simulations (DNS), I was invited for an interview, and I got into a heated argument with one of the post-docs. He was working in the wind tunnel (and, as you are probably aware, there is a&nbsp;healthy&nbsp;portion of distrust and hatred between computational and experimental fluid dynamicists!). So naturally, I didn't take his opinions on CFD too seriously. He insisted that boundary conditions are one of the hardest things to get right, whereas I was of the opinion that they are easy.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I got offered the PhD position (to everyone's surprise, including mine), and later found myself trying to implement boundary conditions into my Cartesian grid-based solver in 2D for steady, laminar flows (we experts call this <em>piss-easy</em>, yes, this is scientific terminology ...). To my surprise, I was struggling, and while I was trying to resolve my boundary condition issues after spending months going through the literature and looking for answers, I remembered the discussion I had with the post-doc. Could he have been right?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Later, I was working on a project using Large-Eddy Simulations. I also supervised a PhD student at the time working on high-resolution schemes on unstructured grids for external aeronautical applications. We both were suffering from the boundary conditions. My inlet boundary conditions could only be described as borderline illegal, while my PhD student did confess to me, after 9 months of troubleshooting, that he just copied and pasted boundary conditions from a different case. After I made some modifications, his case worked, but now he is going to hell, too (I guess).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Boundary conditions are hard. If you believe they aren't, then you either have never implemented them yourself or never have done any simulations where the adverse effects of boundary conditions become an issue. If you want to challenge yourself, go and set up a channel flow with Large Eddy Simulations. But no cheating; periodic boundary conditions aren't allowed. You will realise that there are as many different boundary conditions you can impose at the inlet as there are probably RANS turbulence models available, and some are better than others but not necessarily more correct.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In 1991, Sani and Gresho (who would also later publish their book on <a href="https://www.wiley.com/en-gb/Incompressible+Flow+and+the+Finite+Element+Method%2C+Volume+1%3A+Advection-Diffusion+and+Isothermal+Laminar+Flow-p-9780471492498" target="_blank" rel="noopener" title="">finite elements in CFD applications</a>) held a mini-symposium on open questions and challenges for open boundary conditions during the <a href="https://searchworks.stanford.edu/view/719147" target="_blank" rel="noopener" title="">seventh international conference on numerical methods for laminar and turbulent flow</a>. Three years later, they would publish a bleak review of the outcome of this mini symposium.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The test cases they discussed were classical test cases such as the steady-state flow over a backward-facing step (with and without heating), the unsteady flow past a circular cylinder, and the steady-state flow through a channel. But these cases came with a twist; test cases needed to be simulated with boundary conditions imposed in two locations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The first location was far downstream, i.e. far enough away so that they would not influence the simulation. However, the second location was in a region where the flow was still developing. For example, for the circular cylinder case, the boundaries were placed as close as four diameters away from the cylinder. The von Karman vortex shedding is still in development in this region.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The participants presented results for different outlet boundary conditions, and in their 1994 review, Sani and Gresho summarised the mini-symposium and its outcome as:</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><!-- wp:paragraph -->
<p>It has been an exercise in frustration and we are not thrilled with the results obtained</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/fld.1650181006" target="_blank" rel="noopener" title="">Sani and Gresho, 1994</a></p>
<!-- /wp:paragraph --></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>You would think that 30+ years later, we would have solved all of these issues. We haven't. Sure, we have made some advances in specific areas, such as inlet boundary conditions for scale-resolving turbulent flows, but we are still struggling with very fundamental problems. If you have ever worked with Fluent, for example, then you might have encountered reverse flow at the outlet. Once that happens, your convergence is affected, so the developers at Fluent have implemented a fix.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What's that fix? Well, if you encounter reverse flow on a specific cell at the outlet, Fluent will temporarily turn that cell into a wall, preventing flow from entering. Genius, right? Now, you tell me if this is a true reflection of the physics that is going on or a quick and dirty fix we have come to accept because we haven't made any advances in the past 30 years.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-the-fundamental-problem-with-boundary-conditions">The fundamental problem with boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Before we now go into deep philosophical discussions on boundary conditions, let's address the issue at hand. Why are they so difficult? Why can't we make advances in this field?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The short and simple answer is: because boundary conditions don't exist in real life, at least not all!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To see that this is true, let us look first at boundary conditions that do exist. These are solid boundaries, i.e. walls. In a computational sense, nothing can penetrate a solid boundary, i.e. fluid can't go through a wall (unless we impose some form of porosity, which I am ignoring in this example). In real life, we do have physical wall-type boundaries as well. The cup I had my tea in this morning (Madam Grey, two sugars, and a flood of milk, apparently called a <a href="https://en.wikipedia.org/wiki/Builder's_tea" target="_blank" rel="noopener" title="">builder's brew</a> ...) effectively held the fluid in one place. There was no dripping or loss of fluid.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you want to simulate the flow around an airfoil and also decide to run some wind tunnel experiments (of course, without telling your friends, you don't want to be seen hanging out with those experimental people!), then you can go into the test section and <a href="https://www.youtube.com/watch?v=yE8rkG9Dw4s" target="_blank" rel="noopener" title="">physically touch</a> the wing that is installed in the wind tunnel. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Solid boundaries can be found in real life and, thus, are easy to model. But what about open boundaries like inlets and outlets? Think about it for a second. Can you come up with an example of an inlet or an outlet in real life? You can? Well, think again. There are no such things as inlets and outlets or, in general, open boundaries in real life. Every system is connected to another system in some way.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you simulate the flow through a pipe, whatever you impose at the inlet has to come from somewhere, a part of the system that you have conveniently ignored to model in your simulation. Or go back to the example of the airfoil simulation. In the wind tunnel, whatever leaves the test section (i.e. what we would call an outlet in a CFD simulation) is recycled, straightened, and pressurised before it is returned through the wind tunnel to the test section (i.e. what we would call an inlet in a CFD simulation).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are no open boundaries in real life, and if you want to have a physically correct system, then you are only allowed to use solid walls as your boundary condition. Take the wind tunnel, for example. Instead of imposing a fixed inlet velocity, you could also model the entire wind tunnel, including the spinning rotor, which would drive the flow. This geometry would consist of only walls and thus be a valid physical representation. But as soon as you chop off parts of the system and <em>model</em> the effect of the rotor through an inlet, you have changed the original system.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For a steady state RANS simulation, this might be OK, but you will still have to impose boundary conditions for your RANS model. If you are solving this flow with the [katex]k-\omega[/katex] SST model, for example, you will need to impose boundary conditions at the inlet for the turbulent kinetic energy [katex]k[/katex] and the specific dissipation rate [katex]\omega[/katex]. Are you confident that you can impose correct values for these quantities? And is a uniform distribution of [katex]k[/katex] and [katex]\omega[/katex] across the inlet plane a good approximation or would you expect these quantities to be non-uniformly distributed?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Turbulent kinetic energy is created in boundary layers, so close to the walls, and where you have turbulent kinetic energy, you have dissipation. Thus, you probably have much more happening at the edges of your inlet, where your inlet intersects with a solid wall. OK, so how tall is the turbulent boundary layer at your inlet? After all, you have chopped off part of the system; if there was no inlet, then we would have some boundary layer at the wall. You need to know the size of the turbulent boundary layer in order to impose realistic values for [katex]k[/katex] and [katex]\omega[/katex] here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thankfully, the values of [katex]k[/katex] and [katex]\omega[/katex] are not very sensitive to changes, so you will still get fairly good results in most cases, even if you can't accurately describe these values at the inlet. This is one positive attribute of RANS models. But once you want to resolve more turbulence, rather than modelling it, i.e. we are talking about scale-resolving turbulence such as Detached-eddy Simulations (DES), Scale-adaptative Simulations (SAS), Large-eddy Simulations (LES), or god forbid, even Direct Numerical Simulations (DNS), then the above discussed issues become a real problem!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Because we are now resolving turbulence, we also need to resolve the boundary layer at our inlet. If we don't, well, then we are solving a different type of flow. So how do we get around this issue? Well, there are several solutions in the literature, all of which are an approximation, but none of them are correct.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The simplest approach is to give up before we even start, waive a white flag and pretend that there is no turbulence at the inlet. In this case, we set all turbulence to zero and only impose freestream conditions for velocity, pressure, and potentially temperature. This is the simplest approach and, in some cases, a good approximation. Wind tunnels are able to suck away unwanted boundary layers, so as long as we place our inlet at exactly the position where the boundary layer is sucked away and we develop a new boundary layer, we should be golden, right?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Perhaps, and thinking only about the velocity, this is likely a good approximation. But what about the pressure? We looked at <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-elliptic-flows" target="_blank" rel="noopener" title="">elliptic flows in an earlier article</a> within this series, and the pressure is, for the most part, governed by an elliptic behaviour. What that means is that a change in pressure in one point of the flow will instantly propagate throughout the domain. This is why your flow starts turning around an obstacle before it has even reached it. Look at the streamlines around an airfoil, as shown in the above-linked article, to see what I mean.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What this means for our simulation is that by placing an inlet somewhere, we restrict the propagation of pressure (waves) only in a direction away from the inlet. The pressure isn't allowed to go beyond the inlet, influence the velocity upstream of the inlet itself, and, as a result, change the velocity profile that would otherwise develop at the inlet. This may seem like a small thing, but always remember that the Navier-Stokes equations are non-linear. A small change can have large consequences. After all, turbulence is created by microscopic surface roughness (natural transition).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You can show (and I have) that removing an upstream portion of the flow and replacing this with an inlet with a defined velocity profile that was measured in an experiment will give you different results compared to just simulating the upstream portion of the domain. It is the pressure that plays a critical role here, and concentrating only on the velocity will result in inaccuracies.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Of course, if you are dealing with supersonic flows, your pressure is <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-hyperbolic-flows" target="_blank" rel="noopener" title="">hyperbolic</a>, meaning that it has a preferred direction of travel, unlike elliptic flows, where it is travelling in all directions, and so imposing an inlet here is easier. While you have gained simplicity at the inlet, you have shifted the problem to the numerical schemes, which now have to deal with strong non-linearities. We saw in the last article how to tackle those. Alas, not every flow is supersonic, so we are stuck with elliptic pressure-induced boundary issues.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Hopefully, this will set the scene for you. Boundary conditions aren't easy, but they are a necessary evil that we have to deal with in any simulation. In this article, I want to look at how boundary conditions are commonly imposed, and we will see that there are really just three fundamental types of boundary conditions, of which the third type is just a combination of the first two. So, if you understand these two fundamental boundary conditions, you know all there is about boundary conditions. The art is in finding a combination that works for your case that doesn't violate the laws of physics (good luck to you, my friend!)</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-different-types-of-boundary-conditions">Three fundamental boundary conditions to rule them all</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In this section, we will review the three fundamental types of boundary conditions that we can use in simulations. The first two types are the ones you will use in every simulation. When you use a CFD solver and you select a type for your boundary, for example, a wall, or an inlet, your solver will use that information and translate that back to the two fundamental types for all of the quantities that you are solving for, e.g. velocity, pressure, temperature, and any turbulent quantities.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To make our lives easier, let's introduce some notation that we will use to derive the three fundamental types of boundary conditions. The two figures below show the cell arrangement commonly found in the finite difference method (left side), where the variables are stored at the cell's vertices, and the cell arrangement commonly found in the finite volume method (right side), where the variables are stored at the cell's centroid.</p>
<!-- /wp:paragraph -->

<!-- wp:columns -->
<div class="wp-block-columns"><!-- wp:column -->
<div class="wp-block-column"><!-- wp:paragraph -->
<p><strong>Vertex-based boundary conditions (finite difference method)</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5144,"sizeSlug":"large","linkDestination":"none"} -->
<figure class="wp-block-image size-large"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/vertex_based_boundary_conditions-1024x819.png" alt="" class="wp-image-5144"/></figure>
<!-- /wp:image --></div>
<!-- /wp:column -->

<!-- wp:column -->
<div class="wp-block-column"><!-- wp:paragraph -->
<p><strong>Centroid-based boundary conditions (finite volume method)</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5143,"sizeSlug":"large","linkDestination":"none"} -->
<figure class="wp-block-image size-large"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/centroid_based_boundary_conditions-1024x915.png" alt="" class="wp-image-5143"/></figure>
<!-- /wp:image --></div>
<!-- /wp:column --></div>
<!-- /wp:columns -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-dirichlet-type-boundary-conditions">Dirichlet-type boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Dirichlet-type boundary conditions are those where we impose a value directly. For example, we can impose a velocity, say 10 m/s at an inlet, and then all velocity at the inlet will have this value. This means that we need to know the value we want to impose and that this value will be typically uniformly distributed across the boundary, though we can also implement a non-uniform distribution if we know how this distribution will look like. For example, we may know the velocity profile from experiments.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's see how this can be implemented for the two types of grids that we saw above. On the left, we have the typical vertex-based arrangement that we normally use for finite difference methods. If we concentrate on [katex]\phi_{i-1,j}[/katex], which simply refer to as [katex]\phi_B[/katex], i.e. the value of [katex]\phi[/katex] at the boundary, then we see that since this node is already located on the boundary, we can simply write</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{i,j-1}=\phi_B =\phi_{Dirichlet}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]\phi_{Dirichlet}[/katex] is the value we want to impose on the boundary, e.g. 10 m/s on an inlet, 0 m/s at a non-moving wall, etc. This is rather straightforward. But what about the case on the right side of the figure?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, the right side of the figure shows the typical cell arrangement for a finite volume discretisation. We can see that the node on the boundary is not the cell centroid, i.e. the location where we store our flow variables like velocity, pressure, temperature, etc., but rather [katex]\phi_{i-1/2,j}=\phi_B[/katex]. Again, we just pick one point on the boundary, but the discussion would be the same for any of the other boundary points. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's review the finite volume discretisation again. In my article on <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-discretise-the-navier-stokes-equations/" target="_blank" rel="noopener" title="">how to discretise the Navier-Stokes</a> equations, we looked at how to derive first-order and second-order derivatives. For the first-order spatial derivatives (i.e. in space), we obtained this approximation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a\int_V\frac{\partial \phi}{\partial x}\mathrm{d}V=a\int_An\cdot\phi\,\mathrm{d}A\approx a\sum_{i=1}^{n_{faces}}n_f\cdot \phi_i A_i</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]a[/katex] is some coefficient, for example, the linearised velocity in the non-linear convective term. We go from a volume integral to a surface integral using the Gauss or divergence theorem, which requires us to integrate over all cell faces. In the finite volume method, we approximate that integration by a summation, where we now have to the face normal vector [katex]n_f[/katex], as well as the face area [katex]A_i[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What about [katex]\phi_i[/katex]? Well, these are the values of [katex]\phi[/katex] at the cell's faces. This is indicated in the figure above on the right by the green crosses on the faces. So, using the figure's notation, we could write this summation explicitly as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a\sum_{i=1}^{n_{faces}}n_f\cdot \phi_i A_i=a\left[(\phi_{i+1/2,j}\Delta y) + (\phi_{i,j+1/2}\Delta x) - (\phi_{i,j-1/2}\Delta x) - (\phi_{i-1/2,j}\Delta y)\right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The plus and minus signs appear as a result of the orientation of the normal vector. The convention is that it is pointing outwards, so on the right and top face, the normal vector is pointing along the x and y direction, respectively, so we multiply the flux [katex]\phi_i A_i[/katex] with [katex]+1[/katex] in the x and y direction. For the left and bottom face, on the other hand, the normal vector points against the x and y direction, so we multiply the fluxes by [katex]-1[/katex], hence the negative sign.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we look at the discretised form above, then we see that our Dirichlet value has sneaked into the discretised equation, i.e. the last term [katex]\phi_{i-1/1,j}[/katex] is located on the boundary, and thus we could also write this as [katex]\phi_{i-1/2,j}=\phi_B=\phi_{Dirichlet}[/katex]. Then, our discretised form becomes:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a\sum_{i=1}^{n_{faces}}n_f\cdot \phi_i A_i=a\left[(\phi_{i+1/2,j}\Delta y) + (\phi_{i,j+1/2}\Delta x) - (\phi_{i,j-1/2}\Delta x) - (\phi_{Dirichlet}\Delta y)\right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we can solve this equation again, by finding values for the remaining values of [katex]\phi_{i+1/2, j}[/katex], [katex]\phi_{i,j+1/2}[/katex], and [katex]\phi_{i,j-1/2}[/katex] through a suitable numerical scheme. We have looked at suitable numerical schemes for the finite volume method in the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/" target="_blank" rel="noopener" title="">previous article</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But we also have to deal with second-order derivatives, which are slightly different. Again, I have derived their <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-discretise-the-navier-stokes-equations/#aioseo-approximating-second-order-spatial-derivatives" target="_blank" rel="noopener" title="">step-by-step derivation in the article on how to discretise the Navier-Stokes equation</a>, so we will just look at the final form here, which is of interest. We saw that we can write the finite volume approximation for the second-order derivative as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>b\int_V \frac{\partial^2 \phi}{\partial x^2}\mathrm{d}V=b\int_V \frac{\partial}{\partial x}\frac{\partial \phi}{\partial x}\mathrm{d}V\approx b\sum_{i=1}^{n_{faces}}n_f\cdot \frac{\partial \phi_i}{\partial x} A_i</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]b[/katex] is some coefficient, but since we only have the diffusion term in the Navier-Stokes equation that uses a second-order derivative, this means that [katex]b[/katex] will always be the dynamic or kinematic viscosity (depending on whether it is divided by the density or not).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So now we have the derivative to deal with in our summation. Let's look at the face on the right, i.e. at location [katex]i+1/2,j[/katex]. Looking at the above figure, we can see that a simple approximation for the derivative at this face could be written as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial\phi}{\partial x}\biggr\rvert_{i+1/2,j}\approx\frac{\phi_{i+1,j}-\phi_{i,j}}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>But what about the left face? Here we do not have a value beyond the location [katex]i-1/2,j[/katex], so we can evaluate the gradient the same way. In this case, we simply form the gradient between locations [katex]i-1/2,j[/katex] and [katex]i,j[/katex], which results in</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial\phi}{\partial x}\biggr\rvert_{i-1/2,j}\approx\frac{\phi_{i,j}-\phi_{i-1/2,j}}{\Delta x/2}=2\frac{\phi_{i,j}-\phi_{Dirichlet}}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we see the appearance of [katex]\phi_{i-1/2,j}=\phi_B=\phi_{Dirichlet}[/katex] again, and so we can impose our Dirichlet-type boundary condition for second-order derivatives again. We would find suitable approximations for the remaining terms, i.e. [katex]\phi_{i,j+1/2}[/katex] and [katex]\phi_{i,j-1/2}[/katex], and then we can continue with our finite volume approximation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The remaining steps to approximate both the first-order and second-order derivatives, as well as how to bring them into a form that can be easily solved, are discussed in the previously mentioned article on how to discretise the Navier-Stokes equations.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-neumann-type-boundary-conditions">Neumann-type boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Neumann-type boundary conditions are really just Dirichlet-type boundary conditions in disguise. Instead of setting the absolute value of a quantity [katex]\phi[/katex] (e.g. velocity, pressure, temperature, etc.) at the boundary, we set the value of its derivative, i.e. [katex]\partial\phi/\partial n[/katex], where [katex]n[/katex] is the normal vector on the boundary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We use this boundary condition when we do not know the values at the boundary and we want them to be calculated as part of the solution. Let's take a simple example, a simple flow through a channel, with an inlet, an outlet, and a wall at the top, bottom, front, and back.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For simplicity, let's say we want to impose a velocity at the inlet that is constant across the inlet boundary. What, then, is the velocity at the outlet? We don't know. We would expect it to follow some form of parabolic or power-law velocity profile depending on whether it is a laminar or turbulent flow, but if our domain is very short, it might not even fully develop. We don't know how the velocity will be distributed at the outlet, so we pick a Neumann-type boundary condition for the velocity at the outlet.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, let's look at the pressure. If we assume that the outlet is connected to some opening where we have atmospheric conditions, then it would make sense to prescribe the atmospheric or ambient pressure at the outlet. This can be a constant value for the pressure across the boundary, so we would impose a Dirichlet-type boundary condition for the pressure at the outlet.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What about the inlet? There will be a pressure drop within the channel, but we don't know what its magnitude is. If we want the pressure drop to develop as part of the solution, then we need to allow the pressure to freely develop at the inlet boundary, as the difference of the pressure at the inlet and outlet will determine the pressure gradient (if we divide the difference by the channel length). Thus, we need a Neumann-type boundary condition for the pressure at the inlet.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Finally, what about the walls? We know that we have a no-slip condition, so the velocity should have the same value as the translational motion of the wall. Typically, walls are stationary in simulations, so there is no movement of the walls, and that means our velocity in each direction has to be zero. Since we know the value, we have to impose a Dirichlet-type boundary condition for the velocity at solid walls.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, think about the pressure distribution around an airfoil. It changes from the leading edge to the trailing edge. The only thing we can say with confidence is that the pressure coefficient is one at the stagnation points. However, we don't know the distribution between the leading and trailing edges. The same is true for our channel example, we don't know the pressure here, so we need to let it develop as part of our solution. This means that the pressure needs to be treated as a Neumann-type boundary condition at solid walls.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's see how we can impose Neumann-type boundary conditions. In general, we can write them as follows:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial n}=\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]n[/katex] is the direction of the normal vector on the boundary. In the figures we looked at above, we have [katex]n=x[/katex], i.e. it is aligned with the x-direction. Using the notation of [katex]n[/katex] allows us to write the boundary condition in a generic notation or even account for curvature on the boundary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>[katex]\phi_{Neumann}[/katex] is the value the derivative should be equal to. A common choice is to set [katex]\phi_{Neumann}=0[/katex]. But there are cases where we want to impose a non-zero value for [katex]\phi_{Neumann}[/katex], for example, when we are dealing with heat transfer applications (where [katex]\phi=T[/katex]) and we want to impose some heating, which would be realised with a non-zero gradient of the temperature gradient at the wall (i.e. we set a heat flux).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's start to see how we can impose Neumann-type boundary conditions on the domain sketched out in the figures we looked at previously. For the figure on the left, i.e. using the finite difference method, we have the following discretisation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial n}=\frac{\partial \phi}{\partial x}=\frac{\phi_{i,j}-\phi_{i-1,j}}{\Delta x}=\frac{\phi_{i,j}-\phi_B}{\Delta x}=\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, all that we have to do is solve this equation for [katex]\phi_B[/katex], which will be the value at the boundary that we will impose. This will lead to:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i,j}-\Delta x\cdot\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The boundary position is important and changes this calculation. For example, if we assume for a second that the boundary would be located at [katex]i+1,j[/katex] in the figure, i.e. the solid, vertical black line would be attached to the blue cells on the right, then our boundary condition would be evaluated as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial n}=\frac{\partial \phi}{\partial x}=\frac{\phi_{i+1,j}-\phi_{i,j}}{\Delta x}=\frac{\phi_{B}-\phi_{i,j}}{\Delta x}=\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In this case, when we solve for [katex]\phi_B[/katex], we obtain:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i,j}+\Delta x\cdot\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, if we have the special case of [katex]\phi_{Neumann}=0[/katex] (in the channel flow example we discussed above, all Neumann-type boundaries had a zero gradient condition), both expressions simplify to</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>That is, we simply copy the value of [katex]\phi[/katex] that is next to our boundary node in the [katex]n[/katex] direction. Now you can see why I said that Neumann-type boundary conditions are Dirichlet-type boundary conditions in disguise. We still impose a value for them, but we do so with values from the internal domain. This is also why the values can change (like the pressure distribution around an airfoil), which is based on values obtained from the internal fluid domain.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And what about the finite volume discretisation? Switching our attention to the figure on the right, which we saw in the beginning of this section, we have a very similar process. We can write the Neumann-type boundary condition as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial n}=\frac{\partial \phi}{\partial x}=\frac{\phi_{i,j}-\phi_{i-1/2,j}}{\Delta x/2}=2\frac{\phi_{i,j}-\phi_B}{\Delta x}=\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can solve this equation now for [katex]\phi_B[/katex], which results in</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i,j}-\frac{\Delta x}{2}\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If the boundary would be located again at [katex]i+1,j[/katex], i.e. on the east side of the simplified domain given in the figure above, then we would obtain</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial n}=\frac{\partial \phi}{\partial x}=\frac{\phi_{i+3/2,j}-\phi_{i+1,j}}{\Delta x/2}=2\frac{\phi_{B}-\phi_{i+1,j}}{\Delta x}=\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, the location [katex]i+3/2,j[/katex] is the face between [katex]i+1,j[/katex] and [katex]i+2,j[/katex], i.e. [katex]i+3/2,j=i+1.5,j[/katex]. Then can then be solved for [katex]\phi_B[/katex] again to result in</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i+1,j}+\frac{\Delta x}{2}\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we have [katex]\phi_{Neumann}=0[/katex], then we can simplify our expression again, and we have </p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>For the arrangement given in the figure above on the right (i.e. the boundary is located on the west face of the domain). Since we know the value on the Boundary now, we can continue exactly in the same way as we did for the Dirichlet-type boundary condition. And this is what I would advocate you should do if you want to write your own solver.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Some CFD textbooks will introduce a simplification for second-order derivatives. We saw in the discussion on the Dirichlet-type boundary conditions that we had the following expression for second-order derivatives:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>b\int_V \frac{\partial^2 \phi}{\partial x^2}\mathrm{d}V=b\int_V \frac{\partial}{\partial x}\frac{\partial \phi}{\partial x}\mathrm{d}V\approx b\sum_{i=1}^{n_{faces}}n_f\cdot \frac{\partial \phi_i}{\partial x} A_i</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Since we now have to deal with derivatives directly, as seen in the last term, when we are summing over all faces, we could simply set the gradient at the boundary to the value of [katex]\phi_{Neumann}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I don't like this approach because this is not how you want to implement that in code. Based on the discussion we had up to this point, we saw that once we have found a way to implement Dirichlet-type boundary conditions, we can reuse (or even better, modify) this implementation to also allow for Neumann-type boundary conditions. This results in cleaner code, which is easier to maintain and modify. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-robin-type-boundary-conditions">Robin-type boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Robin-type boundary conditions are just a linear combination of Dirichlet and Neumann-type boundary conditions. We can write them in simple terms as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Robin}=a\cdot\phi_{Dirichlet}+b\cdot\frac{\partial \phi}{\partial n}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]a[/katex] and [katex]b[/katex] are linear weights that we use to determine how much each boundary condition contributes. I will show you in a second how you can determine these. A good question at this point would be, why do we need this type of combination? First of all, it is rare (I have survived my entire CFD career up to this point without ever having to use this condition), but specific applications can benefit from it. In short, it is used to model imperfections.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, we said that we have a no-slip condition at the wall for the velocity. This is true on a macroscopic scale. At a molecular scale, particles will experience an electrostatic force that gets stronger the closer the particles get to the wall. Since the wall is a solid material, its atoms are arranged in a certain lattice structure that doesn't move. Any fluid particle (or atom, I use these nouns interchangeably) that gets close is attracted to the wall, and its movement will slow down due to this attractive force. But the particles will never fully stop moving.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But, if we look at a macroscopic average velocity of these particles at the wall, it would appear as if there is no movement. So, on a macroscopic level, a Dirichlet-type boundary condition for the velocity with no relative motion between the fluid and the wall is a very good approximation of the underlying physics.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But what happens if we work on smaller length scales? For example, have a look at the following application, which is known as a lab-on-a-chip device:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5153,"width":"500px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/lab_on_a_chip_device.jpg" alt="" class="wp-image-5153" style="width:500px"/><figcaption class="wp-element-caption">Reproduced from <a href="https://biotium.com/blog/scaling-down-to-go-big-an-overview-of-the-lab-on-a-chip/" target="_blank" rel="noopener" title="">biotium</a></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We have lots of so-called microchannels, seen in red and blue colour, and you see in comparison to the thumb and index finger that these channels are rather small. As our characteristic length scale (say, the height of the channel) gets smaller and smaller, it gets closer to the average distance an atom can travel before colliding with another atom. This distance is known as the mean free path (and for air at ambient pressure, it is about [katex]7\cdot 10^{-8}[/katex] meters.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As these two numbers converge, our continuum hypothesis that we use for the Navier-Stokes equations no longer holds true, i.e. the continuum hypothesis assumes that we are dealing with a large number of atoms so that any motion we observe results from the average motion of these underlying particles. We use the Knudsen number to help us identify this effect, which is expressed as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>Kn=\frac{\text{mean free path}}{\text{characteristic length}}=\frac{\lambda}{L}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Depending on which sources you consult, we classify our flow into different regimes. Typical values and their corresponding flow regime are given as:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>[katex]Kn&lt;0.01[/katex]: Continuum flow (Navier-Stokes equations are valid)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>[katex]0.01\le Kn\le 0.1[/katex]: Slip flow (Navier-Stokes equations are valid with modified boundary conditions, for example, Robin type)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>[katex]0.1\le Kn\le 10[/katex]: Transitional flow (Navier-Stokes no longer works here; a particle description is needed)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>[katex]Kn &gt; 10[/katex]: Free molecular flow</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>As our characteristic length scale approaches this mean free path (as our Knudsen number increases and gets to a value of [katex]Kn&gt;0.01[/katex]), we start to see a shift from this purely Dirichlet-type boundary condition to that of atoms freely moving about at the boundary, which can result in some noticeable slip at the boundary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This slipping of atoms can be implemented with a Robin-type boundary condition, where we impose a nominal no-slip boundary condition with our Dirichlet-type boundary condition, and then we allow some slippage through the Neumann-type boundary condition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another example would be insolation against heat transfer at walls. Let's say our goal is to keep the temperature at a wall to a constant value, but we don't want the fluid to heat the wall further and impose a heat flux across the boundary. We might not be able to fully insulate our wall, so a small heat flux ([katex]\partial T/\partial n\ne 0[/katex]) may be measured in experiments. If we wanted to account for that in our boundary conditions, then we could impose a Robin-type again to model this with more confidence.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So let's look at how the discretised equations would look like. For the finite difference approximation on the left in the figure above, we have</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=a\cdot\phi_{Dirichlet}+b\cdot\frac{\partial \phi}{\partial n}=a\cdot\phi_{Dirichlet}+b\cdot\frac{\phi_{i,j}-\phi_B}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we have to solve this equation for [katex]\phi_B[/katex], where we first have to isolate [katex]\phi_B[/katex] as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B+\frac{\phi_B}{\Delta x}=a\cdot\phi_{Dirichlet}+b\cdot\frac{\phi_{i,j}}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, we simplify the left-hand side to</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B\left(1+\frac{1}{\Delta x}\right)=a\cdot\phi_{Dirichlet}+b\cdot\frac{\phi_{i,j}}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Dividing by the term in the parenthesis on the left, we obtain our combined Robin-type boundary condition as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\frac{a\cdot\phi_{Dirichlet}+b\cdot\frac{\phi_{i,j}}{\Delta x}}{\left(1+\frac{1}{\Delta x}\right)}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>For the finite volume discretisation seen in the figure above on the right, we have a very similar procedure. We start with</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=a\cdot\phi_{Dirichlet}+b\cdot\frac{\partial \phi}{\partial n}=a\cdot\phi_{Dirichlet}+b\cdot\frac{\phi_{i,j}-\phi_{i-1/2,j}}{\Delta x/2}=a\cdot\phi_{Dirichlet}+2b\cdot\frac{\phi_{i,j}-\phi_B}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can now derive the Robin-type boundary condition for the finite volume discretisation in exactly the same manner, or we can be lazy and realise that this is exactly the same equation as for the finite difference method, with the only difference that we have a factor of two infront of the [katex]b[/katex] coefficient. Thus, regardless of which way we take, we would end up with</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\frac{a\cdot\phi_{Dirichlet}+2b\cdot\frac{\phi_{i,j}}{\Delta x}}{\left(1+\frac{1}{\Delta x}\right)}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Finally, let us discuss how we can obtain the values for [katex]a[/katex] and [katex]b[/katex]. To do this, we need to know beforehand what the behaviour at the boundary should look like. For example, we may have measured a small slippage at a wall boundary condition, either through an experiment or a numerical simulation using a particle method. Let's say that we obtained the following velocity profile:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5155,"width":"300px","sizeSlug":"large","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/robin_boundary_condition_profile-975x1024.png" alt="" class="wp-image-5155" style="width:300px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We can see that we do not have a fully no-slip condition at the boundary. In this particular example, the velocity at the wall is [katex]0.5[/katex]. I have also given the slope at the wall, which we can use to calculate the gradient. Using the numbers provided, we see that as we go one unit up on the y axis, i.e. [katex]\Delta y=1[/katex], we can see that we have to go two units to the right on the x (u) axis, i.e. [katex]\Delta u = 2.5 - 0.5 = 2.0[/katex]. This means that our gradient, or slope, of the velocity at the wall is [katex]\partial u/\partial x\approx \Delta u/\Delta y=2/1=2[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can also say that we want [katex]\phi_{Robin}=\phi_B[/katex] to evaluate to [katex]0.5[/katex], i.e. this is the value that we want to impose on our boundary. The Dirichlet-type boundary condition for the velocity is still going to assume that we have a no-slip value at the wall, which would leave us with [katex]\phi_{Dirichlet}=0[/katex]. With that knowledge, we can write our Robin-type boundary condition as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Robin}=a\cdot\phi_{Dirichlet}+b\cdot\frac{\partial \phi}{\partial n}\\[0.5em]
0.5=a\cdot 0+b\cdot 2\\[0.5em]
0.5=b\cdot 2\\[0.5em]
b=\frac{1}{4}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We want to ensure that [katex]a+b=1.0[/katex], i.e. [katex]a[/katex] and [katex]b[/katex] have to be chosen in a way that we have a linear combination of Dirichlet-type and Neumann-type boundary conditions. If [katex]a+b=1[/katex] and [katex]b=0.25[/katex], then we have [katex]a=0.75[/katex]. In this case, the coefficient of [katex]a[/katex] doesn't matter, as we impose a zero velocity at the wall, but if we were to use the example of a heated wall with a heat flux through it, then we would impose the wall temperature here, which would not be zero.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And there you have it. Three fundamental boundary condition types will be used to construct various types of derived boundary conditions, such as velocity inlets, mass flow outlets, solid walls, symmetry planes, and so on. We will derive this at the end of this article, but before we do that, let's discuss the two different ways we can implement boundary conditions in code. </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-two-schools-of-thought-on-implementing-boundary-conditions">The two schools of thought on implementing boundary conditions</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>As alluded to above, we have two different ways of implementing boundary conditions in our code. We can make changes to our mesh and thus change the way the boundaries are treated. In this section, I want to review these two different methods and show which advantages and disadvantages they bring.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-strict-imposition-of-boundary-conditions">Implementing boundary conditions without mesh modifications</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In the first method, we do not touch the mesh, and we leave everything exactly as it is. This results in the methodology we used in the previous section. Take a look at the vertex-based and centroid-based mesh again that we looked at above:</p>
<!-- /wp:paragraph -->

<!-- wp:columns -->
<div class="wp-block-columns"><!-- wp:column -->
<div class="wp-block-column"><!-- wp:image {"id":5144,"sizeSlug":"large","linkDestination":"none"} -->
<figure class="wp-block-image size-large"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/vertex_based_boundary_conditions-1024x819.png" alt="" class="wp-image-5144"/></figure>
<!-- /wp:image --></div>
<!-- /wp:column -->

<!-- wp:column -->
<div class="wp-block-column"><!-- wp:image {"id":5143,"sizeSlug":"large","linkDestination":"none"} -->
<figure class="wp-block-image size-large"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/centroid_based_boundary_conditions-1024x915.png" alt="" class="wp-image-5143"/></figure>
<!-- /wp:image --></div>
<!-- /wp:column --></div>
<!-- /wp:columns -->

<!-- wp:paragraph -->
<p>The advantage is obvious (well, after you have gone through the other type of how to treat boundaries); we do not have to make any mesh modifications. We either create our mesh within our solver or read in the mesh from an external mesh generator, and we can use it as it is. This seems logical, but you will see why this is an advantage in the next section.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The disadvantage is that as we approach the boundary, the cell directly attached to the boundary will not have any neighbour cell beyond that boundary. But, if we use a higher-order scheme, we saw in my previous article that we need to have more and more points to the left and to the right of the cell for which we are currently finding an approximation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>At boundaries, we can't evaluate these schemes, so we have to switch to a lower-order version just to be able to get approximations near the boundaries, either for the gradients (finite difference method) or the face-interpolated values (finite volume method). If you went through my <a href="https://cfd.university/newsletter-signup/" target="_blank" rel="noopener" title="">eBook on how to implement your own CFD solver</a>, we saw that we had to switch the numerical scheme at the boundaries from a second-order MUSCL scheme to a first-order piecewise constant scheme.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, with this approach, we get to use the mesh as is, without modifications. Boundary conditions can be implemented as we have discussed in the previous section, but the numerical schemes used at boundaries may reduce in order. If we want to overcome this issue, we need to have a look at the second type of implementing boundary conditions with ghost cells. Let's do that next.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-implementing-boundary-conditions-using-the-ghost-cell-approach">Implementing boundary conditions using the ghost cell approach</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>So, you have decided that you do not want to reduce the order of approximation near the boundary. This can be achieved at a cost. What we have to do is to implement additional cells that go beyond the boundary. This is shown below for a vertex-based (finite difference) approach:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5145,"width":"900px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/vertex_based_boundary_cell_arrangements.png" alt="" class="wp-image-5145" style="width:900px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We can also add additional cells for a centroid-based (finite volume) approach, which would result in:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5146,"width":"900px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/centroid_based_boundary_cell_arrangements.png" alt="" class="wp-image-5146" style="width:900px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>In both cases, we have added two additional cells to the left of the boundary, indicated again by the vertical black line. These additional cells go under various names, but a common name is ghost cells. If you look into the CGNS format, it does support ghost cells, but it goes under the name of rind layers, just to confuse that little bit extra (no one else uses that name as far as I can see).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's ignore for the moment how we can impose boundary conditions, now that the boundary is seemingly on the inside of the domain. We are still only solving the flow for the internal domain, i.e. everything up to the boundary, that is the domain we are interested in. But now that we have additional cells beyond the boundary, we can use our higher-order numerical schemes without issues, i.e. those where we need information beyond the boundary. This simplifies our code implementation significantly near boundaries.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another advantage is that we have practically removed boundaries completely. In our code, we simply solve the equations up the cells that are attached to the boundaries, but we no longer have to introduce a special treatment near boundaries. How is that possible? Well, the ghost cells that we have created need to have some values. We set the values within those ghost cells based on the boundary conditions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's take the vertex-based (finite difference) case first. Here we can see that we have [katex]\phi_B[/katex] located at [katex]i,j[/katex], in other words, [katex]\phi_B=\phi_{i,j}[/katex]. So this is the [katex]\phi[/katex] on the boundary. We can see by the shaded outline that both [katex]\phi_{i-1,j}[/katex] and [katex]\phi_{i-2,j}[/katex] are located within the ghost cells, and they are located outside of our fluid domain.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The way that we find values for these two cells is by using the information we have at the boundaries. For example, if we have a Dirichlet-type boundary condition for [katex]\phi[/katex], i.e. we have [katex]\phi_B=\phi_{Dirichlet}[/katex], then we can say that the average of [katex]\phi[/katex] at the two vertices directly left and right to [katex]\phi_B[/katex] must be equal to [katex]\phi_{Dirichlet}[/katex]. This can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Dirichlet}=\frac{\phi_{i+1,j}+\phi_{i-1,j}}{2}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>From this, we can solve this equation for [katex]\phi_{i-1,j}[/katex] and obtain</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{i-1,j}=2\cdot \phi_{Dirichlet}-\phi_{i+1,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The eagle-eyed among you will have realised this is the canonical equation for extrapolation. Thus, we use values of [katex]\phi[/katex] at [katex]i+1,j[/katex] (which we know from the internal fluid domain computation) and [katex]i,j[/katex] (which we know from the Dirichlet-type boundary condition) to find a value at [katex]i-1,j[/katex] (beyond the fluid domain). Because we found this value by using the boundary condition, it will be implicitly included when we use now [katex]\phi_{i-1,j}[/katex] in our computations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What about [katex]i-2,j[/katex]? Well, we repeat the same process and find the average between cells at [katex]i+2,j[/katex] and [katex]i-2,j[/katex]. This results in</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Dirichlet}=\frac{\phi_{i+2,j}+\phi_{i-2,j}}{2}\\[0.5em]
\phi_{i-2,j}=2\cdot\phi_{Dirichlet}-\phi_{i+2,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This extends to an arbitrary number of cells, so we can introduce as many ghost cells as we need to use the numerical stencil we want. If we are dealing with centroid-based (finite volume) approximations, using the definition in the figure above, we simply have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{i-1,j}=2\cdot\phi_{Dirichlet}-\phi_{i,j}\\[0.5em]
\phi_{i-2,j}=2\cdot\phi_{Dirichlet}-\phi_{i+1,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>OK, so this is how we deal with Dirichlet-type boundary conditions. What about Neumann-type? The process is similar, where we first start with the definition of the Neumann-type boundary condition, which is</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Neumann}=\frac{\partial \phi}{\partial n}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We now take this and approximate the derivative across the boundary. For the vertex-based approximation, we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Neumann}=\frac{\phi_{i+1,j}-\phi_{i-1,j}}{2\Delta x}\\[0.5em]
\phi_{Neumann}=\frac{\phi_{i+2,j}-\phi_{i-2,j}}{4\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This can be solved for the unknowns [katex]\phi_{i-1,j}[/katex] and [katex]\phi_{i-2,j}[/katex] to produce:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{i-1,j}=2\Delta x\cdot\phi_{Neumann}+\phi_{i+1,j}\\[0.5em]
\phi_{i-2,j}=4\Delta x\cdot\phi_{Neumann}+\phi_{i+2,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Again, for the centroid-based (finite volume) description, we would obtain similar results. With the notation provided in the figure above, we would have</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Neumann}=\frac{\phi_{i,j}-\phi_{i-1,j}}{\Delta x}\\[0.5em]
\phi_{Neumann}=\frac{\phi_{i+1,j}-\phi_{i-2,j}}{3\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This can be solved for the unknowns again to yield:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{i-1,j}=\Delta x\cdot\phi_{Neumann}+\phi_{i,j}\\[0.5em]
\phi_{i-2,j}=3\Delta x\cdot\phi_{Neumann}+\phi_{i+1,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In all of the above discussions, I assume that the grid spacing is constant. If we have mesh stretching, then we could either introduce ghost cells with constant spacing and then work out how derivatives with non-constant spacing are approximated, or we could simply mirror the mesh spacing in our ghost cells so that the boundary would essentially act as a mirror. For example, if we use inflation layers, these would have to be mirrored by the ghost cells. This is the easier approach of the two.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you look at the Dirichlet-type and Neumann-type approximation, you might have realised that we are using here a second-order extrapolation and a second-order central difference scheme to approximate the derivative. Thus, if you are using a numerical scheme that has a numerical order that is higher than two, you might not be able to achieve that order at the boundaries, as the values within the ghost cells are only approximated to within second-order accuracy. Bummer!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Could we use higher-order approximations? Yes, but once we do, we may start to introduce numerical oscillations. If you have ever fitted a higher-order polynomial through some points, you will know that you will get a seemingly good fit for interior points (probably an overfit), but near the points at the start and end, your polynomial will oscillate quite violently.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Take the following example of fitting a sixth-order polynomial through six points:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5156,"sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/polynomial_approximation_sixth_order.png" alt="" class="wp-image-5156"/><figcaption class="wp-element-caption">Reproduced from <a href="https://bartwronski.com/2021/11/03/study-of-smoothing-filters-savitzky-golay-filters/" target="_blank" rel="noopener" title="">Bart Wronski</a></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>While the polynomial goes through all data points, it does start to oscillate. A similar behaviour may be observed if we want to achieve higher-order approximations for the values in our ghost cells, so it is probably for the best to keep it to second order.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But even if we find a stable method of approximating values within our ghost cells, that would only really work for equidistant structured grids. What about unstructured grids? Let's have a look at the following example:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5158,"width":"400px","sizeSlug":"large","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/ghost_cells_unstructured_grid-1024x996.png" alt="" class="wp-image-5158" style="width:400px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Here, if we want to get the centroid value for the ghost cell shown (I have left the other ghost cells at the top and bottom empty), then we see that the point on the other side of the boundary in the fluid domain would be where the orange dot is located. However, this point does not coincide with any centroid within the fluid domain, so we would have to get this point with an interpolation from surrounding points. This can be done, but higher-order schemes using ghost cells now would be limited by this second-order interpolation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I have just shown one layer of ghost cells here, but for higher-order numerical schemes on unstructured grids, your stencil will be much larger. That means that we have to construct even more ghost cells. You see, on unstructured grids, the complexity quickly escalates, but we are not really gaining anything. We have to resort to second-order interpolation, so our higher-order scheme would lose accuracy near the boundaries anyway. It is simpler to just use a lower-order scheme here, which likely has the same accuracy but less computational cost.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" id="aioseo-how-to-implement-boundary-conditions-for-implicit-time-integration">How to implement boundary conditions for implicit time integration</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Thus far, we have looked at how to treat Dirichlet, Neumann, and Robin-type boundary conditions, and the discussion has been accurate to this point. However, the way that I have presented boundary conditions thus far will only really allow you to deal with explicit time integration schemes.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Why is that? When we deal with a purely explicit time integration scheme, we have an equation of the form:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi^{n+1}=\phi^n + \Delta t\left[\text{advection}(\phi^n) + \text{diffusion}(\phi^n) + \text{sources}(\phi^n)\right] </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, advection(), diffusion(), and sources() are some operators to discretise the various terms in our Navier-Stokes equation. The defining characteristic of a fully explicit time integration is that we have a single unknown on the left-hand side of the equation, in this case, [katex]\phi[/katex] at the <em>next time level</em>, i.e. [katex]\phi^{n+1}[/katex], while all other variables are known and on the right-hand side of the equation, in this case, [katex]\phi[/katex] at the <em>current time level</em>, i.e. [katex]\phi^n[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this case, [katex]\phi^n[/katex] is either taken from the initial condition, if we are just starting our simulation, or from the previously computed time level, if we have already computed some time steps as part of our simulation. For an implicit time integration, at least one (or all) of the terms on the right-hand side is/are evaluated at the next time level, i.e. we have at least one dependency on [katex]\phi^{n+1}[/katex]. For a fully implicit system of equations, for example, we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi^{n+1}=\phi^n + \Delta t\left[\text{advection}(\phi^{n+1}) + \text{diffusion}(\phi^{n+1}) + \text{sources}(\phi^{n+1})\right] </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In this case, it is typically customary to group all known variables on the right-hand side, i.e. those depending on the previous time level (all terms containing [katex]\phi^n[/katex]), and all unknowns on the left-hand side, i.e. those depending on the current time level (all terms containing [katex]\phi^{n+1}[/katex]). This would result in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi^{n+1} - \Delta t\left[\text{advection}(\phi^{n+1}) + \text{diffusion}(\phi^{n+1}) + \text{sources}(\phi^{n+1})\right]=\phi^n  </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This type of system then leads to a linear system of equations, of the form [katex]\mathbf{Ax}=\mathbf{b}[/katex], as we have seen in the previous article, and we need to solve this now. Solving a linear system of equations poses its very own challenges, especially near boundaries. Since we are solving [katex]\mathbf{Ax}=\mathbf{b}[/katex], we need to impose boundary conditions directly into our coefficient matrix [katex]\mathbf{A}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While that is no more complicated than what we have already discussed up to this point, if you have never done it, you might be wondering how to do that, and so in this section, I want to shine some light on that, as this is something that catches me out every now or then (I just spent a week debugging my coefficient matrix only to realise that I must have had a stroke while implementing the Neumann boundary conditions. We shall not speak of this blunder again, and you shall not examine my git history!)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the following section, we will look at how we can implement our two fundamental boundary types (Dirichlet and Neumann) using no mesh modifications and the ghost cell approach.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-implicit-time-integration-without-mesh-modifications">Implicit time integration without mesh modifications</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We'll start with the approach that doesn't require mesh modifications. As it turns out, Dirichlet boundary conditions are pretty straightforward to implement, at least if we assume a finite-difference type data structure, that is, we store our variables at nodes/vertices. This is straightforward, as we will see shortly, because we can impose boundary conditions directly at the location where we store our variables.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once we start to adopt a finite-volume type data structure, though, we store data at cell centroids, which are not on the boundaries, and so, we have to make changes to our discretisation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While it does sound like vertex/node-based discretisation is easier to achieve, it's not; we are just shifting problems around. While it may indeed be easier to impose some boundary conditions with a node-based discretisation, we end up with an array of other issues. For example, think of corner points, where two different boundary conditions meet. Which one are we imposing here?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is an issue for which there are solutions available, but it just goes to show that no matter what we do with our boundaries, they will make sure that we suffer from <a href="https://www.nhs.uk/mental-health/conditions/post-traumatic-stress-disorder-ptsd/overview/" target="_blank" rel="noopener" title="">PTSD</a>. There is no free lunch.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Anyways, after these <em>encouraging</em> words, if you are up for it, let's look at these boundary conditions. Boy, how I look forward to writing this ...</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-dirichlet-boundary-conditions">Dirichlet boundary conditions</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's recall what our goal is with Dirichlet-type boundary conditions. We have some value [katex]\phi_{Dirichlet}[/katex] that we want to impose on boundaries. Looking at the following, simple, 1D domain, we can see that our goal, for example, is to impose some Dirichlet value on the west boundary, that is, at node/vertex 1.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"500px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/implicit_boundary_condition_imposition_node_based.png" alt="A 1D domain with 5 nodes; 2 on the boundaries, and 3 on the internal domain. Dirichlet boundary conditions are applied on the left (first node), while Neumann boundary conditions are applied on the right (last node). Below the 1D domain is a sketch of the 5  by 5 coefficient matrix, the vector x, and the right-hand side b vector that would be used to solve the linear system Ax=b." class="wp-image-5550" style="width:500px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Below the 1D domain, we see the individual matrices and vectors of the linear system of equations that arises from our discretisation, i.e. [katex]\mathbf{Ax}=\mathbf{b}[/katex]. We see that we have the same number of rows (and columns for the coefficient matrix) as we have grid points, which would be true for 2D and 3D grids as well (i.e. if we have 1 million cells in our mesh, and we store information at cell centroids, then we have a 1 million by 1 million coefficient matrix, and two vectors of length 1 million for [katex]\mathbf{x}[/katex] and [katex]\mathbf{b}[/katex], respectively).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On the internal domain, that is, on nodes 2-4, we go about our discretisation as per usual, and find the coefficient that we want to impose in our coefficient matrix. But what happens at the boundaries? Well, we need to focus our attention now on node/vertex 1.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we were dealing with an explicit time integration, we would simply set the value of [katex]\phi[/katex] to [katex]\phi_{Dirichlet}[/katex]. We can write this as [katex]\phi_1=\phi_{Dirichlet}[/katex]. So, the goal of the Dirichlet boundary condition is to impose a fixed value on the boundary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's take that to our linear system of equations now. How do we translate that to [katex]\mathbf{Ax}=\mathbf{b}[/katex]? Well, here, [katex]\mathbf{x}[/katex] is the vector that will contain the solution of our unknowns after we have solved this system of equations. We want this vector to contain the correct values at the boundaries as well, so essentially, what we are saying is that the first entry at index/row 1 of [katex]\mathbf{x}[/katex] should contain [katex]\phi_{Dirichlet}[/katex] after we have finished solving our linear system of equations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, if we were to simply write this into our vector, that is, we set [katex]x_1=\phi_{Dirichlet}[/katex], we would not be imposing this boundary condition at all! Why? Well, let's say, for a moment, that we can easily invert [katex]\mathbf{A}[/katex]. Either the matrix is very small, or we have found a Nobel Prize-worthy inversion algorithm (only to realise that mathematicians are not eligible for Nobel Prizes) that allows us to rewrite our system of equations as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\mathbf{x}=\mathbf{A^{-1}b} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we now set [katex]x_1=\phi_{Dirichlet}[/katex], it would be completely ignored by this system, as [katex]x_1[/katex] is computed from the first row of [katex]\mathbf{A}[/katex] and the entire right-hand side vector [katex]\mathbf{b}[/katex]. And, even if we have not found a Nobel Prize-worthy inversion algorithm and we continue to use an iterative procedure, this iterative procedure will still aim to find a solution to the above equation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, you may then argue, why don't we just set something like [katex]x_1=\phi_{Dirichlet}[/katex], knowing full well that this will not impose boundary conditions correctly, but we still solve [katex]\mathbf{Ax}=\mathbf{b}[/katex] and then overwrite whatever (incorrect) solution has been obtained at [katex]x_1[/katex] with the correct value of [katex]\phi_{Dirichlet}[/katex]?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, this certainly sounds plausible, but that has a pretty big problem. You see, when we discretise our governing equations with our numerical schemes, and we start to fill our coefficient matrix [katex]\mathbf{A}[/katex] based on our discretisation, if we do not impose the boundary conditions correctly here, we are no longer solving the governing equation we are trying to solve.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, we have to impose our boundary condition in such a way that the solution vector [katex]\mathbf{x}[/katex] in [katex]\mathbf{Ax}=\mathbf{b}[/katex] will contain the correct boundary value after the simulation has completed. In the case of Dirichlet-type boundary conditions, this is thankfully easy to achieve.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's look at [katex]\mathbf{Ax}=\mathbf{b}[/katex] again carefully. If we want the first entry in [katex]\mathbf{x}[/katex] to be [katex]\phi{Dirichlet}[/katex], then the easiest way to achieve that is to set the first row and column in the coefficient matrix [katex]\mathbf{A}[/katex] to 1, i.e. we have [katex]A_{11}=1[/katex], while setting the first entry in the right-hand side vector [katex]\mathbf{b}[/katex] to [katex]\phi_{Dirichlet}[/katex], i.e. we have [katex]b_1=\phi_{Dirichlet}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we impose the boundary conditions this way, then we are guaranteed to get the correct value in our solution vector [katex]\mathbf{x}[/katex]. To make this clear, [katex]A_{11}[/katex] is set to 1, while all other columns for the first row are zero. We can write this precisely for the first node as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
A_{1j}=
\begin{cases}
1\qquad j=1\\
0\qquad j\ne 1 
\end{cases} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If this is the case, then our linear system of equations [katex]\mathbf{Ax}=\mathbf{b}[/katex] can be written for the first boundary node as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
A_{11}\cdot x_1 = b_1 \\
1\cdot x_1 = \phi_{Dirichlet}\\
x_1 = \phi_{Dirichlet}/1\\
x_1 = \phi_{Dirichlet} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>It doesn't matter what is in the right-hand side vector [katex]\mathbf{b}[/katex], as long as it contains the correct value at [katex]b_1[/katex], since all other columns in the coefficient matrix are set to zero, and so whatever else is in [katex]\mathbf{b}[/katex], will be multiplied by zero, except what is stored at [katex]b_1[/katex] (which is [katex]\phi_{Dirichlet}[/katex]).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What I have assumed thus far is that the nodes/vertices in our mesh coincide with the location where we store our solution variables as well. This is typical for finite difference approximations, but not for finite-volume discretisations. When we are dealing with finite volumes, we typically store our variables at cell-centroids. If we adapt our 1D domain example from above, where we now store variables at the cell centroids, we obtain the following domain:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/implicit_boundary_condition_imposition_centroid_based.png" alt="A 1D domain with 6 nodes; 2 on the boundaries, and 43 on the internal domain. Dirichlet boundary conditions are applied on the left (first node), while Neumann boundary conditions are applied on the right (last node). Below the 1D domain is a sketch of the 4 by 4 coefficient matrix, the vector x, and the right-hand side b vector that would be used to solve the linear system Ax=b." class="wp-image-5550" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>In this case, the boundary conditions are no longer imposed directly at the same location where our variables are stored, and so, we cannot simply set [katex]A_{11}=1[/katex] and [katex]b_1=\phi_{Dirichlet}[/katex]. If life was only that simple ...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Instead, we have to modify our discretisation and work the boundary conditions directly into our discretisation. Let's consider first-order and second-order derivatives; these are the ones you will usually find in CFD (e.g. advection, divergence, and pressure gradient representing first-order derivatives, and diffusion representing second-order derivatives). For first-order derivatives, we have the following finite-volume discretisation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \phi}{\partial x}\rightarrow \int_v\frac{\partial \phi}{\partial x}\mathrm{d}V = \int_S\vec{n}\cdot \phi \mathrm{d}S\approx \sum_k^{nFaces}\vec{n}_k\cdot\phi_k\cdot S_k </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If you need a refresher on this discretisation, and why on earth I get away with murder for changing a volume to a surface integral, you may want to catch up on my <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-discretise-the-navier-stokes-equations/#aioseo-the-finite-volume-method" target="_blank" rel="noopener" title="">finite-volume</a> write-up.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's consider the following sketch of a single cell, showing all of its dimensions, as well as a boundary on the left-hand side of the cell:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"400px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/single_cell_with_dimensions.png" alt="A single cell showing the dimensions dx and dy (width and height of the cell), as well as distances to the centroid (dx/2 and dy/2, respectively)." class="wp-image-5550" style="width:400px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We can see the surface area in 2D is just the height of the cell (i.e. [katex]S=\Delta y[/katex]), and, if this is a 1D example, then we simply set it to [katex]S=\Delta y=1[/katex], and we can ignore it in our discretisation. We see that the normal vectors point outwards from the cell, and we see that we have interpolated values for [katex]\phi[/katex] on the cell's faces. Well, on the east face, we do have an interpolated value [katex]\phi_{i+\frac{1}{2}}[/katex], on the west face, we have the boundary value [katex]\phi_b[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you need a refresher on how to get those interpolated values, I got you covered as well. See my write-up on <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/#aioseo-numerical-schemes-for-finite-volume-discretisation" target="_blank" rel="noopener" title="">interpolation schemes</a> for the finite-volume method.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In any case, let's write out our discretisation. For that, we need to know what [katex]\phi_{i+1/2}[/katex] is. For first-order derivatives, for example, the advection term, we use an upwind-based discretisation. In the simplest form, we say that we set [katex]\phi_{i+1/2}[/katex] to [katex]\phi_i[/katex] if the local velocity in the x-direction is positive (and along the x-axis), or we set it to [katex]\phi_{i+1}[/katex] if the local velocity is negative (against the x-axis). We can write this as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_{i+\frac{1}{2}}=
\begin{cases}
\phi_i &u_x \gt 0 \\
\phi_{i+1} &u_x \lt 0
\end{cases} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This type of logic may be best implemented with <code>if/else</code> statements in code, which isn't great for our discretisation. So, instead, we can write this in a more compact form as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_{i+\frac{1}{2}} = \text{max}(sign(u_x), 0)\phi_i + \text{min}(sign(u_x), 0)\phi_{i+1} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, I am using the [katex]sign(x)[/katex] <a href="https://en.wikipedia.org/wiki/Sign_function" target="_blank" rel="noopener" title="">function</a>, which does what it says: it returns the sign (but limits the value to 1). So, a value of [katex]u_x=6.3[/katex] would be [katex]sign(u_x=6.3)=1[/katex], whereas a value of [katex]u_x=-0.7[/katex] would be [katex]sign(u_x=-0.7)=-1[/katex]. Thus, if [katex]u_x \gt 0[/katex], then the first term in the above equation will evaluate to [katex]\mathrm{max}(1, 0)=1[/katex], while the second term will evaluate to [katex]\mathrm{min}(1, 0)=0[/katex]. It will be reversed if [katex]u_x \lt 0[/katex]. In this way, we automatically get the correct value for [katex]\phi_{i+\frac{1}{2}}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we are dealing with, for example, the pressure gradient, we are typically OK to use a central differencing scheme as an approximation, and so could write here:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_{i+\frac{1}{2}}=\frac{\phi_i + \phi_{i+1}}{2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>While this works for the pressure, it pretty much always diverges if we try to use this for the velocity, especially the advection (non-linear) term. If you want to know why, we'll need to talk about <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/explicit-vs-implicit-time-integration-and-the-cfl-condition/#aioseo-von-neumann" target="_blank" rel="noopener" title="">von Neumann's stability analysis</a>. Would you believe it, I have a write-up on that, too. Wow, today must be your lucky day. Have you played the lottery already?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we take the central differencing approach, and we set [katex]\vec{n}=1[/katex] at the east face (pointing along the x-direction) and [katex]\vec{n}=-1[/katex] at the west face (pointing against the x-direction), then we can start to write our discretised equation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\sum_k^{nFaces}\vec{n}_k\cdot\phi_k\cdot S_k=1\cdot\phi_{i+\frac{1}{2}}S + (-1)\cdot \phi_b\cdot S = \frac{\phi_i + \phi_{i+1}}{2}S-\phi_b\cdot S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we have to find all unknowns and collect them on the left-hand side of the equation (that is, all [katex]\phi[/katex] values that are unknown), and place all known values on the right-hand side of the equation. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\phi_i + \phi_{i+1}}{2}S=\phi_b\cdot S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We know what [katex]\phi_b[/katex] is; this is the boundary value we set and want to impose in our simulation, so it moves to the right-hand side. Since this is an implicit discretisation, we don't know the values of [katex]\phi[/katex] on the internal domain, and we obtain these from our linear system of equations. Let's bring this equation into coefficient form:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_i\left[\frac{S}{2}\right] + \phi_{i+1}\left[\frac{S}{2}\right] = \phi_b S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In our linear system [katex]\mathbf{Ax}=\mathbf{b}[/katex], where we have [katex]\mathbf{x}=\mathbf{\phi}[/katex] now, we would set [katex]A_{11}=S/2[/katex] and [katex]A_{12}=S/2[/katex]. Furthermore, we have [katex]b_1=\phi_b S[/katex], and the values of [katex]\phi_1,\ \phi_2,\,...,\,\phi_n[/katex] will be stored in the solution vector [katex]\mathbf{x}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we discretised a second-order derivative with the finite-volume discretisation, then we would have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial^2 \phi}{\partial x^2}\rightarrow\int_V\frac{\partial^2 \phi}{\partial x^2}\mathrm{d}V=\int_S\vec{n}\cdot\frac{\partial \phi}{\partial x}\mathrm{d}S\approx\sum_k^{nFaces}\vec{n}\cdot\frac{\partial \phi}{\partial x}S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The derivative [katex]\partial \phi/\partial x[/katex] will be evaluated at the face as well, that is, at [katex]i+1/2[/katex]. Since diffusion itself is a process that has no preferred direction of travel, we do not have to worry about upwinding here. In fact, these types of second-order derivatives have an elliptic behaviour, and you may ask yourself, what is elliptic behaviour, and WHERE IS MY WRITE-UP?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Steady-on, no need to scream, I think someone had too much CFD (fun?) for one day, perhaps take a break? As your CFD doctor, I would usually only recommend a few milligrams of dopamin release when visiting my website, but if you can't stop, you can enjoy my write-up at your own risk: <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-elliptic-flows" target="_blank" rel="noopener" title="">Elliptic flows</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, the derivative at the east face can be evaluated as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \phi}{\partial x}\bigg|_{i+\frac{1}{2}}=\frac{\phi_{i+1}-\phi_{i}}{\Delta x} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We also have to find the derivative at the boundary face, that is, what is [katex]\partial \phi/\partial x[/katex] at [katex]i-1/2[/katex]? Well, we don't have a value for [katex]\phi_{i-1}[/katex], however, we do have the value at [katex]\phi_b[/katex]. This value is not a distance of [katex]\Delta x[/katex] away from [katex]\phi_i[/katex], but rather half that, i.e. [katex]\Delta x/2[/katex]. Therefore, we can find this derivative at the west face as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \phi}{\partial x}\bigg|_{i-\frac{1}{2}}=\frac{\phi_{i}-\phi_{b}}{\Delta x/2}=2\frac{\phi_{i}-\phi_{b}}{\Delta x} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>With both of these two derivatives now available, we can discretise our second-order derivative near boundaries again as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\sum_k^{nFaces}\vec{n}\cdot\frac{\partial \phi}{\partial x}S=(1)\frac{\phi_{i+1}-\phi_{i}}{\Delta x}S + (-1)2\frac{\phi_{i}-\phi_{b}}{\Delta x} S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we proceed as before, we collect terms on the left-hand side which are unknown, and those which are known on the right-hand side, and we end up with:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\phi_{i+1}-\phi_{i}}{\Delta x}S-2\frac{S\phi_i}{\Delta x}=-\frac{2S\phi_b}{\Delta x} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can bring this again in coefficient from, which provides us with:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_i\left[-3\frac{S}{\Delta x}\right] + \phi_{i+1}\left[\frac{S}{\Delta x}\right] = -\frac{2S\phi_b}{\Delta x} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>And, again, we can now populate our coefficient matrix with [katex]A_{11}=-3S/\Delta x[/katex] and [katex]A_{12}=S/\Delta x[/katex], while the right-hand side vector is [katex]b_1=-2S\phi_b/\Delta x[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can repeat this now for any of the other faces, though, in a general sense, we would simply keep the normal vector [katex]\vec{n}[/katex] in the discretisation (here I have inserted the values of +1 and -1 already), which means that we can apply the same procedure to unstructured grids just as well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Additionally, the Navier-Stokes equation consists of a few terms, and each of them will be discretised on its own. This means that if we use a centroid-based discretisation, we may have to add coefficients to [katex]\mathbf{A}[/katex] and values to our right-hand side vector [katex]\mathbf{b}[/katex] a few times.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, we could either write out the coefficients for the entire discretised equation (which textbooks typically do, and this is a sure way to lose overview very quickly) or we can apply the boundary conditions on a per-term basis (advection, diffusion, sources, etc.). This is typically much easier to comprehend (at least in my opinion), and it also aligns better with how you would actually <em>want to</em> implement this.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I say I want to, as this would promote a modular design (we can add as many or as few terms as we want, without having to re-derive our equations if something changes), but let's be honest, it is mostly academics who write CFD solvers, and they rarely think about good software design. (I am not even 40, where is all of that cynicism coming from? ... I should see a (real) doctor ...).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Anyhow, I think we have covered Dirichlet-type boundary conditions now extensively, and we can move on. I tried to be more explanatory here, as I have found classical CFD textbooks to be surprisingly vague on the details here. All it takes is just a bit of derivations, which aren't difficult, but we just need to know what we are doing here. With that said, let's now turn to Neumann-type boundary conditions, which require even more derivations. Oh, the joy that is to come!</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-neumann-boundary-conditions">Neumann boundary conditions</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's return to our sketch using a node-based discretisation. Here, we said that we wanted to apply the Neumann boundary conditions on the right-hand side of the domain, as shown in the figure below, which I have repeated here for convenience:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/implicit_boundary_condition_imposition_node_based.png" alt="A 1D domain with 5 nodes; 2 on the boundaries, and 3 on the internal domain. Dirichlet boundary conditions are applied on the left (first node), while Neumann boundary conditions are applied on the right (last node). Below the 1D domain is a sketch of the 5  by 5 coefficient matrix, the vector x, and the right-hand side b vector that would be used to solve the linear system Ax=b." class="wp-image-5550" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>When we dealt with the Dirichlet-type boundary condition, in this particular case (i.e. with a node-based discretisation), we saw that we can just easily impose that through the coefficient matrix and the right-hand side vector. But, for Neumann-type boundary conditions, that is not the case, unfortunately.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Neumann boundary conditions require us to derive the required matrix coefficients and right-hand side vector component for each operator separately. So, if we are dealing with the Navier-Stokes equations of the form:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\underbrace{\frac{\partial \mathbf{u}}{\partial t}}_{\text{Term 1}} + \underbrace{(\mathbf{u}\cdot\nabla )\mathbf{u}}_{\text{Term 2}} = \underbrace{-\frac{1}{\rho}\nabla p}_{\text{Term 3}} + \underbrace{\nu\nabla^2\mathbf{u}}_{\text{Term 4}} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Then, we have to derive the Neumann condition for each of these 4 terms and apply that to our coefficient matrix. To complicate things further, the above equation cannot be solved as it is, but rather, we have to discretise this equation. In the process, we have to make choices about our numerical schemes, and changing a numerical scheme means we are solving a different discretised equation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, for each scheme that we implement, we have to derive a corresponding Neumann-type condition. Having said that, typically we can discretise the pressure gradient (term 3) and diffusion operator (term 4) with a central scheme and don't (for incompressible flows anyways) and don't have to worry about ever having to change that. The time derivative is also simple (it is very similar to a Dirichlet-type boundary condition), and so the burden, really, is only with the non-linear advective operator (term 2).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, in the sketch above, we want to apply the Neumann-type boundary condition to the right of the domain. Let's do that and start easy. Let's start with the time derivative. If we discretised the time derivative, using a first-order forward finite-difference approximation (as we are node-based here, though I should point out this is a common choice, but not the only permissible one). That is, we can use finite volumes for node-based discretisation and centroid-based discretisation for finite-difference methods. Just for completeness, we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \mathbf{u}}{\partial t}\approx \frac{\mathbf{u}_i^{n+1} - \mathbf{u}_i^{n}}{\Delta t} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we collect terms again and write unknowns on the left-hand side and known terms on the right-hand side, and we arrive at:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\mathbf{u}_i^{n+1}\left[\frac{1}{\Delta t}\right]=\mathbf{u}_i^{n}\left[\frac{1}{\Delta t}\right] </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Referring to the sketch above, we want to impose the Neumann boundary conditions now at the last node with ID 5, so that the coefficient matrix has to be set at location [katex]i=5[/katex] and [katex]j=5[/katex]. This results in [katex]A_{55}=1/\Delta t[/katex], and the right-hand side vector at location [katex]i=5[/katex] becomes [katex]b_5=1/\Delta t[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For completeness, to show what happens with higher-order time derivatives, a popular choice here is the second-order backwards scheme, which can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \mathbf{u}}{\partial t}\approx \frac{3\mathbf{u}_i^{n+1} - 4\mathbf{u}_i^{n} + \mathbf{u}_i^{n}}{2\Delta t} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we collect terms on the left-hand side again that are unknown, and known terms on the right-hand side, we end up with:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\mathbf{u}_i^{n+1}\left[\frac{3}{2\Delta t}\right] = \mathbf{u}_i^{n}\left[\frac{4}{2\Delta t}\right] - \mathbf{u}_i^{n-1}\left[\frac{1}{2\Delta t}\right] </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>And thus, we write into our coefficient matrix [katex]A_{55}=3/(2\Delta t)[/katex] and into our right-hand side vector [katex]b_5=\mathbf{u}_i^{n}[4/(2\Delta t)] - \mathbf{u}_i^{n-1}[1/(2\Delta t)][/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Perhaps now you can see why I say that the time derivative is very similar to a Dirichlet-type boundary condition, with the difference that we are not setting a value of 1 in the coefficient matrix, but rather the coefficient that comes out from our discretisation. Well, it will become, perhaps, even clearer when we deal with different operators. So, let's look at the diffusion operator. We can discretise the diffusion term (term 4 in our Navier-Stokes equation, ignoring the viscosity and only focusing on the derivative here) as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\nabla^2\mathbf{u}=\frac{\partial^2 u}{\partial x^2} \approx \frac{u_{i+1}^{n+1}-2u_{i}^{n+1}+u_{i-1}^{n+1}}{(\Delta x)^2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we have to make an uncomfortable realisation! Thus far in your life, you may have been living under the impression that boundary conditions are imposed on the boundaries and that's that. You left them alone, computed solutions on the interior domain, and then updated boundary conditions afterwards. For explicit schemes, this is the case. But not for implicit schemes.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>No, when we deal with implicit schemes, you see, we do have to compute the solution on the boundaries as well! I don't know about you, but when I first had this realisation, it made me feel very uncomfortable, as if someone told me Santa Claus didn't exist. I don't know why, it just did. So, Neumann boundary conditions are imposed as a constraint on our linear system of equations; we do not update any boundary condition after we are done with the computation; rather, they naturally arise as part of the solution.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's remind ourselves what Neumann boundary conditions are. We said that these represent gradients that are normal to the boundary edges, which we can express as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \phi}{\partial n}=\phi_{Neumann} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can discretise this with a classical central scheme, now using [katex]\phi=u[/katex], as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial u}{\partial n}\rightarrow \frac{u^{n+1}_{i+1} - u^{n+1}_{i-1}}{2\Delta x}=u_{Neumann} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we are at location [katex]i=5[/katex], where we want to impose the Neumann-type boundary condition in the above sketched domain, then inserting this into our discretised Neumann condition will give us [katex]i+1=5+1=6[/katex] and [katex]i-1=5-1=4[/katex] for the locations. Clearly, there is no node at [katex]i=6[/katex], so what do we do? Well, let us write the discretised form of the Neumann condition so that we place all unknowns (i.e. in this case, not in time, but rather in space, that is, [katex]i+1[/katex] quantities are unknown and [katex]i-1[/katex] are known) on the left-hand side:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
u^{n+1}_{i+1}=u^{n+1}_{i-1} + 2u_{Neumann}\Delta x </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>So far so good, now let's turn our attention back to our discretised stencil, we had:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial^2 u}{\partial x^2} \approx \frac{u_{i+1}^{n+1}-2u_{i}^{n+1}+u_{i-1}^{n+1}}{(\Delta x)^2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Remember what our goal here is: we want to compute the solution on the boundary, that is, at location [katex]i=5[/katex], in a way that imposes our Neumann boundary condition. Well, if we want to solve the above discretised form of the diffusion operator, we have the same issue as with the derivative of the Neumann boundary condition; we have a term that is evaluated at [katex]i+1[/katex] in our discretised equation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But, here comes the trick: We already know what [katex]u^{n+1}_{i+1}[/katex] is; we just derived an expression for it with the help of the Neumann boundary condition! So, we can insert this expression into our discretised form and have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{u^{n+1}_{i-1} + 2u_{Neumann}\Delta x -2u_{i}^{n+1}+u_{i-1}^{n+1}}{(\Delta x)^2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can now go about our usual business. First, let's collect unknowns (this time referred to as unknown in time again, i.e. all quantities at time level [katex]n+1[/katex]) again on the left-hand side and everything else on the right-hand side. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{u^{n+1}_{i-1} -2u_{i}^{n+1}+u_{i-1}^{n+1}}{(\Delta x)^2}=\frac{-2u_{Neumann}\Delta x}{(\Delta x)^2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's bring this again into coefficient form:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
u_{i}^{n+1}\left[\frac{-2}{(\Delta x)^2}\right] + u_{i-1}^{n+1}\left[\frac{2}{(\Delta x)^2}\right] = \frac{-2u_{Neumann}\Delta x}{(\Delta x)^2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can even clean up the right-hand side a bit if we want:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
u_{i}^{n+1}\left[\frac{-2}{(\Delta x)^2}\right] + u_{i-1}^{n+1}\left[\frac{2}{(\Delta x)^2}\right] = \frac{-2u_{Neumann}}{\Delta x} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is now the equation we have to solve on the boundary, in our example, at [katex]i=5[/katex]. Thus, in our coefficient matrix, we set [katex]A_{55}=-2/(\Delta x)^2[/katex] but now we also have to set [katex]A_{54}=2/(\Delta x)^2[/katex]. In the coefficient matrix [katex]\mathbf{A}[/katex], the row index is determined by the node (or cell) index, in this case [katex]i=5[/katex], and the column index is determined by the individual node/cell IDs within our discretised equation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, the coefficient for [katex]u_i^{n+1}[/katex] needs to be placed in column 5, because this velocity value is evaluated at location [katex]i[/katex]. But, the coefficient for [katex]u_{i-1}^{n+1}[/katex] (remember that this term is coming from the discretised equation for node [katex]i=5[/katex], so we are still in row 5) is evaluated at [katex]i-1=5-1=4[/katex], thus, we need to store the coefficient now at row 5 and column 4.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, in general, each row in a matrix represents a cell or node, and then any column in that row represents any neighbouring coefficients we have to set due to our stencil (in this case, we had [katex]i-1[/katex] in our stencil, and since the row is fixed to 5 as we are writing the discretised equation for node 5, and [katex]i-1[/katex] tells us in which column we have to place coefficients).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But that's it, this is how you impose Neumann boundary conditions. We can generalise this procedure as:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>First, discretise the Neumann boundary condition, i.e. the derivative at the boundary of interest, and solve it for the unknown variable that is beyond the boundary

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Next, discretise each operator at the boundary

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Insert the Neumann condition from the first step into your discretised operators at the boundaries

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Solve the modified discretisation at boundaries

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>There is one important consequence of this. Let's look at our sketched domain again. We said that we impose Dirichlet-type boundary conditions on the left side of the domain and Neumann-type boundary conditions on the right side of the domain. We saw that the Dirichlet-type boundary conditions only modify [katex]A_{11}[/katex], while the Neumann boundary conditions modified [katex]A_{55}[/katex] <strong>and</strong> [katex]A_{54}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Why is this important? Well, if you only use Dirichlet-type boundary conditions, and you implemented a simple equation, something like the heat diffusion equation, then you get a symmetric matrix. Symmetric matrices can be easily solved with something like a Conjugate Gradient method. But these Conjugate Gradient methods, while being extremely popular, require a symmetric matrix. If you now, all of a sudden, insert a Neumann boundary condition, your matrix becomes asymmetric, and your Conjugate Gradient solver goes on strike.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this case, this is easily fixed by using an extended Conjugate Gradient method, e.g. something like the Bi-Conjugate Gradient (Stabilised) versions (also often abbreviated to BiCGStab or BCGS), but it is one of these bugs where your solver is working fine, you haven't touched anything about the linear system of equation solver but you implement a new boundary condition and all of a sudden your solver stops working.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Naturally, you spend hours debugging your new implementation, which has nothing to do with the issue. It happened to me in the past, and I thought I would mention it here because that can easily trip someone up when using just the plan conjugate gradient method.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What about the advection (non-linear) term? Well, as it turns out, it is actually not that bad here. When it comes to CFD, and we want to simulate anything of engineering interest, we typically resort to an upwind discretisation here. For example, using a finite-difference approximation, we can discretise the advection term using a first-order upwind scheme as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
u\frac{\partial u}{\partial x} = \text{max}(u^n_i, 0)\frac{u^{n+1}_{i} - u^{n+1}_{i-1}}{\Delta x} + \text{min}(u^n_i, 0)\frac{u^{n+1}_{i+1} - u^{n+1}_{i}}{\Delta x} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, let's analyse this scheme for a moment, specifically, what happens on the right side of the domain. If we assume that the flow is coming in from the left side of the domain and then going to the right side of the domain, it stands to reason that the flow on the right side of the domain is leaving, not entering. We would only have flow entering the domain if we had reverse flow.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, as a rule of thumb, we should never place open boundaries like inlets and outlets near regions of flows that are still developing. So, for the sake of argument, let's say that the flow has developed and it is uniformly flowing out at the boundary. This means that the above discretisation can assume and [katex]u\gt 0[/katex]. This means [katex]\text{min}(u,0)[/katex] will always be 0 in this case on the boundary, and so we could write our discretised equation on the boundary as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
u\frac{\partial u}{\partial x} = \text{max}(u^n_i, 0)\frac{u^{n+1}_{i} - u^{n+1}_{i-1}}{\Delta x} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we make this assumption, then we no longer have any dependence on [katex]i+1[/katex]. It naturally vanishes if outflow is assumed and reverse flow is suppressed. In the opening of this article, I mentioned that ANSYS Fluent will allow you to suppress reverse flow by artificially implementing walls where reverse flow is detected. It does make sense all of a sudden, doesn't it? If we have no reverse flow, well, then the above discretisation is never violated, making our implementation effort really easy.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For completeness, I should add that there are other schemes that depend on upwinding, but have a larger stencil, and thus a dependence on [katex]i+1[/katex] may still exist near boundaries. For example, the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/#aioseo-muscl-scheme" target="_blank" rel="noopener" title="">MUSCL scheme</a> or <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/#aioseo-quick-scheme" target="_blank" rel="noopener" title="">QUICK scheme</a>, both of which we reviewed in the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/" target="_blank" rel="noopener" title="">numerical schemes article</a>, may have this dependence. If this is the case, we can opt for a lower-order scheme near the boundary to get rid of this dependence, or we can use the ghost cell approach, which we will look at in the next section.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, before we jump there, I want to comment on the finite-volume type of grid arrangement, that is, when the variables we are interested in are stored at cell centroids. Let's remind ourselves of the sketch I provided before for this case:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/implicit_boundary_condition_imposition_centroid_based.png" alt="A 1D domain with 6 nodes; 2 on the boundaries, and 43 on the internal domain. Dirichlet boundary conditions are applied on the left (first node), while Neumann boundary conditions are applied on the right (last node). Below the 1D domain is a sketch of the 4 by 4 coefficient matrix, the vector x, and the right-hand side b vector that would be used to solve the linear system Ax=b." class="wp-image-5550" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>If we are now on the right-hand side of the domain and we want to impose Neumann boundary conditions, then we proceed just like before, with minor adjustments.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For a diffusion-type operator, that is, a second-order derivative, we had the following finite-volume approximation (again, most commonly used for centroid-based discretisations):</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial^2 \phi}{\partial x^2}\rightarrow\int_V\frac{\partial^2 \phi}{\partial x^2}\mathrm{d}V=\int_S\vec{n}\cdot\frac{\partial \phi}{\partial x}\mathrm{d}S\approx\sum_k^{nFaces}\vec{n}\cdot\frac{\partial \phi}{\partial x}S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we discretise this operator on the right side of the domain, we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\sum_k^{nFaces}\vec{n}\cdot\frac{\partial \phi}{\partial x}S=(1)\frac{\partial \phi}{\partial x}\bigg|_{i+\frac{1}{2}}S+(-1)\frac{\partial \phi}{\partial x}\bigg|_{i-\frac{1}{2}}S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>However, you may already be ahead of everyone else and realise that the derivative [katex]\partial \phi/\partial x[/katex], which we evaluate at location [katex]i+1/2[/katex] is on the east boundary face. Since the Neumann boundary condition imposes a derivative at exactly that location, that is:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \phi}{\partial x}\bigg|_{east}=\frac{\partial \phi}{\partial x}\bigg|_{i+\frac{1}{2}}=\phi_{Neumann} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can simply substitute the Neumann boundary condition in this discretisation and get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\sum_k^{nFaces}\vec{n}\cdot\frac{\partial \phi}{\partial x}S=(1)\phi_{Neumann}S+(-1)\frac{\partial \phi}{\partial x}\bigg|_{i-\frac{1}{2}}S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we can carry out the rest of the discretisation. First of all, let's discretise the derivative in the second term as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \phi}{\partial x}\bigg|_{i-\frac{1}{2}}\approx\frac{\phi_i^{n+1}-\phi_{i-1}^{n+1}}{\Delta x} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Inserting this results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\sum_k^{nFaces}\vec{n}\cdot\frac{\partial \phi}{\partial x}S=(1)\phi_{Neumann}S+(-1)\frac{\phi_i^{n+1}-\phi_{i-1}^{n+1}}{\Delta x}S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now let's collect terms again and place unknowns on the left-hand side and knowns on the right-hand side:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_i^{n+1}\left[\frac{-S}{\Delta x}\right] + \phi_{i-1}^{n+1}\left[\frac{S}{\Delta x}\right] = -\phi_{Neumann}S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we can insert that again into our coefficient matrix as [katex]A_{55}=-S/\Delta x[/katex], [katex]A_{54}=S/\Delta x[/katex], and into our right-hand side vector [katex]b_5=-\phi_{Neumann}S[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What about first-order derivatives? Well, we had the following discretisation for a finite-volume-based discretisation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \phi}{\partial x}\rightarrow \int_v\frac{\partial \phi}{\partial x}\mathrm{d}V = \int_S\vec{n}\cdot \phi \mathrm{d}S\approx \sum_k^{nFaces}\vec{n}_k\cdot\phi_k\cdot S_k </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's write out the summation for our 1D example. We get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\sum_k^{nFaces}\vec{n}_k\cdot\phi_k\cdot S_k=(1)\phi_{i+\frac{1}{2}}S+(-1)\phi_{i-\frac{1}{2}}S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Cleaning up the right-hand side, we can further simplify this as (I think simplify is a strong word here!):</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\sum_k^{nFaces}\vec{n}_k\cdot\phi_k\cdot S_k=\phi_{i+\frac{1}{2}}S - \phi_{i-\frac{1}{2}}S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now the central question here is how do we approximate [katex]\phi[/katex] on the boundary, that is, at location [katex]i+1/2[/katex]. If we use an upwind discretisation again, then the same discussion as before applies. We can assume the flow has fully developed, and so, upwinding would then dictate, for a first-order approximation, that [katex]\phi_{i+1/2}^{n+1}=\phi_{i}^{n+1}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When upwinding is involved, Neumann boundary conditions typically do not pose any issues, as we assume that the upwind direction is into the domain, and so all variables we need in our stencil are located inside the domain, not outside.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But let's assume we are dealing with the divergence operator or pressure gradient. In this case, we do not typically use upwinding, and so our stencil may still include values that go beyond our boundary. For example, for the divergence ([katex]\nabla\cdot \mathbf{u}[/katex]) or pressure gradient ([katex]\nabla p[/katex]), both of which result in first-order derivatives, we typically use the central scheme to approximate their values at faces. For location [katex]i+1/2[/katex], we may write:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_{i+\frac{1}{2}}=\frac{\phi_i^{n+1} + \phi_{i+1}^{n+1}}{2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>So now, we have again a dependence on [katex]i+1[/katex], which we need to get rid of. We use, again, the definition of the Neumann boundary condition to do so. First, we write out the discretised operation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \phi}{\partial x}\approx \frac{\phi_{i+1}^{n+1}-\phi_i^{n+1}}{\Delta x}=\phi_{Neumann} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Solving this for the value at [katex]i+1[/katex] results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_{i+1}^{n+1} = \phi_i^{n+1} + \phi_{Neumann}\Delta x </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can insert this into our central scheme and obtain:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_{i+\frac{1}{2}}=\frac{\phi_i^{n+1} + \phi_{i+1}^{n+1}}{2} = \frac{\phi_i^{n+1} + \phi_i^{n+1} + \phi_{Neumann}\Delta x}{2} = \frac{2\phi_i^{n+1} + \phi_{Neumann}\Delta x}{2} = \phi_i^{n+1} + \frac{\phi_{Neumann}\Delta x}{2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can insert this into our discretised equation and obtain:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\sum_k^{nFaces}\vec{n}_k\cdot\phi_k\cdot S_k=\phi_{i+\frac{1}{2}}^{n+1}S - \phi_{i-\frac{1}{2}}^{n+1}S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\sum_k^{nFaces}\vec{n}_k\cdot\phi_k\cdot S_k = \left(\phi_i^{n+1} + \frac{\phi_{Neumann}\Delta x}{2}\right)S - \phi_{i-\frac{1}{2}}^{n+1}S </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>To approximate [katex]\phi_{i-1/2}^{n+1}[/katex], we use the central scheme again and get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_{i-\frac{1}{2}}=\frac{\phi_i^{n+1} + \phi_{i-1}^{n+1}}{2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Inserting this into our discretisation results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\left(\phi_i^{n+1} + \frac{\phi_{Neumann}\Delta x}{2}\right)S - \frac{\phi_i^{n+1} + \phi_{i-1}^{n+1}}{2}S=0 </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can now sort this equation again and store knowns on the right-hand side and unknowns on the left-hand side, which gives us:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_i^{n+1} S - \frac{\phi_i^{n+1} + \phi_{i-1}^{n+1}}{2}S=-\frac{\phi_{Neumann}S\Delta x}{2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Writing this in coefficient form results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_i^{n+1}\left[\frac{S}{2}\right] + \phi_{i-1}^{n+1}\left[\frac{-S}{2}\right]=-\frac{\phi_{Neumann}S\Delta x}{2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>And so, we have found our matrix coefficients and right-hand side vector again, with [katex]A_{55}=S/2[/katex], [katex]A_{54}=-S/2[/katex], and [katex]b_5=-\phi_{Neumann}S\Delta x/2[/katex], respectively.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In some cases, you may come across a different derivation. For example, we can arrive at exactly the same discretised equation on the boundary by assuming that the Neumann boundary condition can be discretised as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \phi}{\partial x}\approx\frac{\phi_{i+\frac{1}{2}}-\phi_i}{\Delta x/2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, instead of taking the derivative between [katex]i[/katex] and [katex]i+1[/katex], over a cell distance [katex]\Delta x[/katex], we say that we evaluate the derivative between [katex]i[/katex] and [katex]i+1/2[/katex], i.e. half a cell distance [katex]\Delta x/2[/katex]. If you solve this now for [katex]\phi_{i+1/2}[/katex], you can directly insert that into the discretised equation, no need to first compute [katex]\phi_{i+1/2}[/katex] through a central interpolation scheme.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You will obtain exactly the same results, I thought I just mentioned it here, as some people will derive it this way.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Good, I think this should give you sufficient knowledge for how to implement boundary conditions using either Dirichlet-type or Neumann-type boundary conditions. If you have to implement Robin-type boundary conditions, well, then you simply have to mix both Dirichlet and Neumann together. This will result in more terms, but the methodology is exactly the same as what we have discussed; the only difference being that you will now have contributions due to Dirichlet <strong>and</strong> Neumann in your coefficient matrix and right-hand side vector.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now that we have an idea of what it takes to implement these conditions without modifying our mesh, I want to now look at the ghost cell approach and discuss how we can implement Dirichlet and Neumann boundary conditions here.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-implicit-time-integration-with-the-ghost-cell-approach">Implicit time integration with the ghost cell approach</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>If you were reading the article thus far and you were really getting into the ghost cell approach, then I have bad news for you! They don't work for implicit time integration schemes, or at least not without (severe?!) limitations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's remind ourselves what we did in explicit schemes, and let's use our 1D domain again as an example, as sketched now with ghost cells below:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"700px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/ghost_cells_implicit_time_integration.png" alt="A 1D domain showing the ghost cell approach with one ghost cell beyond the left and right boundary, respectively. It is indicated that a Dirichlet-type boundary condition is used on the left, while a Neumann-type boundary condition is used on the right." class="wp-image-5550" style="width:700px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Let's start on the left with our Dirichlet-type boundary conditions, where we want to impose [katex]\phi_0=\phi_{Dirichlet}[/katex]. When we were dealing with the ghost cell approach previously, I said that we can impose this value implicitly by enforcing the following condition:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_{Dirichlet}=\frac{\phi_{-1}+\phi_1}{2} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can solve this for our ghost cell now:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_{-1}=2\phi_{Dirichlet} - \phi_{1} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In our simulation, this is what we do, i.e. we set the value of the ghost cell for each (explicit) time step and then the value [katex]\phi_0[/katex] will automatically contain the value [katex]\phi_{Dirichlet}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On the right of the domain, where we want to impose Neumann-type boundary conditions, we can first discretise our Neumann-type boundary condition on the right of the domain as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial \phi}{\partial n}=\phi_{Neumann}\rightarrow \frac{\phi_{NX+1}-\phi_{NX-1}}{2\Delta x}=\phi_{Neumann} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We then solve this again for our ghost cell:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\phi_{NX+1} = 2\Delta x\phi_{Neumann} + \phi_{NX-1} </pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is what we, again, impose on our solution vector, and this will then ensure that [katex]\phi_{NX}[/katex] receives the correct boundary treatment. For this reason, ghost cells are a very lucrative approach, as they essentially require you to only modify some value beyond your domain (which you would not export as part of the solution anyway); they are just there to help us compute the solution. For the rest of the computation, we can just treat our domain as if it didn't have any boundary conditions, which makes our life extremely easy.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, but here is the problem: Notice how we always update [katex]\phi[/katex] directly. In our linear system of equations, i.e. [katex]\mathbf{Ax}=\mathbf{b}[/katex], we have that [katex]\phi=\mathbf{x}[/katex], that is, [katex]\mathbf{x}[/katex] is the vector containing the solution. When we solve [katex]\mathbf{Ax}=\mathbf{b}[/katex], we have to do so iteratively. At each iteration, the solution vector [katex]\mathbf{x}[/katex] is updated. All of its values. So, if we set part of this vector to contain a specific value at the beginning of the iterative process, those values will eventually be lost.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>One could think of imposing or fixing these ghost cell values, then at each iteration, but that would mean that your iterative algorithm would now also have to handle boundary conditions, and generalising that isn't straightforward. Furthermore, it would also mean that you couldn't use any off-the-shelf algorithms to solve [katex]\mathbf{Ax}=\mathbf{b}[/katex], and we really like to use efficient libraries to do that for us when writing our own CFD solvers.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, I said that ghost cells can be combined with implicit time integration methods, but that their use is severely limited. The limited application areas where it does work are in the area of matrix-free algorithms. These algorithms, surprise surprise, do not form the matrix [katex]\mathbf{A}[/katex] explicitly. This has various advantages, mostly that you don't have to store the matrix in memory, but, as with everything, there are trade-offs. Yes, we don't need to store the matrix, but that means we have to repeatedly compute its coefficient at every time step.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Furthermore, we have gained so much experience with solving [katex]\mathbf{Ax}=\mathbf{b}[/katex], and the verdict is that matrix-free algorithms, such as the Jacobi or Gauss-Seidel (with or without successive overrelaxation (SOR)), belong in the classroom, not in your CFD solver. It is easy to get started with them, and you can quickly solve your own linear system of equations, and for that, they are brilliant, but don't write a CFD solver using the Jacobi method, please! (and please don't tell my former PhD supervisor that I said this, it'll be our secret!)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>No, the gold standard are Krylov subspace methods, like the Conjugate Gradient method (and its derivatives), Generalised Minimal Residual (GMRES), or methods falling under the Multigrid umbrella (and there are several variations, including combinations with Krylov subspace methods). Don't let other people tell you otherwise; people have strong opinions on this matter (I just noticed that I also told you what to believe, so, perhaps, if you take my advice, don't listen to me, I suppose?)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, what is the solution then? What if you really want to use ghost cells in your solver? Well, the solution is simple: Either limit yourself to matrix-free algorithms, which also means you have to implement the whole [katex]\mathbf{Ax}=\mathbf{b}[/katex] solving part yourself, or continue to use ghost cells, but switch to a non-ghost cell approach for all implicit calculations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, if you write an incompressible Navier-Stokes solver using explicit time integration, you may only need to solve the pressure Poisson solver with an implicit system. Actually, I just realised this is exactly what I did in my PhD (ghost cells + explicit time integration + matrix-free Gauss-Seidel for the pressure Poisson solver). It works, it satisfies your supervisor's strong opinions about how to solve the pressure Poisson solver, and you are allowed to graduate.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I exaggerate here a bit; I was allowed to use other methods, but to this day, I have a (friendly) disagreement about how to solve linear systems of equations and still I debate this topic every now and then with my former supervisor (and I'm glad we do!). In fairness, this disagreement led to a new incompressible algorithm in which we discovered a new governing equation for the pressure, and it worked really well. I probably still need to publish that eventually ...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In any case, this should be it for our discussion on treating boundary conditions for implicit systems of equations. Let's now discuss what I like to call derived boundary conditions, i.e. those that you would typically set in a general-purpose CFD solver.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-derived-boundary-conditions">Derived boundary conditions</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Up until this point, we have only really touched upon Dirichlet-type and Neumann-type boundary conditions, as well as Robin-type as a combination of the two. This is really all that you need. If you are working with OpenFOAM, for example, you have countless of boundary conditions to choose from, but if you know these three fundamental types of boundary conditions, you can set up any flow problem.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you are going for a commercial solver, they typically want to make your life as easy as possible and don't have you think about what is Dirichlet and what should be Neumann. Instead, they provide abstract versions of these, which you will know under names such as Inlet, Outlet, Walls, Symmetry, Periodic or Cyclic, and so on.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So in this section, I want to shine a light on these boundary conditions and show what type of boundary conditions are actually solved here in terms of Dirichlet and Neumann. This can also help you write your own solver so you know what type of boundary conditions to impose in terms of Dirichlet and Neumann.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-solid-boundary-conditions">Solid boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The first boundary condition we want to look at is solid boundary conditions. These are boundary conditions where flow cannot penetrate through the boundary, and typically, when we talk about solid boundary conditions, we refer to walls. But there are different types of wall boundary conditions, so let's review them here.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-wall">Wall</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The first type is the wall itself. We have already briefly discussed it before, but for completeness, I want to introduce it again here. At the wall, the velocity has to come to rest, and this means that all velocity components have to be zero for a stationary wall or the same speed as the wall if it is moving. The pressure develops at the wall, so we don't know its values before we run the simulation, so we cannot impose the pressure here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we are dealing with the energy equation as well, that is, we are solving for the temperature, then we have two options. We can either set a constant temperature [katex]T[/katex] or impose a heat flux. If the heat flux is set to zero, we have an adiabatic system (no heat is transferred between our fluid and the wall itself). Depending on our sign convention, we may have heating for a positive heat flux or cooling for a negative heat flux.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can summarise a wall boundary condition as:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet, with [katex]u=v=w=u_{wall}[/katex]. For stationary walls, we have [katex]u_{wall}=0[/katex]</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann, with [katex]\partial p/\partial n=0[/katex]</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>:<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Dirichlet for constant temperature</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Neumann for adiabatic walls with [katex]\partial T/\partial n=0[/katex]</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Neumann for heating with [katex]\partial T/\partial n&gt;0[/katex]</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Neumann for cooling with [katex]\partial T/\partial n&lt;0[/katex]</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-symmetry">Symmetry</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The symmetry condition can be somewhat confusing. Yes, if we mirror the flow at the symmetry plane, we get a mirror image of the flow. But that is also true for all other boundary conditions, so this is not a very effective name in my view. Instead, I find it best to think of symmetry boundary conditions as a frictionless wall or a slip wall.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Essentially, a symmetry boundary condition is a solid wall as well, so no fluid can penetrate through it, with the exception that the velocity in the parallel direction of the symmetry boundary plane is treated as a Neumann boundary condition rather than a Dirichlet boundary condition. This means that we have</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet for [katex]\mathbf{u}_\perp=0[/katex] and Neumann for [katex]\partial\mathbf{u}_\parallel/\partial \mathbf{x}_\parallel=0[/katex]. Here, [katex]\perp[/katex] and [katex]\parallel[/katex] are the normal and parallel direction at the boundary. We used [katex]n[/katex] before to denote the normal direction at the wall, which is equivalent to the [katex]\perp[/katex] direction, and [katex]\parallel[/katex] is tangential/parallel to the symmetry boundary face.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>All other variables</strong>: [katex]\partial\phi/\partial n=0[/katex]</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-open-boundary-conditions">Open boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Open boundary conditions start to break things and will cause you headaches. As a general rule, place these boundaries as far away as possible from any object of interest so that they do not influence the flow near that object. If you can't do that, then check that your open boundaries do not adversely influence the results.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-periodic">Periodic or cyclic</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>These are the simplest open boundaries to implement. Assuming that your domain does indeed feature a periodic pattern, and it is suitable to consider just one instance and replace the boundaries with periodic boundaries, then these open boundary conditions are the only ones that will not adversely affect your simulation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It is a popular boundary condition for turbulent flows, where we say that whatever goes out on one side of the domain has to go in on the opposite side of the domain. This requires that boundaries are parallel to each other and flat.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's consider a simple example of a 1D case to see how we can implement them. You will have two boundaries, one on the left side and one on the right side. Let's say that we have 10 vertices (finite difference) or 10 cells (finite volume), and let's write the number of cells with the variable [katex]N=10[/katex]. Then, we can establish the following index:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>i\,\%\,N</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]\%[/katex] is the modulo operator, which will return the remainder of the division of [katex]i/N[/katex]. For example, [katex]5%10=5[/katex]. [katex]5/10=0[/katex] with a remainder of [katex]5[/katex]. Or take another example, [katex]5%2=1[/katex]. We can divide 5 by 2 exactly two times, this leaves a remainder of 1. So how does it relate to periodic boundary conditions?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's consider the 1D heat diffusion equation with explicit time integration, This can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>T_i^{n+1}=T_i^n+\alpha\frac{T_{(i+1)\%N}^n-2T_i^n+T_{(i-1)\%N}^n}{\Delta x^2}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, instead of [katex]T_{i+1}^n[/katex] and [katex]T_{i-1}^n[/katex], I wrote [katex]T_{(i+1)\%N}[/katex] and [katex]T_{(i-1)\%N}[/katex]. We said that [katex]N=10[/katex], so let's see what happens for [katex]i=8[/katex]. We have [katex]8%N=8%10=8[/katex]; 10 does not fit into 8, so we have a remainder of 8. So [katex](i+1)\%N=(8+1)\%10=9\%10=9[/katex]. Similarily, [katex](i-1)\%N=7[/katex]. So these two statemets still return [katex]T_{i+1}[/katex] and [katex]T_{i-1}[/katex], respectively.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This only becomes important at the boundaries. So let's set [katex]i=N=10[/katex]. We are now on the boundary vertex/cell, and we know there is no more vertex/cell to the right. Thus, [katex]i+1=10+1=11[/katex] does not exist as a location, as we only have [katex]N=10[/katex] vertices/cells. But, if we evaluate now [katex](i+1)\%N[/katex], we get [katex](10+1)\%10=11\%10=1[/katex]. 11 divided by 10 is 1, with a remainder of 1.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On the left boundary, we have a similar situation. Here, we have [katex](i-1)\%N=(0-1)\%10=-1[/katex]. Hmm, that looks strange. The location [katex]i=-1[/katex] does not exist and is beyond the left side of the domain. There are two ways to deal with this. We can check each index and then add [katex]N[/katex] whenever we have a negative number. In this case, we would have [katex]-1+N=-1+10=9[/katex], which is the vertex/cell one unit to the left on the right boundary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Alternatively, we can also simply add [katex]N[/katex] to all of our stencils. For example, in the previous example, we would modify this to [katex](i-1+N)\%N=(0-1+10)\%10=9\%10=9[/katex]. For the example on the right boundary, we would get [katex](i+1+N)\%N=(10+1+10)\%10=(21)\%10=1[/katex]. In the last case, we still get 1. Even though we added [katex]N[/katex], it doesn't change the result, as the modulo operator [katex]\%[/katex] returns the remainder, not the actual result of the division. The remainder will not change if we add multiples of [katex]N[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, by using the modulo operator, we can simply implement boundary conditions without even being aware that they are there. While we haven't used Dirichlet-type or Neumann-type boundary conditions here explicitly, since we are setting values beyond the boundaries to know values, periodic boundary conditions can be understood to be of type Dirichlet for all quantities that we are solving for.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-the-importance-of-characteristics-on-open-boundary-conditions">Differences in open boundary conditions based on the Mach number</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>No all boundary conditions are created equal. Depending on the local Mach number, the flow's behaviour will change. For example, for subsonic flows where the Mach number is below one, the pressure behaves in an <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-elliptic-flows" target="_blank" rel="noopener" title="">elliptic manner</a>, meaning that pressure disturbances are instantaneously propagated through the domain. This allows streamlines to start curving away from objects like airfoils before the flow has even reached these objects.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once we go supersonic, the behaviour of the Navier-Stokes equation changes, and we get a <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-hyperbolic-flows" target="_blank" rel="noopener" title="">hyperbolic behaviour</a>. Now there is a defined direction of travel, and the pressure, for example, is no longer propagating instantaneously. So, for the airfoil example, it will only see the airfoil when it reaches it, causing an instant shock wave to form at the leading edge (depending on the shape of the airfoil, or in general, of the object, we may get a detached bow shock instead).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Since the behaviour of the flow changes as we go from subsonic ([katex]Ma&lt;1[/katex]) to supersonic ([katex]Ma\ge 1[/katex]), so does the behaviour on the boundary, and so we need to account for that in our boundary conditions. In general, we have the following requirements on open boundaries for subsonic flows ([katex]Ma&lt; 1[/katex]):</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Inlet:<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>All boundary conditions are known and imposed as Dirichlet-type boundary conditions except for one.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>One boundary condition needs to be of type Neumann.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Outlet:<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>All boundary conditions are unknown and imposed as Neumann-type boundary conditions except for one.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>One boundary condition needs to be of type Dirichlet.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>In contrast, for supersonic boundaries ([katex]Ma\ge 1[/katex]), we have:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Inlet:<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>All boundary conditions are known and imposed as Dirichlet-type boundary conditions.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Outlet:<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>All boundary conditions are unknown and imposed as Neumann-type boundary conditions.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>The reason this changes has to do with <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-precurser" target="_blank" rel="noopener" title="">the characteristics of the flow</a>. They change their behaviour on open boundaries as the flow changes from a mixed-elliptic hyperbolic (subsonic) flow to a fully hyperbolic (supersonic) flow. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For subsonic (e.g. incompressible) flows, all but one characteristics are pointing into the domain. We impose values for these using Dirichlet-type conditions, but there is one characteristic that points outwards, and so we don't know its value, and we have to impose that as a Neumann-type boundary condition. At the outlet, all but one characteristics point outwards, so we impose Neumann for them and one characteristic points into the domain, so we impose a Dirichlet type for it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For supersonic (e.g. compressible) flows, this changes to all characteristics either pointing into the domain at the inlet, so we apply Dirichlet-type boundary conditions to all variables, or out of the domain at the outlet, so we apply Neumann-type boundary conditions to all variables.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We'll have to keep this in mind for the remaining discussion, as boundary conditions will slightly change for the type of flow we have at hand.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-freestream-or-farfield">Freestream or farfield</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Having gone through the above discussion, we are going to discuss an exception immediately. Freestream or farfield conditions are fully Dirichlet-type conditions. That is, we set values for all variables at both the inlet and the outlet. How can we do that? Well, consider an aircraft flying in cruise condition. If we wanted to model this, and we placed a domain around the aircraft that is, say, 10 km wide in each direction, we can probably assume that if we are far enough away from an object in an external flow scenario, we have reached atmospheric conditions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, the wake of the aircraft may have dissipated into heat and is no longer there, while the flow near the outlet will have returned to its original state. So if we place the boundaries very far away from the object that we are investigating, then farfield boundary conditions are not a bad starting point. This implies that we have open boundaries on all sides, i.e. we can't use freestream or farfield boundary conditions for internal flows.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>They are popular for aeronautical cases, e.g. airfoils, aircraft, and similar applications. But these are the exception to the rule, and, due to their requirement of no solid boundaries in the farfield, we can only use them for specific applications. If we want to have a more general open boundary condition, then we need to treat inlets and outlets separately so we can account for incoming and outgoing characteristics.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For completeness, let's write out the boundary conditions. We have for both inlets and outlets:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Dirichlet</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Dirichlet</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-inlet">Pressure or velocity inlet</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The pressure or velocity inlet, as the name suggests, specifies a value for either the pressure or velocity. This is imposed as a Dirichlet boundary condition. If we are dealing with an incompressible flow, we only need to consider the velocity and pressure, and we remember from our discussion above that for subsonic flows (all incompressible flows must be subsonic by definition), we need to specify at least one Neumann-type condition. For compressible flows, we have to specify Dirichlet-type boundary conditions everywhere.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We typically specify the velocity if we want to achieve a certain flow rate or Reynolds number. A pressure inlet, on the other hand, is typically used with a pressure outlet, where we specify a pressure gradient between the inlet and outlet. By knowing the length of the domain [katex]L_{domain}[/katex], we can compute the pressure gradient [katex]\nabla p[/katex] as [katex]\nabla p=(p_{inlet}-p_{outlet}/L_{domain})[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, for an <strong>incompressible </strong>flow, we impose the following conditions for a <strong>velocity inlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet for all velocity components [katex]u[/katex], [katex]v[/katex], and [katex]w[/katex].</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann, typically [katex]\partial p/\partial n=0[/katex].</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Either Dirichlet if the temperature at the inlet is known or Neumann if it is unknown.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>For an <strong>incompressible </strong>flow, we impose the following conditions for a <strong>pressure inlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Neumann for velocity normal to inlet, i.e. [katex]\partial u_{\perp}/\partial x_\perp=0[/katex], Dirichlet for all tangential velocities, i.e. [katex]u_\parallel=0[/katex].</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Dirichlet</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: The same as for the velocity inlet, Dirichlet if temperature is known, Neumann if it isn't.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>For a <strong>subsonic, compressible</strong> flow, i.e. [katex]Ma&lt;1[/katex], we can impose either a <strong>velocity inlet</strong> or <strong>pressure inlet</strong> boundary condition as seen above. For a <strong>supersonic, compressible </strong>flow, i.e. [katex]Ma\ge 1[/katex], we impose the following conditions at the <strong>inlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Dirichlet</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Dirichlet</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>We do not differentiate between velocity and pressure inlets for compressible flows as all characteristics point into the domain. Thus, all quantities have to be specified.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-outlet">Pressure or velocity outlet</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The pressure or velocity outlet is the opposite to the corresponding inlet, in many ways, i.e. we prescribe either one velocity component or the pressure at the outlet, at least for incompressible flows. For compressible flows, we would specify Neumann-type boundary conditions for all variables.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For incompressible flows, we need to be careful with the pairing of inlets and outlets as well. If we use a velocity inlet, for example, we specify Neumann-type boundary conditions for the pressure. If we now also set the outlet to a velocity outlet, then we use Neumann-type boundary conditions again for the pressure. If we now have some walls as well in the domain, then we have further Neumann-type boundary conditions for the pressure. This is a problem.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Why? Well, we saw before that Neumann-type boundary conditions really just copy values from the internal domain and they set them at the boundaries. If all of our boundaries use a Neumann-type boundary condition, then the pressure is allowed to increase without bounds (and it will). In order to avoid this issue, we typically have to specify the value of the pressure in one cell, and then we ensure that this pressure is set for this one cell. In this way, we fix the pressure not through boundary conditions but instead through a single cell or a volume condition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To avoid this issue, we can simply pair a velocity inlet with a pressure outlet, where we prescribe, for example, the ambient pressure at the outlet as a Dirichlet-type boundary condition. This is a common combination if we are using a velocity inlet. If we use a pressure inlet, we can still use a pressure outlet, as we prescribe now both pressure values as a Dirichlet-type boundary condition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, for an <strong>incompressible </strong>flow, we impose the following conditions at the <strong>velocity outlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: One component Dirichlet, typically the velocity component normal to the boundary face, the remaining components are Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Neumann</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>For an <strong>incompressible</strong> flow, we impose the following conditions at the <strong>pressure outlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Neumann for all velocity components</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Dirichlet, typically ambient pressure</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Neumann</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>For a <strong>subsonic, compressible</strong> flow, i.e. [katex]Ma&lt;1[/katex], we can either impose a <strong>velocity outlet</strong> or <strong>pressure outlet</strong> as seen above. For a <strong>supersonic, compressible</strong> flow, i.e. [katex]Ma\ge 1[/katex], we impose the following conditions at the <strong>outlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Neumann</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>I should mention here that, while technically possible, the velocity outlet is rarely used. It does have the issue of potentially having a fully Neumann-type boundary condition for the pressure, and thus, the pressure outlet is typically preferred.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-advective-outlet">Advective outlet</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Thus far, we have only really discussed one type of boundary condition at the outlet, i.e. a combination of Dirichlet and Neumann boundary conditions. But in specific cases, we can impose a third type (or fourth, if you want to count Robin-type boundary conditions as well). This is to solve an advection equation at the outlet. In particular, this is the equation we are solving for the outlet:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial t}+u_\perp\frac{\partial \phi}{\partial n}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]u_\perp[/katex] is the normal velocity at the outlet, and [katex]\partial \phi/\partial n[/katex] is the derivative of [katex]\phi[/katex] (velocity, pressure, temperature, etc.) at the outlet and it is normal/perpendicular to the boundary face. If we discretise this equation with a finite-difference approximation, for example, we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\phi^{n+1}_{i}-\phi_i^n}{\Delta t}+u_i^n\frac{\phi_i^n-\phi^n_{i-1}}{\Delta x}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, I have used a backward approximation for the derivative. Let's assume that the vertex on the boundary is located at location [katex]i[/katex], so that location [katex]i-1[/katex] is on the internal fluid domain. If the boundary was located on the left side of the domain, then we would use a forward derivative in space, which we would evaluate at locations [katex]i[/katex] and [katex]i+1[/katex], respectively.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we solve this equation now for [katex]\phi_i^{n+1}[/katex], we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_i^{n+1}=\phi_i^n-u_i^n\frac{\Delta t}{\Delta x}\left(\phi_i^n-\phi^n_{i-1}\right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Thus, by knowing the values of [katex]\phi_i^n[/katex] and the velocity normal at the boundary [katex]u_i^n[/katex] from the previous time step (or the values obtained from the initialisation if it is the first time step), we can compute the values for [katex]\phi_i^{n+1}[/katex] for the next time step.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You might be asking yourself, why would we go through the trouble of doing this? Well, the outlet conditions we have discussed in the previous section are so-called reflective boundary conditions, while the advective type discussed in this section are so-called non-reflective type boundary conditions. They do pretty much what their name suggests, but I think a video that shows both types in action will likely be more explanatory. Can you guess which type was used for the top and bottom domain?</p>
<!-- /wp:paragraph -->
 
<iframe src="https://www.youtube.com/embed/J-52qLLDku4?si=2hRCIenaiVcvP6eF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen style="width:100%; aspect-ratio:16/9; border:0;"></iframe>

<!-- wp:paragraph -->
<p>Here, we see some pressure waves being advected by the flow. The top domain uses a pressure outlet of some sort (reflective), while the bottom domain uses an advective outlet (non-reflective).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Using one or the other will depend on your given flow problem. Reflective boundary conditions can sometimes lead to slower convergence, though this may be necessary to properly simulate the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-elliptic-flows" target="_blank" rel="noopener" title="">elliptic nature of the pressure</a>. This, in turn, can influence the simulations and produce correct physical results that may not be obtained with an advective-type outlet condition, even though convergence may be accelerated.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Generally speaking, since all characteristics point outwards for compressible, supersonic flows, advective boundary conditions can be used here to ensure that no flow is entering back into the domain. This aligns with the physical expectation of a <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-hyperbolic-flows" target="_blank" rel="noopener" title="">hyperbolic flow</a>, and thus, correct physics can be reproduced while convergence may also be accelerated.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If this boundary condition is used for compressible flows, we can replace the normal velocity component [katex]u_\perp[/katex] with the largest eigenvalue given by [katex]u_\perp + a[/katex], where [katex]a[/katex] is the speed of sound.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-mass-flow">Mass-based or volume-based inlets and outlets</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Finally, we can also compute the inlet or outlet velocity by imposing a specific mass or volume flow rate. The volume flow rate can be computed as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\dot{V}=u_\perp\cdot A</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]u_\perp[/katex] is again the velocity component normal/perpendicular to the boundary, while [katex]A[/katex] is the surface area of the boundary. This will give us a flow rate in units of [katex]m^3/s[/katex]. For an incompressible flow, where the density remains constant, this is a good boundary condition, but for compressible flows, we may want to bring in the density as well. If we multiply the volume flow rate by the density, we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\dot{m}=\rho \cdot u_\perp\cdot A</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This will give us a mass flow rate at either the inlet or the outlet. If the volume flow rate is given in units of [katex]m^3/s[/katex], multiplying this by the density gives us [katex](m^3/s)(kg/m^3)=kg/s[/katex]. Because of this unit, we call it the mass flow rate.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can modify both the volume flow rate and the mass flow rate to the following equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u_\perp = \frac{\dot{V}}{A}\\[0.5em]
u_\perp =\frac{\dot{m}}{\rho \cdot A}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Thus, if we want to impose a volume or mass flow rate, we really just specify the velocity again as a Dirichlet boundary condition. This has some advantages and disadvantages.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The disadvantage is that we now potentially get a fully Neumann-type boundary condition for the pressure if we deal with subsonic speeds. This is typically the case, as volume flow rate and mass flow rate boundary conditions are typically used for internal flows, such as the flow through pipes and channels, which are <em>rarely</em> supersonic. So we have to use our little trick again of fixing the pressure in one cell to a specific value, i.e. we impose a volume condition for the pressure.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The advantage, however, is that by imposing a mass flow rate and using this boundary condition exclusively for open boundaries, we can ensure that mass is conserved in our domain. What goes in has to leave, and this means our continuity equation will be happy and converge, potentially, better.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, if we do not use mass flow rate boundary conditions and opt for a combination of velocity inlets and pressure outlets, there is no guarantee that we will conserve mass in our domain. If we are using an unstructured grid with tetrahedron or polyhedron elements, then we are inducing numerical diffusion. Combining that with a low-order upwind-based scheme, we will diffuse the results even further. This will artificially slow down the flow, and this leads to a reduced velocity at the outlet, which will not conserve mass.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, the remedy here is that we simply look at the ratio of the computed mass flow rate at the inlet and outlet and multiply the velocities at the outlet by that value. This can be given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\dot{m}_{in}=\rho \cdot u_{in}\cdot A\\[0.5em]
\dot{m}_{out}=\rho \cdot u_{out}\cdot A\\[0.5em]
r_m=\frac{\dot{m}_{in}}{\dot{m}_{out}}\\[0.5em]
u_{out, corrected}=u_{out}\cdot r_m</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The first three equations here are computed once (i.e. we compute the mass flow rate once at the inlet, once at the outlet, and we compute the ratio once). We then use this ratio to compute a corrected outlet velocity [katex]u_{out, corrected}[/katex]. In this way, we ensure mass is conserved.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, regardless of which boundary condition pairing we are using, we run into trouble. Pure velocity inlet and outlet conditions, such as those given by the mass flow inlet and outlet, result in a fully Neumann-type boundary condition for the pressure, and we have to fix the pressure through other means. A combination of velocity inlet and pressure outlet will avoid the issue with the pressure, but we now have to start adjusting the mass flow rate through velocity scaling.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For completeness, the boundary conditions for a mass or volume flow inlet are given as:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet (see equations above for how to calculate the velocity)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Dirichlet or Neumann, depending on whether a constant temperature should be imposed or if the temperature is unknown at the inlet.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>At the outlet, we would impose the following conditions:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet (again, see equations above for how to calculate the velocity)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Neumann</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>While we could also state the boundary conditions for a supersonic compressible flow (i.e. fully Dirichlet at the inlet and fully Neumann at the outlet), I'll refrain from doing so, as I can't really think of an application where this would be useful. If you know of an application, let me know, and I'll happily change the text here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the end, open boundaries will always pose some challenges, and our choices can have a noticeable influence on the results. We always need to verify that our boundary conditions are doing what we want them to, and a lot of issues with simulations can be traced back to incorrect boundary conditions. I think you get the point; I'll leave it at that!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-summary">Summary</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>You survived my boundary condition rant. Congratulations. We started by looking at some of the challenges we face with boundary conditions, in particular with open boundary conditions. Then, we reviewed the three fundamental types that exist: Dirichlet, Neumann, and Robin-type boundary conditions. We also looked at the two different ways to implement them, either through no mesh modification or using ghost cells.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We then put that theoretical knowledge into practice. We reviewed derived boundary conditions, such as solid walls, symmetry planes, and various inlets and outlets, along with some modelling issues that we face based on how we want to treat our open boundary conditions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Boundary conditions only get more complicated as we increase the modelling complexity. The more we want to resolve, the more unknown quantities we have to prescribe at the inlet for which we typically don't have any reasonable values or estimates at hand. Scale-resolved turbulence modelling is the prime example here. Imposing physically correct fluctuations at the inlet for Large-eddy Simulations (LES) and Direct Numerical Simulations (DNS) are still unsolved questions, even though some progress has been made here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you experience convergence issues and you are happy it is not due to your mesh, then check your boundary conditions. Is there a way to improve them? Do you understand all the options your solver exposes here, and could you tweak them to make your boundary conditions align better with the case you are solving? Be critical of your boundary conditions, and your simulations will improve!</p>
<!-- /wp:paragraph -->