<!-- How to implement boundary conditions in CFD -->
<!-- https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-implement-boundary-conditions-in-cfd/ -->

<!-- wp:paragraph -->
<p>In this series thus far, we have looked at the governing equations of CFD, how to discretise them and what their character is. We have looked at different numerical schemes and how they influence various properties, such as accuracy. Eventually, we need to talk about boundary conditions, as every simulation will have to truncate the simulation domain somewhere.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, in this article, we take a deep dive into the (fascinating?!) world of boundary conditions, and I promise you, you might think they are easy and straightforward (I've been there), but they are not. The devil is in the detail, and by the end of this article, you will have an appreciation for what common issues, solved and unsolved, exist when we have to deal with boundary conditions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the process, we will see that there really are only three different types of boundary conditions, and if you understand them, you can model any kind of boundary. In most cases, we don't even need the third, so just knowing two, really, is all you need. With these two (or three) fundamental types of boundary conditions, we can derive boundary conditions like walls, symmetry planes, inlets, outlets, and so on, which are just different combinations of these two fundamental types of boundary conditions for the flow variables we are solving for.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I can't make boundary conditions look sexy, but I can tell you about all of the dead bodies it has been hiding and its troubled past (and future), if that is something you are interested in, get the popcorn, we have a journey in front of us!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading">In this series</h2>
<!-- /wp:heading -->

<!-- wp:shortcode -->
[custom_category_posts_list category_slug="10-key-concepts-everyone-must-understand-in-cfd"]
<!-- /wp:shortcode -->

<!-- wp:heading -->
<h2 class="wp-block-heading">In this article</h2>
<!-- /wp:heading -->

<!-- wp:aioseo/table-of-contents {"headings":[{"id":8,"blockClientId":"bd1585b1-3490-4d5e-be37-7840c6dccf29","content":"Introduction","level":2,"anchor":"aioseo-introduction","order":0,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":22,"blockClientId":"a94e5fee-1992-4419-abb1-e95a0f491d24","content":"The fundamental problem with boundary conditions","level":3,"anchor":"aioseo-the-fundamental-problem-with-boundary-conditions","order":1,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]},{"id":40,"blockClientId":"a3eee655-4845-4c39-9deb-ff26f88bc1f8","content":"Three fundamental boundary conditions to rule them all","level":2,"anchor":"aioseo-different-types-of-boundary-conditions","order":2,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":44,"blockClientId":"b8f7460b-57c0-4db6-bf3b-b6e54078f973","content":"Dirichlet-type boundary conditions","level":3,"anchor":"aioseo-dirichlet-type-boundary-conditions","order":3,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":68,"blockClientId":"701ffe09-9bca-4a12-9e18-8471bd97ccb8","content":"Neumann-type boundary conditions","level":3,"anchor":"aioseo-neumann-type-boundary-conditions","order":4,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":106,"blockClientId":"e2011227-6c88-40d1-8f3c-e0d40b2a13ec","content":"Robin-type boundary conditions","level":3,"anchor":"aioseo-robin-type-boundary-conditions","order":5,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]},{"id":141,"blockClientId":"d558fe24-f7eb-4772-a28d-2206d0f0af9b","content":"The two schools of thought on implementing boundary conditions","level":2,"anchor":"aioseo-two-schools-of-thought-on-implementing-boundary-conditions","order":6,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":143,"blockClientId":"83ab1b37-17d5-4df8-8ee9-b460faf359e4","content":"Implementing boundary conditions without mesh modifications","level":3,"anchor":"aioseo-strict-imposition-of-boundary-conditions","order":7,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":150,"blockClientId":"f2683c6d-815f-4f2c-a247-f333a9dfc7c5","content":"Implementing boundary conditions using the ghost cell approach","level":3,"anchor":"aioseo-implementing-boundary-conditions-using-the-ghost-cell-approach","order":8,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]},{"id":188,"blockClientId":"c048197c-8455-4d17-b78c-e101df9287fa","content":"Derived boundary conditions","level":2,"anchor":"aioseo-derived-boundary-conditions","order":9,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":192,"blockClientId":"f36fbd57-b9e9-4e7e-b7f5-a5b6007a9b4f","content":"Solid boundary conditions","level":3,"anchor":"aioseo-solid-boundary-conditions","order":10,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":194,"blockClientId":"01d984e1-06cf-46b8-be1e-b8a62f93e534","content":"Wall","level":4,"anchor":"aioseo-wall","order":11,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":199,"blockClientId":"955b99a5-e4da-442e-b83a-e3b5ea0e5b2e","content":"Symmetry","level":4,"anchor":"aioseo-symmetry","order":12,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]},{"id":203,"blockClientId":"6743471b-b940-40ef-9b36-8c5ebc79a391","content":"Open boundary conditions","level":3,"anchor":"aioseo-open-boundary-conditions","order":13,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[{"id":205,"blockClientId":"b1a5175f-937d-456c-b0c9-3fe7694fb0be","content":"Periodic or cyclic","level":4,"anchor":"aioseo-periodic","order":14,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":218,"blockClientId":"012abb7f-b2cc-4f85-8adb-b6f3d76f0c0f","content":"Differences in open boundary conditions based on the Mach number","level":4,"anchor":"aioseo-the-importance-of-characteristics-on-open-boundary-conditions","order":15,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":229,"blockClientId":"8c12ebeb-bea8-4fb7-a52f-c4add269ad9b","content":"Freestream or farfield","level":4,"anchor":"aioseo-freestream-or-farfield","order":16,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":235,"blockClientId":"518bac0c-e4c6-442c-8dc6-90f3c956e922","content":"Pressure or velocity inlet","level":4,"anchor":"aioseo-inlet","order":17,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":245,"blockClientId":"aa16bbc0-bdc4-4dcc-b463-b5814e2fdc70","content":"Pressure or velocity outlet","level":4,"anchor":"aioseo-outlet","order":18,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":257,"blockClientId":"980ea437-3e3e-44fd-b67a-b15470952241","content":"Advective outlet","level":4,"anchor":"aioseo-advective-outlet","order":19,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]},{"id":272,"blockClientId":"333b601b-60c2-4dc8-a952-22209c31f5c8","content":"Mass-based or volume-based inlets and outlets","level":4,"anchor":"aioseo-mass-flow","order":20,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]}]},{"id":294,"blockClientId":"a9705545-3168-444a-994b-8209c8dfb810","content":"Summary","level":2,"anchor":"aioseo-summary","order":21,"editedContent":"","editedLevel":0,"editedOrder":0,"hidden":false,"headings":[]}]} -->
<div class="wp-block-aioseo-table-of-contents"><ul><li><a href="#aioseo-introduction">Introduction</a><ul><li><a href="#aioseo-the-fundamental-problem-with-boundary-conditions">The fundamental problem with boundary conditions</a></li></ul></li><li><a href="#aioseo-different-types-of-boundary-conditions">Three fundamental boundary conditions to rule them all</a><ul><li><a href="#aioseo-dirichlet-type-boundary-conditions">Dirichlet-type boundary conditions</a></li><li><a href="#aioseo-neumann-type-boundary-conditions">Neumann-type boundary conditions</a></li><li><a href="#aioseo-robin-type-boundary-conditions">Robin-type boundary conditions</a></li></ul></li><li><a href="#aioseo-two-schools-of-thought-on-implementing-boundary-conditions">The two schools of thought on implementing boundary conditions</a><ul><li><a href="#aioseo-strict-imposition-of-boundary-conditions">Implementing boundary conditions without mesh modifications</a></li><li><a href="#aioseo-implementing-boundary-conditions-using-the-ghost-cell-approach">Implementing boundary conditions using the ghost cell approach</a></li></ul></li><li><a href="#aioseo-derived-boundary-conditions">Derived boundary conditions</a><ul><li><a href="#aioseo-solid-boundary-conditions">Solid boundary conditions</a><ul><li><a href="#aioseo-wall">Wall</a></li><li><a href="#aioseo-symmetry">Symmetry</a></li></ul></li><li><a href="#aioseo-open-boundary-conditions">Open boundary conditions</a><ul><li><a href="#aioseo-periodic">Periodic or cyclic</a></li><li><a href="#aioseo-the-importance-of-characteristics-on-open-boundary-conditions">Differences in open boundary conditions based on the Mach number</a></li><li><a href="#aioseo-freestream-or-farfield">Freestream or farfield</a></li><li><a href="#aioseo-inlet">Pressure or velocity inlet</a></li><li><a href="#aioseo-outlet">Pressure or velocity outlet</a></li><li><a href="#aioseo-advective-outlet">Advective outlet</a></li><li><a href="#aioseo-mass-flow">Mass-based or volume-based inlets and outlets</a></li></ul></li></ul></li><li><a href="#aioseo-summary">Summary</a></li></ul></div>
<!-- /wp:aioseo/table-of-contents -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-introduction">Introduction</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>When you performed your first CFD simulations, you probably simulated some kind of laminar or even turbulent flow using a commercial or open-source solver. You selected some boundary conditions, perhaps a combination of inlets and outlets, and sprinkled in some solid walls here and there. You solved this simulation, got results, and presumably, you were very happy with the results. If this describes you, then you would be forgiven for thinking that imposing boundary conditions is easy.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, a lot happens behind the scenes, which is abstracted away from you. Unless you deal with OpenFOAM (where the developers really want you to think long and hard about your boundary conditions, and, by extension, about your life choices (I could have used Fluent/StarCCM+ instead ...)), the end result you see is a combination of violated physics and some undisclosed black magic. Let's face it: we probably all go to hell for the way we treat boundaries. We don't want to admit it, but we know it to be true in our hearts. Or is it just me?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When I applied for my first PhD position on Large Eddy Simulations (LES) and Direct Numerical Simulations (DNS), I was invited for an interview, and I got into a heated argument with one of the post-docs. He was working in the wind tunnel (and, as you are probably aware, there is a&nbsp;healthy&nbsp;portion of distrust and hatred between computational and experimental fluid dynamicists!). So naturally, I didn't take his opinions on CFD too seriously. He insisted that boundary conditions are one of the hardest things to get right, whereas I was of the opinion that they are easy.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I got offered the PhD position (to everyone's surprise, including mine), and later found myself trying to implement boundary conditions into my Cartesian grid-based solver in 2D for steady, laminar flows (we experts call this <em>piss-easy</em>, yes, this is scientific terminology ...). To my surprise, I was struggling, and while I was trying to resolve my boundary condition issues after spending months going through the literature and looking for answers, I remembered the discussion I had with the post-doc. Could he have been right?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Later, I was working on a project using Large-Eddy Simulations. I also supervised a PhD student at the time working on high-resolution schemes on unstructured grids for external aeronautical applications. We both were suffering from the boundary conditions. My inlet boundary conditions could only be described as borderline illegal, while my PhD student did confess to me, after 9 months of troubleshooting, that he just copied and pasted boundary conditions from a different case. After I made some modifications, his case worked, but now he is going to hell, too (I guess).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Boundary conditions are hard. If you believe they aren't, then you either have never implemented them yourself or have done any simulations where the adverse effects of boundary conditions become an issue. If you want to challenge yourself, go and set up a channel flow with Large Eddy Simulations. But no cheating; periodic boundary conditions aren't allowed. You will realise that there are as many different boundary conditions you can impose at the inlet as there are probably RANS turbulence models available, and some are better than others but not necessarily more correct.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In 1991, Sani and Gresho (who would also later publish their book on <a href="https://www.wiley.com/en-gb/Incompressible+Flow+and+the+Finite+Element+Method%2C+Volume+1%3A+Advection-Diffusion+and+Isothermal+Laminar+Flow-p-9780471492498" target="_blank" rel="noopener" title="">finite elements in CFD applications</a>) held a mini-symposium on open questions and challenges for open boundary conditions during the <a href="https://searchworks.stanford.edu/view/719147" target="_blank" rel="noopener" title="">seventh international conference on numerical methods for laminar and turbulent flow</a>. Three years later, they would publish a bleak review of the outcome of this mini symposium.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The test cases they discussed were classical test cases such as the steady-state flow over a backward-facing step (with and without heating), the unsteady flow past a circular cylinder, and the steady-state flow through a channel. But these cases came with a twist; test cases needed to be simulated with boundary conditions imposed in two locations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The first location was far downstream, i.e. far enough away so that they would not influence the simulation. However, the second location was in a region where the flow was still developing. For example, for the circular cylinder case, the boundaries were placed as close as four diameters away from the cylinder. The von Karman vortex shedding is still in development in this region.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The participants presented results for different outlet boundary conditions, and in their 1994 review, Sani and Gresho summarised the mini-symposium and its outcome as:</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><!-- wp:paragraph -->
<p>It has been an exercise in frustration and we are not thrilled with the results obtained</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/fld.1650181006" target="_blank" rel="noopener" title="">Sani and Gresho, 1994</a></p>
<!-- /wp:paragraph --></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>You would think that 30+ years later, we would have solved all of these issues. We haven't. Sure, we have made some advances in specific areas, such as inlet boundary conditions for scale-resolving turbulent flows, but we are still struggling with very fundamental problems. If you have ever worked with Fluent, for example, then you might have encountered reverse flow on the outlet. Once that happens, your convergence is affected, so the developers at Fluent have implemented a fix.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What's that fix? Well, if you encounter reverse flow on a specific cell at the outlet, Fluent will temporarily turn that cell into a wall, preventing flow from entering. Genius, right? Now, you tell me if this is a true reflection of the physics that is going on or a quick and dirty fix we have come to accept because we haven't made any advances in the past 30 years.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-the-fundamental-problem-with-boundary-conditions">The fundamental problem with boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Before we now go into deep philosophical discussions on boundary conditions, let's address the issue at hand. Why are they so difficult? Why can't we make advances in this field?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The short and simple answer is: because boundary conditions don't exist in real life, at least not all!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To see that this is true, let us look first at boundary conditions that do exist. These are solid boundaries, i.e. walls. In a computational sense, nothing can penetrate a solid boundary, i.e. fluid can't go through a wall (unless we impose some form of porosity, which I am ignoring in this example). In real life, we do have physical wall-type boundaries as well. The cup I had my tea in this morning (Madam Grey, two sugars, and a flood of milk, apparently called a <a href="https://en.wikipedia.org/wiki/Builder's_tea" target="_blank" rel="noopener" title="">builder's brew</a> ...) effectively held the fluid in one place. There was no dripping or loss of fluid.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you want to simulate the flow around an airfoil and also decide to run some wind tunnel experiments (of course, without telling your friends, you don't want to be seen hanging out with those experimental people!), then you can go into the test section and <a href="https://www.youtube.com/watch?v=yE8rkG9Dw4s" target="_blank" rel="noopener" title="">physically touch</a> the wing that is installed in the wind tunnel. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Solid boundaries can be found in real life and, thus, are easy to model. But what about open boundaries like inlets and outlets? Think about it for a second. Can you come up with an example of an inlet or an outlet in real life? You can? Well, think again. There are no such things as inlets and outlets or, in general, open boundaries in real life. Every system is connected to another system in some way.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you simulate the flow through a pipe, whatever you impose at the inlet has to come from somewhere, a part of the system that you have conveniently ignored to model in your simulation. Or go back to the example of the airfoil simulation. In the wind tunnel, whatever leaves the test section (i.e. what we would call an outlet in a CFD simulation) is recycled, straightened, and pressurised before it is returned through the wind tunnel to the test section (i.e. what we would call an inlet in a CFD simulation).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are no open boundaries in real life, and if you want to have a physically correct system, then you are only allowed to use solid walls as your boundary condition. Take the wind tunnel, for example. Instead of imposing a fixed inlet velocity, you could also model the entire wind tunnel, including the spinning rotor, which would drive the flow. This geometry would consist of only walls and thus be a valid physical representation. But as soon as you chop off parts of the system and <em>model</em> the effect of the rotor through an inlet, you have changed the original system.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For a steady state RANS simulation, this might be OK, but you will still have to impose boundary conditions for your RANS model. If you are solving this flow with the [katex]k-\omega[/katex] SST model, for example, you will need to impose boundary conditions at the inlet for the turbulent kinetic energy [katex]k[/katex] and the specific dissipation rate [katex]\omega[/katex]. Are you confident that you can impose correct values for these quantities? And is a uniform distribution of [katex]k[/katex] and [katex]\omega[/katex] across the inlet plane a good approximation or would you expect these quantities to be non-uniformly distributed?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Turbulent kinetic energy is created in boundary layers, so close to the walls, and where you have turbulent kinetic energy, you have dissipation. Thus, you probably have much more happening at the edges of your inlet, where your inlet intersects with a solid wall. OK, so how tall is the turbulent boundary layer at your inlet? After all, you have chopped off part of the system; if there was no inlet, then we would have some boundary layer at the wall. You need to know the size of the turbulent boundary layer in order to impose realistic values for [katex]k[/katex] and [katex]\omega[/katex] here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thankfully, the values of [katex]k[/katex] and [katex]\omega[/katex] are not very sensitive to changes, so you will still get fairly good results in most cases, even if you can't accurately describe these values at the inlet. This is one positive attribute of RANS models. But once you want to resolve more turbulence, rather than modelling it, i.e. we are talking about scale-resolving turbulence such as Detached-eddy Simulations (DES), Scale-adaptative Simulations (SAS), Large-eddy Simulations (LES), or god forbid, even Direct Numerical Simulations (DNS), then the above discussed issues become a real problem!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Because we are now resolving turbulence, we also need to resolve the boundary layer at our inlet. If we don't, well, then we are solving a different type of flow. So how do we get around this issue? Well, there are several solutions in the literature, all of which are an approximation, but none of them are correct.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The simplest approach is to give up before we even start, waive a white flag and pretend that there is no turbulence at the inlet. In this case, we set all turbulence to zero and only impose freestream conditions for velocity, pressure, and potentially temperature. This is the simplest approach and, in some cases, a good approximation. Wind tunnels are able to suck away unwanted boundary layers, so as long as we place our inlet at exactly the position where the boundary layer is sucked away and we develop a new boundary layer, we should be golden, right?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Perhaps, and thinking only about the velocity, this is likely a good approximation. But what about the pressure? We looked at <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-elliptic-flows" target="_blank" rel="noopener" title="">elliptic flows in an earlier article</a> within this series, and the pressure is, for the most part, governed by an elliptic behaviour. What that means is that a change in pressure in one point of the flow will instantly propagate throughout the domain. This is why your flow starts turning around an obstacle before it has even reached it. Look at the streamlines around an airfoil, as shown in the above-linked article, to see what I mean.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What this means for our simulation is that by placing an inlet somewhere, we restrict the propagation of pressure (waves) only in a direction away from the inlet. The pressure isn't allowed to go beyond the inlet, influence the velocity upstream of the inlet itself, and, as a result, change the velocity profile that would otherwise develop at the inlet. This may seem like a small thing, but always remember that the Navier-Stokes equations are non-linear. A small change can have large consequences. After all, turbulence is created by microscopic surface roughness (natural transition).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You can show (and I have) that removing an upstream portion of the flow and replacing this with an inlet with a defined velocity profile that was measured in an experiment will give you different results compared to just simulating the upstream portion of the domain. It is the pressure that plays a critical role here, and concentrating only on the velocity will result in inaccuracies.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Of course, if you are dealing with supersonic flows, your pressure is <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-hyperbolic-flows" target="_blank" rel="noopener" title="">hyperbolic</a>, meaning that it has a preferred direction of travel, unlike elliptic flows, where it is travelling in all directions, and so imposing an inlet here is easier. While you have gained simplicity at the inlet, you have shifted the problem to the numerical schemes, which now have to deal with strong non-linearities. We saw in the last article how to tackle those. Alas, not every flow is supersonic, so we are stuck with elliptic pressure-induced boundary issues.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Hopefully, this will set the scene for you. Boundary conditions aren't easy, but they are a necessary evil that we have to deal with in any simulation. In this article, I want to look at how boundary conditions are commonly imposed, and we will see that there are really just three fundamental types of boundary conditions, of which the third type is just a combination of the first two. So, if you understand these two fundamental boundary conditions, you know all there is about boundary conditions. The art is in finding a combination that works for your case that doesn't violate the laws of physics (good luck to you, my friend!)</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-different-types-of-boundary-conditions">Three fundamental boundary conditions to rule them all</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In this section, we will review the three fundamental types of boundary conditions that we can use in simulations. The first two types are the ones you will use in every simulation. When you use a CFD solver and you select a type for your boundary, for example, a wall, or an inlet, your solver will use that information and translate that back to the two fundamental types for all of the quantities that you are solving for, e.g. velocity, pressure, temperature, and any turbulent quantities.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To make our lives easier, let's introduce some notation that we will use to derive the three fundamental types of boundary conditions. The two figures below show the cell arrangement commonly found in the finite difference method (left side), where the variables are stored at the cell's vertices, and the cell arrangement commonly found in the finite volume method (right side), where the variables are stored at the cell's centroid.</p>
<!-- /wp:paragraph -->

<!-- wp:columns -->
<div class="wp-block-columns"><!-- wp:column -->
<div class="wp-block-column"><!-- wp:paragraph -->
<p><strong>Vertex-based boundary conditions (finite difference method)</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5144,"sizeSlug":"large","linkDestination":"none"} -->
<figure class="wp-block-image size-large"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/vertex_based_boundary_conditions-1024x819.png" alt="" class="wp-image-5144"/></figure>
<!-- /wp:image --></div>
<!-- /wp:column -->

<!-- wp:column -->
<div class="wp-block-column"><!-- wp:paragraph -->
<p><strong>Centroid-based boundary conditions (finite volume method)</strong></p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5143,"sizeSlug":"large","linkDestination":"none"} -->
<figure class="wp-block-image size-large"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/centroid_based_boundary_conditions-1024x915.png" alt="" class="wp-image-5143"/></figure>
<!-- /wp:image --></div>
<!-- /wp:column --></div>
<!-- /wp:columns -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-dirichlet-type-boundary-conditions">Dirichlet-type boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Dirichlet-type boundary conditions are those where we impose a value directly. For example, we can impose a velocity, say 10 m/s at an inlet, and then all velocity at the inlet will have this value. This means that we need to know the value we want to impose and that this value will be typically uniformly distributed across the boundary, though we can also implement a non-uniform distribution if we know how this distribution will look like. For example, we may know the velocity profile from experiments.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's see how this can be implemented for the two types of grids that we saw above. On the left, we have the typical vertex-based arrangement that we normally use for finite difference methods. If we concentrate on [katex]\phi_{i-1,j}[/katex], which simply refer to as [katex]\phi_B[/katex], i.e. the value of [katex]\phi[/katex] at the boundary, then we see that since this node is already located on the boundary, we can simply write</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{i,j-1}=\phi_B =\phi_{Dirichlet}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]\phi_{Dirichlet}[/katex] is the value we want to impose on the boundary, e.g. 10 m/s on an inlet, 0 m/s at a non-moving wall, etc. This is rather straightforward. But what about the case on the right side of the figure?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, the right side of the figure shows the typical cell arrangement for a finite volume discretisation. We can see that the node on the boundary is not the cell centroid, i.e. the location where we store our flow variables like velocity, pressure, temperature, etc., but rather [katex]\phi_{i-1/2,j}=\phi_B[/katex]. Again, we just pick one point on the boundary, but the discussion would be the same for any of the other boundary points. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's review the finite volume discretisation again. In my article on <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-discretise-the-navier-stokes-equations/" target="_blank" rel="noopener" title="">how to discretise the Navier-Stokes</a> equations, we looked at how to derive first-order and second-order derivatives. For the first-order spatial derivatives (i.e. in space), we obtained this approximation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a\int_V\frac{\partial \phi}{\partial x}\mathrm{d}V=a\int_An\cdot\phi\,\mathrm{d}A\approx a\sum_{i=1}^{n_{faces}}n_f\cdot \phi_i A_i</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]a[/katex] is some coefficient, for example, the linearised velocity in the non-linear convective term. We go from a volume integral to a surface integral using the Gauss or divergence theorem, which requires us to integrate over all cell faces. In the finite volume method, we approximate that integration by a summation, where we now have to the face normal vector [katex]n_f[/katex], as well as the face area [katex]A_i[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What about [katex]\phi_i[/katex]? Well, these are the values of [katex]\phi[/katex] at the cell's faces. This is indicated in the figure above on the right by the green crosses on the faces. So, using the figure's notation, we could write this summation explicitly as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a\sum_{i=1}^{n_{faces}}n_f\cdot \phi_i A_i=a\left[(\phi_{i+1/2,j}\Delta y) + (\phi_{i,j+1/2}\Delta x) - (\phi_{i,j-1/2}\Delta x) - (\phi_{i-1/2,j}\Delta y)\right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The plus and minus signs appear as a result of the orientation of the normal vector. The convention is that it is pointing outwards, so on the right and top face, the normal vector is pointing along the x and y direction, respectively, so we multiply the flux [katex]\phi_i A_i[/katex] with [katex]+1[/katex] in the x and y direction. For the left and bottom face, on the other hand, the normal vector points against the x and y direction, so we multiply the fluxes by [katex]-1[/katex], hence the negative sign.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we look at the discretised form above, then we see that our Dirichlet value has sneaked into the discretised equation, i.e. the last term [katex]\phi_{i-1/1,j}[/katex] is located on the boundary, and thus we could also write this as [katex]\phi_{i-1/2,j}=\phi_B=\phi_{Dirichlet}[/katex]. Then, our discretised form becomes:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>a\sum_{i=1}^{n_{faces}}n_f\cdot \phi_i A_i=a\left[(\phi_{i+1/2,j}\Delta y) + (\phi_{i,j+1/2}\Delta x) - (\phi_{i,j-1/2}\Delta x) - (\phi_{Dirichlet}\Delta y)\right]</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we can solve this equation again, by finding values for the remaining values of [katex]\phi_{i+1/2, j}[/katex], [katex]\phi_{i,j+1/2}[/katex], and [katex]\phi_{i,j-1/2}[/katex] through a suitable numerical scheme. We have looked at suitable numerical schemes for the finite volume method in the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/" target="_blank" rel="noopener" title="">previous article</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But we also have to deal with second-order derivatives, which are slightly different. Again, I have derived their <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-discretise-the-navier-stokes-equations/#aioseo-approximating-second-order-spatial-derivatives" target="_blank" rel="noopener" title="">step-by-step derivation in the article on how to discretise the Navier-Stokes equation</a>, so we will just look at the final form here, which is of interest. We saw that we can write the finite volume approximation for the second-order derivative as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>b\int_V \frac{\partial^2 \phi}{\partial x^2}\mathrm{d}V=b\int_V \frac{\partial}{\partial x}\frac{\partial \phi}{\partial x}\mathrm{d}V\approx b\sum_{i=1}^{n_{faces}}n_f\cdot \frac{\partial \phi_i}{\partial x} A_i</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]b[/katex] is some coefficient, but since we only have the diffusion term in the Navier-Stokes equation that uses a second-order derivative, this means that [katex]b[/katex] will always be the dynamic or kinematic viscosity (depending on whether it is divided by the density or not).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So now we have the derivative to deal with in our summation. Let's look at the face on the right, i.e. at location [katex]i+1/2,j[/katex]. Looking at the above figure, we can see that a simple approximation for the derivative at this face could be written as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial\phi}{\partial x}\biggr\rvert_{i+1/2,j}\approx\frac{\phi_{i+1,j}-\phi_{i,j}}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>But what about the left face? Here we do not have a value beyond the location [katex]i-1/2,j[/katex], so we can evaluate the gradient the same way. In this case, we simply form the gradient between locations [katex]i-1/2,j[/katex] and [katex]i,j[/katex], which results in</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial\phi}{\partial x}\biggr\rvert_{i-1/2,j}\approx\frac{\phi_{i,j}-\phi_{i-1/2,j}}{\Delta x/2}=2\frac{\phi_{i,j}-\phi_{Dirichlet}}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we see the appearance of [katex]\phi_{i-1/2,j}=\phi_B=\phi_{Dirichlet}[/katex] again, and so we can impose our Dirichlet-type boundary condition for second-order derivatives again. We would find suitable approximations for the remaining terms, i.e. [katex]\phi_{i,j+1/2}[/katex] and [katex]\phi_{i,j-1/2}[/katex], and then we can continue with our finite volume approximation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The remaining steps to approximate both the first-order and second-order derivatives, as well as how to bring them into a form that can be easily solved, are discussed in the previously mentioned article on how to discretise the Navier-Stokes equations.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-neumann-type-boundary-conditions">Neumann-type boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Neumann-type boundary conditions are really just Dirichlet-type boundary conditions in disguise. Instead of setting the absolute value of a quantity [katex]\phi[/katex] (e.g. velocity, pressure, temperature, etc.) at the boundary, we set the value of its derivative, i.e. [katex]\partial\phi/\partial n[/katex], where [katex]n[/katex] is the normal vector on the boundary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We use this boundary condition when we do not know the values at the boundary and we want them to be calculated as part of the solution. Let's take a simple example, a simple flow through a channel, with an inlet, an outlet, and a wall at the top, bottom, front, and back.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For simplicity, let's say we want to impose a velocity at the inlet that is constant across the inlet boundary. What, then, is the velocity at the outlet? We don't know. We would expect it to follow some form of parabolic or power-law velocity profile depending on whether it is a laminar or turbulent flow, but if our domain is very short, it might not even fully develop. We don't know how the velocity will be distributed at the outlet, so we pick a Neumann-type boundary condition for the velocity at the outlet.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, let's look at the pressure. If we assume that the outlet is connected to some opening where we have atmospheric conditions, then it would make sense to prescribe the atmospheric or ambient pressure at the outlet. This can be a constant value for the pressure across the boundary, so we would impose a Dirichlet-type boundary condition for the pressure at the outlet.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What about the inlet? There will be a pressure drop within the channel, but we don't know what its magnitude is. If we want the pressure drop to develop as part of the solution, then we need to allow the pressure to freely develop at the inlet boundary, as the difference of the pressure at the inlet and outlet will determine the pressure gradient (if we divide the difference by the channel length). Thus, we need a Neumann-type boundary condition for the pressure at the inlet.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Finally, what about the walls? We know that we have a no-slip condition, so the velocity should have the same value as the translational motion of the wall. Typically, walls are stationary in simulations, so there is no movement of the walls, and that means our velocity in each direction has to be zero. Since we know the value, we have to impose a Dirichlet-type boundary condition for the velocity at solid walls.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, think about the pressure distribution around an airfoil. It changes from the leading edge to the trailing edge. The only thing we can say with confidence is that the pressure coefficient is one at the stagnation points. However, we don't know the distribution between the leading and trailing edges. The same is true for our channel example, we don't know the pressure here, so we need to let it develop as part of our solution. This means that the pressure needs to be treated as a Neumann-type boundary condition at solid walls.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's see how we can impose Neumann-type boundary conditions. In general, we can write them as follows:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial n}=\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]n[/katex] is the direction of the normal vector on the boundary. In the figures we looked at above, we have [katex]n=x[/katex], i.e. it is aligned with the x-direction. Using the notation of [katex]n[/katex] allows us to write the boundary condition in a generic notation or even account for curvature on the boundary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>[katex]\phi_{Neumann}[/katex] is the value the derivative should be equal to. A common choice is to set [katex]\phi_{Neumann}=0[/katex]. But there are cases where we want to impose a non-zero value for [katex]\phi_{Neumann}[/katex], for example, when we are dealing with heat transfer applications (where [katex]\phi=T[/katex]) and we want to impose some heating, which would be realised with a non-zero gradient of the temperature gradient at the wall (i.e. we set a heat flux).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's start to see how we can impose Neumann-type boundary conditions on the domain sketched out in the figures we looked at previously. For the figure on the left, i.e. using the finite difference method, we have the following discretisation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial n}=\frac{\partial \phi}{\partial x}=\frac{\phi_{i,j}-\phi_{i-1,j}}{\Delta x}=\frac{\phi_{i,j}-\phi_B}{\Delta x}=\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, all that we have to do is solve this equation for [katex]\phi_B[/katex], which will be the value at the boundary that we will impose. This will lead to:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i,j}-\Delta x\cdot\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The boundary position is important and changes this calculation. For example, if we assume for a second that the boundary would be located at [katex]i+1,j[/katex] in the figure, i.e. the solid, vertical black line would be attached to the blue cells on the right, then our boundary condition would be evaluated as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial n}=\frac{\partial \phi}{\partial x}=\frac{\phi_{i+1,j}-\phi_{i,j}}{\Delta x}=\frac{\phi_{B}-\phi_{i,j}}{\Delta x}=\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In this case, when we solve for [katex]\phi_B[/katex], we obtain:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i,j}+\Delta x\cdot\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, if we have the special case of [katex]\phi_{Neumann}=0[/katex] (in the channel flow example we discussed above, all Neumann-type boundaries had a zero gradient condition), both expressions simplify to</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>That is, we simply copy the value of [katex]\phi[/katex] that is next to our boundary node in the [katex]n[/katex] direction. Now you can see why I said that Neumann-type boundary conditions are Dirichlet-type boundary conditions in disguise. We still impose a value for them, but we do so with values from the internal domain. This is also why the values can change (like the pressure distribution around an airfoil), which is based on values obtained from the internal fluid domain.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And what about the finite volume discretisation? Switching our attention to the figure on the right, which we saw in the beginning of this section, we have a very similar process. We can write the Neumann-type boundary condition as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial n}=\frac{\partial \phi}{\partial x}=\frac{\phi_{i,j}-\phi_{i-1/2,j}}{\Delta x/2}=2\frac{\phi_{i,j}-\phi_B}{\Delta x}=\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can solve this equation now for [katex]\phi_B[/katex], which results in</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i,j}-\frac{\Delta x}{2}\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If the boundary would be located again at [katex]i+1,j[/katex], i.e. on the east side of the simplified domain given in the figure above, then we would obtain</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial n}=\frac{\partial \phi}{\partial x}=\frac{\phi_{i+3/2,j}-\phi_{i+1,j}}{\Delta x/2}=2\frac{\phi_{B}-\phi_{i+1,j}}{\Delta x}=\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, the location [katex]i+3/2,j[/katex] is the face between [katex]i+1,j[/katex] and [katex]i+2,j[/katex], i.e. [katex]i+3/2,j=i+1.5,j[/katex]. Then can then be solved for [katex]\phi_B[/katex] again to result in</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i+1,j}+\frac{\Delta x}{2}\phi_{Neumann}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we have [katex]\phi_{Neumann}=0[/katex], then we can simplify our expression again, and we have </p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\phi_{i,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>For the arrangement given in the figure above on the right (i.e. the boundary is located on the west face of the domain). Since we know the value on the Boundary now, we can continue exactly in the same way as we did for the Dirichlet-type boundary condition. And this is what I would advocate you should do if you want to write your own solver.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Some CFD textbooks will introduce a simplification for second-order derivatives. We saw in the discussion on the Dirichlet-type boundary conditions that we had the following expression for second-order derivatives:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>b\int_V \frac{\partial^2 \phi}{\partial x^2}\mathrm{d}V=b\int_V \frac{\partial}{\partial x}\frac{\partial \phi}{\partial x}\mathrm{d}V\approx b\sum_{i=1}^{n_{faces}}n_f\cdot \frac{\partial \phi_i}{\partial x} A_i</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Since we now have to deal with derivatives directly, as seen in the last term, when we are summing over all faces, we could simply set the gradient at the boundary to the value of [katex]\phi_{Neumann}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I don't like this approach because this is not how you want to implement that in code. Based on the discussion we had up to this point, we saw that once we have found a way to implement Dirichlet-type boundary conditions, we can reuse (or even better, modify) this implementation to also allow for Neumann-type boundary conditions. This results in cleaner code, which is easier to maintain and modify. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-robin-type-boundary-conditions">Robin-type boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Robin-type boundary conditions are just a linear combination of Dirichlet and Neumann-type boundary conditions. We can write them in simple terms as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Robin}=a\cdot\phi_{Dirichlet}+b\cdot\frac{\partial \phi}{\partial n}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]a[/katex] and [katex]b[/katex] are linear weights that we use to determine how much each boundary condition contributes. I will show you in a second how you can determine these. A good question at this point would be, why do we need this type of combination? First of all, it is rare (I have survived my entire CFD career up to this point without ever having to use this condition), but specific applications can benefit from it. In short, it is used to model imperfections.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, we said that we have a no-slip condition at the wall for the velocity. This is true on a macroscopic scale. At a molecular scale, particles will experience an electrostatic force that gets stronger the closer the particles get to the wall. Since the wall is a solid material, its atoms are arranged in a certain lattice structure that doesn't move. Any fluid particle (or atom, I use these nouns interchangeably) that gets close is attracted to the wall, and its movement will slow down due to this attractive force. But the particles will never fully stop moving.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But, if we look at a macroscopic average velocity of these particles at the wall, it would appear as if there is no movement. So, on a macroscopic level, a Dirichlet-type boundary condition for the velocity with no relative motion between the fluid and the wall is a very good approximation of the underlying physics.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But what happens if we work on smaller length scales? For example, have a look at the following application, which is known as a lab-on-a-chip device:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5153,"width":"500px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/lab_on_a_chip_device.jpg" alt="" class="wp-image-5153" style="width:500px"/><figcaption class="wp-element-caption">Reproduced from <a href="https://biotium.com/blog/scaling-down-to-go-big-an-overview-of-the-lab-on-a-chip/" target="_blank" rel="noopener" title="">biotium</a></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We have lots of so-called microchannels, seen in red and blue colour, and you see in comparison to the thumb and index finger that these channels are rather small. As our characteristic length scale (say, the height of the channel) gets smaller and smaller, it gets closer to the average distance an atom can travel before colliding with another atom. This distance is known as the mean free path (and for air at ambient pressure, it is about [katex]7\cdot 10^{-8}[/katex] meters.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As these two numbers converge, our continuum hypothesis that we use for the Navier-Stokes equations no longer holds true, i.e. the continuum hypothesis assumes that we are dealing with a large number of atoms so that any motion we observe results from the average motion of these underlying particles. We use the Knudsen number to help us identify this effect, which is expressed as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>Kn=\frac{\text{mean free path}}{\text{characteristic length}}=\frac{\lambda}{L}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Depending on which sources you consult, we classify our flow into different regimes. Typical values and their corresponding flow regime are given as:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>[katex]Kn&lt;0.01[/katex]: Continuum flow (Navier-Stokes equations are valid)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>[katex]0.01\le Kn\le 0.1[/katex]: Slip flow (Navier-Stokes equations are valid with modified boundary conditions, for example, Robin type)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>[katex]0.1\le Kn\le 10[/katex]: Transitional flow (Navier-Stokes no longer works here; a particle description is needed)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>[katex]Kn &gt; 10[/katex]: Free molecular flow</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>As our characteristic length scale approaches this mean free path (as our Knudsen number increases and gets to a value of [katex]Kn&gt;0.01[/katex]), we start to see a shift from this purely Dirichlet-type boundary condition to that of atoms freely moving about at the boundary, which can result in some noticeable slip at the boundary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This slipping of atoms can be implemented with a Robin-type boundary condition, where we impose a nominal no-slip boundary condition with our Dirichlet-type boundary condition, and then we allow some slippage through the Neumann-type boundary condition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another example would be insolation against heat transfer at walls. Let's say our goal is to keep the temperature at a wall to a constant value, but we don't want the fluid to heat the wall further and impose a heat flux across the boundary. We might not be able to fully insulate our wall, so a small heat flux ([katex]\partial T/\partial n\ne 0[/katex]) may be measured in experiments. If we wanted to account for that in our boundary conditions, then we could impose a Robin-type again to model this with more confidence.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So let's look at how the discretised equations would look like. For the finite difference approximation on the left in the figure above, we have</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=a\cdot\phi_{Dirichlet}+b\cdot\frac{\partial \phi}{\partial n}=a\cdot\phi_{Dirichlet}+b\cdot\frac{\phi_{i,j}-\phi_B}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we have to solve this equation for [katex]\phi_B[/katex], where we first have to isolate [katex]\phi_B[/katex] as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B+\frac{\phi_B}{\Delta x}=a\cdot\phi_{Dirichlet}+b\cdot\frac{\phi_{i,j}}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, we simplify the left-hand side to</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B\left(1+\frac{1}{\Delta x}\right)=a\cdot\phi_{Dirichlet}+b\cdot\frac{\phi_{i,j}}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Dividing by the term in the parenthesis on the left, we obtain our combined Robin-type boundary condition as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\frac{a\cdot\phi_{Dirichlet}+b\cdot\frac{\phi_{i,j}}{\Delta x}}{\left(1+\frac{1}{\Delta x}\right)}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>For the finite volume discretisation seen in the figure above on the right, we have a very similar procedure. We start with</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=a\cdot\phi_{Dirichlet}+b\cdot\frac{\partial \phi}{\partial n}=a\cdot\phi_{Dirichlet}+b\cdot\frac{\phi_{i,j}-\phi_{i-1/2,j}}{\Delta x/2}=a\cdot\phi_{Dirichlet}+2b\cdot\frac{\phi_{i,j}-\phi_B}{\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can now derive the Robin-type boundary condition for the finite volume discretisation in exactly the same manner, or we can be lazy and realise that this is exactly the same equation as for the finite difference method, with the only difference that we have a factor of two infront of the [katex]b[/katex] coefficient. Thus, regardless of which way we take, we would end up with</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_B=\frac{a\cdot\phi_{Dirichlet}+2b\cdot\frac{\phi_{i,j}}{\Delta x}}{\left(1+\frac{1}{\Delta x}\right)}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Finally, let us discuss how we can obtain the values for [katex]a[/katex] and [katex]b[/katex]. To do this, we need to know beforehand what the behaviour at the boundary should look like. For example, we may have measured a small slippage at a wall boundary condition, either through an experiment or a numerical simulation using a particle method. Let's say that we obtained the following velocity profile:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5155,"width":"300px","sizeSlug":"large","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/robin_boundary_condition_profile-975x1024.png" alt="" class="wp-image-5155" style="width:300px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We can see that we do not have a fully no-slip condition at the boundary. In this particular example, the velocity at the wall is [katex]0.5[/katex]. I have also given the slope at the wall, which we can use to calculate the gradient. Using the numbers provided, we see that as we go one unit up on the y axis, i.e. [katex]\Delta y=1[/katex], we can see that we have to go two units to the right on the x (u) axis, i.e. [katex]\Delta u = 2.5 - 0.5 = 2.0[/katex]. This means that our gradient, or slope, of the velocity at the wall is [katex]\partial u/\partial x\approx \Delta u/\Delta y=2/1=2[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can also say that we want [katex]\phi_{Robin}=\phi_B[/katex] to evaluate to [katex]0.5[/katex], i.e. this is the value that we want to impose on our boundary. The Dirichlet-type boundary condition for the velocity is still going to assume that we have a no-slip value at the wall, which would leave us with [katex]\phi_{Dirichlet}=0[/katex]. With that knowledge, we can write our Robin-type boundary condition as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Robin}=a\cdot\phi_{Dirichlet}+b\cdot\frac{\partial \phi}{\partial n}\\[0.5em]
0.5=a\cdot 0+b\cdot 2\\[0.5em]
0.5=b\cdot 2\\[0.5em]
b=\frac{1}{4}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We want to ensure that [katex]a+b=1.0[/katex], i.e. [katex]a[/katex] and [katex]b[/katex] have to be chosen in a way that we have a linear combination of Dirichlet-type and Neumann-type boundary conditions. If [katex]a+b=1[/katex] and [katex]b=0.25[/katex], then we have [katex]a=0.75[/katex]. In this case, the coefficient of [katex]a[/katex] doesn't matter, as we impose a zero velocity at the wall, but if we were to use the example of a heated wall with a heat flux through it, then we would impose the wall temperature here, which would not be zero.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And there you have it. Three fundamental boundary condition types will be used to construct various types of derived boundary conditions, such as velocity inlets, mass flow outlets, solid walls, symmetry planes, and so on. We will derive this at the end of this article, but before we do that, let's discuss the two different ways we can implement boundary conditions in code. </p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-two-schools-of-thought-on-implementing-boundary-conditions">The two schools of thought on implementing boundary conditions</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>As alluded to above, we have two different ways of implementing boundary conditions in our code. We can make changes to our mesh and thus change the way the boundaries are treated. In this section, I want to review these two different methods and show which advantages and disadvantages they bring.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-strict-imposition-of-boundary-conditions">Implementing boundary conditions without mesh modifications</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In the first method, we do not touch the mesh, and we leave everything exactly as it is. This results in the methodology we used in the previous section. Take a look at the vertex-based and centroid-based mesh again that we looked at above:</p>
<!-- /wp:paragraph -->

<!-- wp:columns -->
<div class="wp-block-columns"><!-- wp:column -->
<div class="wp-block-column"><!-- wp:image {"id":5144,"sizeSlug":"large","linkDestination":"none"} -->
<figure class="wp-block-image size-large"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/vertex_based_boundary_conditions-1024x819.png" alt="" class="wp-image-5144"/></figure>
<!-- /wp:image --></div>
<!-- /wp:column -->

<!-- wp:column -->
<div class="wp-block-column"><!-- wp:image {"id":5143,"sizeSlug":"large","linkDestination":"none"} -->
<figure class="wp-block-image size-large"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/centroid_based_boundary_conditions-1024x915.png" alt="" class="wp-image-5143"/></figure>
<!-- /wp:image --></div>
<!-- /wp:column --></div>
<!-- /wp:columns -->

<!-- wp:paragraph -->
<p>The advantage is obvious (well, after you have gone through the other type of how to treat boundaries); we do not have to make any mesh modifications. We either create our mesh within our solver or read in the mesh from an external mesh generator, and we can use it as it is. This seems logical, but you will see why this is an advantage in the next section.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The disadvantage is that as we approach the boundary, the cell directly attached to the boundary will not have any neighbour cell beyond that boundary. But, if we use a higher-order scheme, we saw in my previous article that we need to have more and more points to the left and to the right of the cell for which we are currently finding an approximation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>At boundaries, we can't evaluate these schemes, so we have to switch to a lower-order version just to be able to get approximations near the boundaries, either for the gradients (finite difference method) or the face-interpolated values (finite volume method). If you went through my <a href="https://cfd.university/newsletter-signup/" target="_blank" rel="noopener" title="">eBook on how to implement your own CFD solver</a>, we saw that we had to switch the numerical scheme at the boundaries from a second-order MUSCL scheme to a first-order piecewise constant scheme.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, with this approach, we get to use the mesh as is, without modifications. Boundary conditions can be implemented as we have discussed in the previous section, but the numerical schemes used at boundaries may reduce in order. If we want to overcome this issue, we need to have a look at the second type of implementing boundary conditions with ghost cells. Let's do that next.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-implementing-boundary-conditions-using-the-ghost-cell-approach">Implementing boundary conditions using the ghost cell approach</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>So, you have decided that you do not want to reduce the order of approximation near the boundary. This can be achieved at a cost. What we have to do is to implement additional cells that go beyond the boundary. This is shown below for a vertex-based (finite difference) approach:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5145,"width":"900px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/vertex_based_boundary_cell_arrangements.png" alt="" class="wp-image-5145" style="width:900px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We can also add additional cells for a centroid-based (finite volume) approach, which would result in:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5146,"width":"900px","sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/centroid_based_boundary_cell_arrangements.png" alt="" class="wp-image-5146" style="width:900px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>In both cases, we have added two additional cells to the left of the boundary, indicated again by the vertical black line. These additional cells go under various names, but a common name is ghost cells. If you look into the CGNS format, it does support ghost cells, but it goes under the name of rind layers, just to confuse that little bit extra (no one else uses that name as far as I can see).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's ignore for the moment how we can impose boundary conditions, now that the boundary is seemingly on the inside of the domain. We are still only solving the flow for the internal domain, i.e. everything up to the boundary, that is the domain we are interested in. But now that we have additional cells beyond the boundary, we can use our higher-order numerical schemes without issues, i.e. those where we need information beyond the boundary. This simplifies our code implementation significantly near boundaries.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another advantage is that we have practically removed boundaries completely. In our code, we simply solve the equations up the cells that are attached to the boundaries, but we no longer have to introduce a special treatment near boundaries. How is that possible? Well, the ghost cells that we have created need to have some values. We set the values within those ghost cells based on the boundary conditions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's take the vertex-based (finite difference) case first. Here we can see that we have [katex]\phi_B[/katex] located at [katex]i,j[/katex], in other words, [katex]\phi_B=\phi_{i,j}[/katex]. So this is the [katex]\phi[/katex] on the boundary. We can see by the shaded outline that both [katex]\phi_{i-1,j}[/katex] and [katex]\phi_{i-2,j}[/katex] are located within the ghost cells, and they are located outside of our fluid domain.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The way that we find values for these two cells is by using the information we have at the boundaries. For example, if we have a Dirichlet-type boundary condition for [katex]\phi[/katex], i.e. we have [katex]\phi_B=\phi_{Dirichlet}[/katex], then we can say that the average of [katex]\phi[/katex] at the two vertices directly left and right to [katex]\phi_B[/katex] must be equal to [katex]\phi_{Dirichlet}[/katex]. This can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Dirichlet}=\frac{\phi_{i+1,j}+\phi_{i-1,j}}{2}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>From this, we can solve this equation for [katex]\phi_{i-1,j}[/katex] and obtain</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{i-1,j}=2\cdot \phi_{Dirichlet}-\phi_{i+1,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The eagle-eyed among you will have realised this is the canonical equation for extrapolation. Thus, we use values of [katex]\phi[/katex] at [katex]i+1,j[/katex] (which we know from the internal fluid domain computation) and [katex]i,j[/katex] (which we know from the Dirichlet-type boundary condition) to find a value at [katex]i-1,j[/katex] (beyond the fluid domain). Because we found this value by using the boundary condition, it will be implicitly included when we use now [katex]\phi_{i-1,j}[/katex] in our computations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What about [katex]i-2,j[/katex]? Well, we repeat the same process and find the average between cells at [katex]i+2,j[/katex] and [katex]i-2,j[/katex]. This results in</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Dirichlet}=\frac{\phi_{i+2,j}+\phi_{i-2,j}}{2}\\[0.5em]
\phi_{i-2,j}=2\cdot\phi_{Dirichlet}-\phi_{i+2,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This extends to an arbitrary number of cells, so we can introduce as many ghost cells as we need to use the numerical stencil we want. If we are dealing with centroid-based (finite volume) approximations, using the definition in the figure above, we simply have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{i-1,j}=2\cdot\phi_{Dirichlet}-\phi_{i,j}\\[0.5em]
\phi_{i-2,j}=2\cdot\phi_{Dirichlet}-\phi_{i+1,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>OK, so this is how we deal with Dirichlet-type boundary conditions. What about Neumann-type? The process is similar, where we first start with the definition of the Neumann-type boundary condition, which is</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Neumann}=\frac{\partial \phi}{\partial n}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We now take this and approximate the derivative across the boundary. For the vertex-based approximation, we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Neumann}=\frac{\phi_{i+1,j}-\phi_{i-1,j}}{2\Delta x}\\[0.5em]
\phi_{Neumann}=\frac{\phi_{i+2,j}-\phi_{i-2,j}}{4\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This can be solved for the unknowns [katex]\phi_{i-1,j}[/katex] and [katex]\phi_{i-2,j}[/katex] to produce:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{i-1,j}=2\Delta x\cdot\phi_{Neumann}+\phi_{i+1,j}\\[0.5em]
\phi_{i-2,j}=4\Delta x\cdot\phi_{Neumann}+\phi_{i+2,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Again, for the centroid-based (finite volume) description, we would obtain similar results. With the notation provided in the figure above, we would have</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{Neumann}=\frac{\phi_{i,j}-\phi_{i-1,j}}{\Delta x}\\[0.5em]
\phi_{Neumann}=\frac{\phi_{i+1,j}-\phi_{i-2,j}}{3\Delta x}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This can be solved for the unknowns again to yield:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_{i-1,j}=\Delta x\cdot\phi_{Neumann}+\phi_{i,j}\\[0.5em]
\phi_{i-2,j}=3\Delta x\cdot\phi_{Neumann}+\phi_{i+1,j}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In all of the above discussions, I assume that the grid spacing is constant. If we have mesh stretching, then we could either introduce ghost cells with constant spacing and then work out how derivatives with non-constant spacing are approximated, or we could simply mirror the mesh spacing in our ghost cells so that the boundary would essentially act as a mirror. For example, if we use inflation layers, these would have to be mirrored by the ghost cells. This is the easier approach of the two.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you look at the Dirichlet-type and Neumann-type approximation, you might have realised that we are using here a second-order extrapolation and a second-order central difference scheme to approximate the derivative. Thus, if you are using a numerical scheme that has a numerical order that is higher than two, you might not be able to achieve that order at the boundaries, as the values within the ghost cells are only approximated to within second-order accuracy. Bummer!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Could we use higher-order approximations? Yes, but once we do, we may start to introduce numerical oscillations. If you have ever fitted a higher-order polynomial through some points, you will know that you will get a seemingly good fit for interior points (probably an overfit), but near the points at the start and end, your polynomial will oscillate quite violently.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Take the following example of fitting a sixth-order polynomial through six points:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5156,"sizeSlug":"full","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-full"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/polynomial_approximation_sixth_order.png" alt="" class="wp-image-5156"/><figcaption class="wp-element-caption">Reproduced from <a href="https://bartwronski.com/2021/11/03/study-of-smoothing-filters-savitzky-golay-filters/" target="_blank" rel="noopener" title="">Bart Wronski</a></figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>While the polynomial goes through all data points, it does start to oscillate. A similar behaviour may be observed if we want to achieve higher-order approximations for the values in our ghost cells, so it is probably for the best to keep it to second order.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But even if we find a stable method of approximating values within our ghost cells, that would only really work for equidistant structured grids. What about unstructured grids? Let's have a look at the following example:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":5158,"width":"400px","sizeSlug":"large","linkDestination":"none","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/06_how-to-implement-boundary-conditions-in-cfd/ghost_cells_unstructured_grid-1024x996.png" alt="" class="wp-image-5158" style="width:400px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Here, if we want to get the centroid value for the ghost cell shown (I have left the other ghost cells at the top and bottom empty), then we see that the point on the other side of the boundary in the fluid domain would be where the orange dot is located. However, this point does not coincide with any centroid within the fluid domain, so we would have to get this point with an interpolation from surrounding points. This can be done, but higher-order schemes using ghost cells now would be limited by this second-order interpolation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I have just shown one layer of ghost cells here, but for higher-order numerical schemes on unstructured grids, your stencil will be much larger. That means that we have to construct even more ghost cells. You see, on unstructured grids, the complexity quickly escalates, but we are not really gaining anything. We have to resort to second-order interpolation, so our higher-order scheme would lose accuracy near the boundaries anyway. It is simpler to just use a lower-order scheme here, which likely has the same accuracy but less computational cost.</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-derived-boundary-conditions">Derived boundary conditions</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Up until this point, we have only really touched upon Dirichlet-type and Neumann-type boundary conditions, as well as Robin-type as a combination of the two. This is really all that you need. If you are working with OpenFOAM, for example, you have countless of boundary conditions to choose from, but if you know these three fundamental types of boundary conditions, you can set up any flow problem.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you are going for a commercial solver, they typically want to make your life as easy as possible and don't have you think about what is Dirichlet and what should be Neumann. Instead, they provide abstract versions of these, which you will know under names such as Inlet, Outlet, Walls, Symmetry, Periodic or Cyclic, and so on.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So in this section, I want to shine a light on these boundary conditions and show what type of boundary conditions are actually solved here in terms of Dirichlet and Neumann. This can also help you write your own solver so you know what type of boundary conditions to impose in terms of Dirichlet and Neumann.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-solid-boundary-conditions">Solid boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The first boundary condition we want to look at is solid boundary conditions. These are boundary conditions where flow cannot penetrate through the boundary, and typically, when we talk about solid boundary conditions, we refer to walls. But there are different types of wall boundary conditions, so let's review them here.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-wall">Wall</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The first type is the wall itself. We have already briefly discussed it before, but for completeness, I want to introduce it again here. At the wall, the velocity has to come to rest, and this means that all velocity components have to be zero for a stationary wall or the same speed as the wall if it is moving. The pressure develops at the wall, so we don't know its values before we run the simulation, so we cannot impose the pressure here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we are dealing with the energy equation as well, that is, we are solving for the temperature, then we have two options. We can either set a constant temperature [katex]T[/katex] or impose a heat flux. If the heat flux is set to zero, we have an adiabatic system (no heat is transferred between our fluid and the wall itself). Depending on our sign convention, we may have heating for a positive heat flux or cooling for a negative heat flux.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can summarise a wall boundary condition as:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet, with [katex]u=v=w=u_{wall}[/katex]. For stationary walls, we have [katex]u_{wall}=0[/katex]</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann, with [katex]\partial p/\partial n=0[/katex]</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>:<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Dirichlet for constant temperature</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Neumann for adiabatic walls with [katex]\partial T/\partial n=0[/katex]</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Neumann for heating with [katex]\partial T/\partial n&gt;0[/katex]</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Neumann for cooling with [katex]\partial T/\partial n&lt;0[/katex]</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-symmetry">Symmetry</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The symmetry condition can be somewhat confusing. Yes, if we mirror the flow at the symmetry plane, we get a mirror image of the flow. But that is also true for all other boundary conditions, so this is not a very effective name in my view. Instead, I find it best to think of symmetry boundary conditions as a frictionless wall or a slip wall.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Essentially, a symmetry boundary condition is a solid wall as well, so no fluid can penetrate through it, with the exception that the velocity in the parallel direction of the symmetry boundary plane is treated as a Neumann boundary condition rather than a Dirichlet boundary condition. This means that we have</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet for [katex]\mathbf{u}_\perp=0[/katex] and Neumann for [katex]\partial\mathbf{u}_\parallel/\partial \mathbf{x}_\parallel=0[/katex]. Here, [katex]\perp[/katex] and [katex]\parallel[/katex] are the normal and parallel direction at the boundary. We used [katex]n[/katex] before to denote the normal direction at the wall, which is equivalent to the [katex]\perp[/katex] direction, and [katex]\parallel[/katex] is tangential/parallel to the symmetry boundary face.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>All other variables</strong>: [katex]\partial\phi/\partial n=0[/katex]</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-open-boundary-conditions">Open boundary conditions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Open boundary conditions start to break things and will cause you headaches. As a general rule, place these boundaries as far away as possible from any object of interest so that they do not influence the flow near that object. If you can't do that, then check that your open boundaries do not adversely influence the results.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-periodic">Periodic or cyclic</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>These are the simplest open boundaries to implement. Assuming that your domain does indeed feature a periodic pattern, and it is suitable to consider just one instance and replace the boundaries with periodic boundaries, then these open boundary conditions are the only ones that will not adversely affect your simulation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It is a popular boundary condition for turbulent flows, where we say that whatever goes out on one side of the domain has to go in on the opposite side of the domain. This requires that boundaries are parallel to each other and flat.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's consider a simple example of a 1D case to see how we can implement them. You will have two boundaries, one on the left side and one on the right side. Let's say that we have 10 vertices (finite difference) or 10 cells (finite volume), and let's write the number of cells with the variable [katex]N=10[/katex]. Then, we can establish the following index:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>i\,\%\,N</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]\%[/katex] is the modulo operator, which will return the remainder of the division of [katex]i/N[/katex]. For example, [katex]5%10=5[/katex]. [katex]5/10=0[/katex] with a remainder of [katex]5[/katex]. Or take another example, [katex]5%2=1[/katex]. We can divide 5 by 2 exactly two times, this leaves a remainder of 1. So how does it relate to periodic boundary conditions?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's consider the 1D heat diffusion equation with explicit time integration, This can be written as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>T_i^{n+1}=T_i^n+\alpha\frac{T_{(i+1)\%N}^n-2T_i^n+T_{(i-1)\%N}^n}{\Delta x^2}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, instead of [katex]T_{i+1}^n[/katex] and [katex]T_{i-1}^n[/katex], I wrote [katex]T_{(i+1)\%N}[/katex] and [katex]T_{(i-1)\%N}[/katex]. We said that [katex]N=10[/katex], so let's see what happens for [katex]i=8[/katex]. We have [katex]8%N=8%10=8[/katex]; 10 does not fit into 8, so we have a remainder of 8. So [katex](i+1)\%N=(8+1)\%10=9\%10=9[/katex]. Similarily, [katex](i-1)\%N=7[/katex]. So these two statemets still return [katex]T_{i+1}[/katex] and [katex]T_{i-1}[/katex], respectively.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This only becomes important at the boundaries. So let's set [katex]i=N=10[/katex]. We are now on the boundary vertex/cell, and we know there is no more vertex/cell to the right. Thus, [katex]i+1=10+1=11[/katex] does not exist as a location, as we only have [katex]N=10[/katex] vertices/cells. But, if we evaluate now [katex](i+1)\%N[/katex], we get [katex](10+1)\%10=11\%10=1[/katex]. 11 divided by 10 is 1, with a remainder of 1.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On the left boundary, we have a similar situation. Here, we have [katex](i-1)\%N=(0-1)\%10=-1[/katex]. Hmm, that looks strange. The location [katex]i=-1[/katex] does not exist and is beyond the left side of the domain. There are two ways to deal with this. We can check each index and then add [katex]N[/katex] whenever we have a negative number. In this case, we would have [katex]-1+N=-1+10=9[/katex], which is the vertex/cell one unit to the left on the right boundary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Alternatively, we can also simply add [katex]N[/katex] to all of our stencils. For example, in the previous example, we would modify this to [katex](i-1+N)\%N=(0-1+10)\%10=9\%10=9[/katex]. For the example on the right boundary, we would get [katex](i+1+N)\%N=(10+1+10)\%10=(21)\%10=1[/katex]. In the last case, we still get 1. Even though we added [katex]N[/katex], it doesn't change the result, as the modulo operator [katex]\%[/katex] returns the remainder, not the actual result of the division. The remainder will not change if we add multiples of [katex]N[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, by using the modulo operator, we can simply implement boundary conditions without even being aware that they are there. While we haven't used Dirichlet-type or Neumann-type boundary conditions here explicitly, since we are setting values beyond the boundaries to know values, periodic boundary conditions can be understood to be of type Dirichlet for all quantities that we are solving for.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-the-importance-of-characteristics-on-open-boundary-conditions">Differences in open boundary conditions based on the Mach number</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>No all boundary conditions are created equal. Depending on the local Mach number, the flow's behaviour will change. For example, for subsonic flows where the Mach number is below one, the pressure behaves in an <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-elliptic-flows" target="_blank" rel="noopener" title="">elliptic manner</a>, meaning that pressure disturbances are instantaneously propagated through the domain. This allows streamlines to start curving away from objects like airfoils before the flow has even reached these objects.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once we go supersonic, the behaviour of the Navier-Stokes equation changes, and we get a <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-hyperbolic-flows" target="_blank" rel="noopener" title="">hyperbolic behaviour</a>. Now there is a defined direction of travel, and the pressure, for example, is no longer propagating instantaneously. So, for the airfoil example, it will only see the airfoil when it reaches it, causing an instant shock wave to form at the leading edge (depending on the shape of the airfoil, or in general, of the object, we may get a detached bow shock instead).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Since the behaviour of the flow changes as we go from subsonic ([katex]Ma&lt;1[/katex]) to supersonic ([katex]Ma\ge 1[/katex]), so does the behaviour on the boundary, and so we need to account for that in our boundary conditions. In general, we have the following requirements on open boundaries for subsonic flows ([katex]Ma&lt; 1[/katex]):</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Inlet:<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>All boundary conditions are known and imposed as Dirichlet-type boundary conditions except for one.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>One boundary condition needs to be of type Neumann.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Outlet:<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>All boundary conditions are unknown and imposed as Neumann-type boundary conditions except for one.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>One boundary condition needs to be of type Dirichlet.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>In contrast, for supersonic boundaries ([katex]Ma\ge 1[/katex]), we have:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>Inlet:<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>All boundary conditions are known and imposed as Dirichlet-type boundary conditions.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li>Outlet:<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li>All boundary conditions are unknown and imposed as Neumann-type boundary conditions.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>The reason this changes has to do with <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-precurser" target="_blank" rel="noopener" title="">the characteristics of the flow</a>. They change their behaviour on open boundaries as the flow changes from a mixed-elliptic hyperbolic (subsonic) flow to a fully hyperbolic (supersonic) flow. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For subsonic (e.g. incompressible) flows, all but one characteristics are pointing into the domain. We impose values for these using Dirichlet-type conditions, but there is one characteristic that points outwards, and so we don't know its value, and we have to impose that as a Neumann-type boundary condition. At the outlet, all but one characteristics point outwards, so we impose Neumann for them and one characteristic points into the domain, so we impose a Dirichlet type for it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For supersonic (e.g. compressible) flows, this changes to all characteristics either pointing into the domain at the inlet, so we apply Dirichlet-type boundary conditions to all variables, or out of the domain at the outlet, so we apply Neumann-type boundary conditions to all variables.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We'll have to keep this in mind for the remaining discussion, as boundary conditions will slightly change for the type of flow we have at hand.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-freestream-or-farfield">Freestream or farfield</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Having gone through the above discussion, we are going to discuss an exception immediately. Freestream or farfield conditions are fully Dirichlet-type conditions. That is, we set values for all variables at both the inlet and the outlet. How can we do that? Well, consider an aircraft flying in cruise condition. If we wanted to model this, and we placed a domain around the aircraft that is, say, 10 km wide in each direction, we can probably assume that if we are far enough away from an object in an external flow scenario, we have reached atmospheric conditions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, the wake of the aircraft may have dissipated into heat and is no longer there, while the flow near the outlet will have returned to its original state. So if we place the boundaries very far away from the object that we are investigating, then farfield boundary conditions are not a bad starting point. This implies that we have open boundaries on all sides, i.e. we can't use freestream or farfield boundary conditions for internal flows.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>They are popular for aeronautical cases, e.g. airfoils, aircraft, and similar applications. But these are the exception to the rule, and, due to their requirement of no solid boundaries in the farfield, we can only use them for specific applications. If we want to have a more general open boundary condition, then we need to treat inlets and outlets separately so we can account for incoming and outgoing characteristics.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For completeness, let's write out the boundary conditions. We have for both inlets and outlets:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Dirichlet</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Dirichlet</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-inlet">Pressure or velocity inlet</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The pressure or velocity inlet, as the name suggests, specifies a value for either the pressure or velocity. This is imposed as a Dirichlet boundary condition. If we are dealing with an incompressible flow, we only need to consider the velocity and pressure, and we remember from our discussion above that for subsonic flows (all incompressible flows must be subsonic by definition), we need to specify at least one Neumann-type condition. For compressible flows, we have to specify Dirichlet-type boundary conditions everywhere.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We typically specify the velocity if we want to achieve a certain flow rate or Reynolds number. A pressure inlet, on the other hand, is typically used with a pressure outlet, where we specify a pressure gradient between the inlet and outlet. By knowing the length of the domain [katex]L_{domain}[/katex], we can compute the pressure gradient [katex]\nabla p[/katex] as [katex]\nabla p=(p_{inlet}-p_{outlet}/L_{domain})[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, for an <strong>incompressible </strong>flow, we impose the following conditions for a <strong>velocity inlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet for all velocity components [katex]u[/katex], [katex]v[/katex], and [katex]w[/katex].</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann, typically [katex]\partial p/\partial n=0[/katex].</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Either Dirichlet if the temperature at the inlet is known or Neumann if it is unknown.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>For an <strong>incompressible </strong>flow, we impose the following conditions for a <strong>pressure inlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Neumann for velocity normal to inlet, i.e. [katex]\partial u_{\perp}/\partial x_\perp=0[/katex], Dirichlet for all tangential velocities, i.e. [katex]u_\parallel=0[/katex].</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Dirichlet</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: The same as for the velocity inlet, Dirichlet if temperature is known, Neumann if it isn't.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>For a <strong>subsonic, compressible</strong> flow, i.e. [katex]Ma&lt;1[/katex], we can impose either a <strong>velocity inlet</strong> or <strong>pressure inlet</strong> boundary condition as seen above. For a <strong>supersonic, compressible </strong>flow, i.e. [katex]Ma\ge 1[/katex], we impose the following conditions at the <strong>inlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Dirichlet</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Dirichlet</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>We do not differentiate between velocity and pressure inlets for compressible flows as all characteristics point into the domain. Thus, all quantities have to be specified.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-outlet">Pressure or velocity outlet</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The pressure or velocity outlet is the opposite to the corresponding inlet, in many ways, i.e. we prescribe either one velocity component or the pressure at the outlet, at least for incompressible flows. For compressible flows, we would specify Neumann-type boundary conditions for all variables.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For incompressible flows, we need to be careful with the pairing of inlets and outlets as well. If we use a velocity inlet, for example, we specify Neumann-type boundary conditions for the pressure. If we now also set the outlet to a velocity outlet, then we use Neumann-type boundary conditions again for the pressure. If we now have some walls as well in the domain, then we have further Neumann-type boundary conditions for the pressure. This is a problem.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Why? Well, we saw before that Neumann-type boundary conditions really just copy values from the internal domain and they set them at the boundaries. If all of our boundaries use a Neumann-type boundary condition, then the pressure is allowed to increase without bounds (and it will). In order to avoid this issue, we typically have to specify the value of the pressure in one cell, and then we ensure that this pressure is set for this one cell. In this way, we fix the pressure not through boundary conditions but instead through a single cell or a volume condition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To avoid this issue, we can simply pair a velocity inlet with a pressure outlet, where we prescribe, for example, the ambient pressure at the outlet as a Dirichlet-type boundary condition. This is a common combination if we are using a velocity inlet. If we use a pressure inlet, we can still use a pressure outlet, as we prescribe now both pressure values as a Dirichlet-type boundary condition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, for an <strong>incompressible </strong>flow, we impose the following conditions at the <strong>velocity outlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: One component Dirichlet, typically the velocity component normal to the boundary face, the remaining components are Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Neumann</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>For an <strong>incompressible</strong> flow, we impose the following conditions at the <strong>pressure outlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Neumann for all velocity components</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Dirichlet, typically ambient pressure</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Neumann</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>For a <strong>subsonic, compressible</strong> flow, i.e. [katex]Ma&lt;1[/katex], we can either impose a <strong>velocity outlet</strong> or <strong>pressure outlet</strong> as seen above. For a <strong>supersonic, compressible</strong> flow, i.e. [katex]Ma\ge 1[/katex], we impose the following conditions at the <strong>outlet</strong>:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Neumann</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>I should mention here that, while technically possible, the velocity outlet is rarely used. It does have the issue of potentially having a fully Neumann-type boundary condition for the pressure, and thus, the pressure outlet is typically preferred.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-advective-outlet">Advective outlet</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Thus far, we have only really discussed one type of boundary condition at the outlet, i.e. a combination of Dirichlet and Neumann boundary conditions. But in specific cases, we can impose a third type (or fourth, if you want to count Robin-type boundary conditions as well). This is to solve an advection equation at the outlet. In particular, this is the equation we are solving for the outlet:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\partial \phi}{\partial t}+u_\perp\frac{\partial \phi}{\partial n}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]u_\perp[/katex] is the normal velocity at the outlet, and [katex]\partial \phi/\partial n[/katex] is the derivative of [katex]\phi[/katex] (velocity, pressure, temperature, etc.) at the outlet and it is normal/perpendicular to the boundary face. If we discretise this equation with a finite-difference approximation, for example, we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\frac{\phi^{n+1}_{i}-\phi_i^n}{\Delta t}+u_i^n\frac{\phi_i^n-\phi^n_{i-1}}{\Delta x}=0</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, I have used a backward approximation for the derivative. Let's assume that the vertex on the boundary is located at location [katex]i[/katex], so that location [katex]i-1[/katex] is on the internal fluid domain. If the boundary was located on the left side of the domain, then we would use a forward derivative in space, which we would evaluate at locations [katex]i[/katex] and [katex]i+1[/katex], respectively.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we solve this equation now for [katex]\phi_i^{n+1}[/katex], we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\phi_i^{n+1}=\phi_i^n-u_i^n\frac{\Delta t}{\Delta x}\left(\phi_i^n-\phi^n_{i-1}\right)</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Thus, by knowing the values of [katex]\phi_i^n[/katex] and the velocity normal at the boundary [katex]u_i^n[/katex] from the previous time step (or the values obtained from the initialisation if it is the first time step), we can compute the values for [katex]\phi_i^{n+1}[/katex] for the next time step.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You might be asking yourself, why would we go through the trouble of doing this? Well, the outlet conditions we have discussed in the previous section are so-called reflective boundary conditions, while the advective type discussed in this section are so-called non-reflective type boundary conditions. They do pretty much what their name suggests, but I think a video that shows both types in action will likely be more explanatory. Can you guess which type was used for the top and bottom domain?</p>
<!-- /wp:paragraph -->
 
<iframe src="https://www.youtube.com/embed/J-52qLLDku4?si=2hRCIenaiVcvP6eF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen style="width:100%; aspect-ratio:16/9; border:0;"></iframe>

<!-- wp:paragraph -->
<p>Here, we see some pressure waves being advected by the flow. The top domain uses a pressure outlet of some sort (reflective), while the bottom domain uses an advective outlet (non-reflective).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Using one or the other will depend on your given flow problem. Reflective boundary conditions can sometimes lead to slower convergence, though this may be necessary to properly simulate the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-elliptic-flows" target="_blank" rel="noopener" title="">elliptic nature of the pressure</a>. This, in turn, can influence the simulations and produce correct physical results that may not be obtained with an advective-type outlet condition, even though convergence may be accelerated.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Generally speaking, since all characteristics point outwards for compressible, supersonic flows, advective boundary conditions can be used here to ensure that no flow is entering back into the domain. This aligns with the physical expectation of a <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-hyperbolic-flows" target="_blank" rel="noopener" title="">hyperbolic flow</a>, and thus, correct physics can be reproduced while convergence may also be accelerated.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If this boundary condition is used for compressible flows, we can replace the normal velocity component [katex]u_\perp[/katex] with the largest eigenvalue given by [katex]u_\perp + a[/katex], where [katex]a[/katex] is the speed of sound.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-mass-flow">Mass-based or volume-based inlets and outlets</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Finally, we can also compute the inlet or outlet velocity by imposing a specific mass or volume flow rate. The volume flow rate can be computed as</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\dot{V}=u_\perp\cdot A</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]u_\perp[/katex] is again the velocity component normal/perpendicular to the boundary, while [katex]A[/katex] is the surface area of the boundary. This will give us a flow rate in units of [katex]m^3/s[/katex]. For an incompressible flow, where the density remains constant, this is a good boundary condition, but for compressible flows, we may want to bring in the density as well. If we multiply the volume flow rate by the density, we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\dot{m}=\rho \cdot u_\perp\cdot A</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This will give us a mass flow rate at either the inlet or the outlet. If the volume flow rate is given in units of [katex]m^3/s[/katex], multiplying this by the density gives us [katex](m^3/s)(kg/m^3)=kg/s[/katex]. Because of this unit, we call it the mass flow rate.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can modify both the volume flow rate and the mass flow rate to the following equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>u_\perp = \frac{\dot{V}}{A}\\[0.5em]
u_\perp =\frac{\dot{m}}{\rho \cdot A}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Thus, if we want to impose a volume or mass flow rate, we really just specify the velocity again as a Dirichlet boundary condition. This has some advantages and disadvantages.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The disadvantage is that we now potentially get a fully Neumann-type boundary condition for the pressure if we deal with subsonic speeds. This is typically the case, as volume flow rate and mass flow rate boundary conditions are typically used for internal flows, such as the flow through pipes and channels, which are <em>rarely</em> supersonic. So we have to use our little trick again of fixing the pressure in one cell to a specific value, i.e. we impose a volume condition for the pressure.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The advantage, however, is that by imposing a mass flow rate and using this boundary condition exclusively for open boundaries, we can ensure that mass is conserved in our domain. What goes in has to leave, and this means our continuity equation will be happy and converge, potentially, better.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, if we do not use mass flow rate boundary conditions and opt for a combination of velocity inlets and pressure outlets, there is no guarantee that we will conserve mass in our domain. If we are using an unstructured grid with tetrahedron or polyhedron elements, then we are inducing numerical diffusion. Combining that with a low-order upwind-based scheme, we will diffuse the results even further. This will artificially slow down the flow, and this leads to a reduced velocity at the outlet, which will not conserve mass.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, the remedy here is that we simply look at the ratio of the computed mass flow rate at the inlet and outlet and multiply the velocities at the outlet by that value. This can be given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>\dot{m}_{in}=\rho \cdot u_{in}\cdot A\\[0.5em]
\dot{m}_{out}=\rho \cdot u_{out}\cdot A\\[0.5em]
r_m=\frac{\dot{m}_{in}}{\dot{m}_{out}}\\[0.5em]
u_{out, corrected}=u_{out}\cdot r_m</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The first three equations here are computed once (i.e. we compute the mass flow rate once at the inlet, once at the outlet, and we compute the ratio once). We then use this ratio to compute a corrected outlet velocity [katex]u_{out, corrected}[/katex]. In this way, we ensure mass is conserved.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, regardless of which boundary condition pairing we are using, we run into trouble. Pure velocity inlet and outlet conditions, such as those given by the mass flow inlet and outlet, result in a fully Neumann-type boundary condition for the pressure, and we have to fix the pressure through other means. A combination of velocity inlet and pressure outlet will avoid the issue with the pressure, but we now have to start adjusting the mass flow rate through velocity scaling.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For completeness, the boundary conditions for a mass or volume flow inlet are given as:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet (see equations above for how to calculate the velocity)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Dirichlet or Neumann, depending on whether a constant temperature should be imposed or if the temperature is unknown at the inlet.</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>At the outlet, we would impose the following conditions:</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Velocity</strong>: Dirichlet (again, see equations above for how to calculate the velocity)</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Pressure</strong>: Neumann</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><strong>Temperature</strong>: Neumann</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>While we could also state the boundary conditions for a supersonic compressible flow (i.e. fully Dirichlet at the inlet and fully Neumann at the outlet), I'll refrain from doing so, as I can't really think of an application where this would be useful. If you know of an application, let me know, and I'll happily change the text here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the end, open boundaries will always pose some challenges, and our choices can have a noticeable influence on the results. We always need to verify that our boundary conditions are doing what we want them to, and a lot of issues with simulations can be traced back to incorrect boundary conditions. I think you get the point; I'll leave it at that!</p>
<!-- /wp:paragraph -->

<!-- wp:heading -->
<h2 class="wp-block-heading" id="aioseo-summary">Summary</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>You survived my boundary condition rant. Congratulations. We started by looking at some of the challenges we face with boundary conditions, in particular with open boundary conditions. Then, we reviewed the three fundamental types that exist: Dirichlet, Neumann, and Robin-type boundary conditions. We also looked at the two different ways to implement them, either through no mesh modification or using ghost cells.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We then put that theoretical knowledge into practice. We reviewed derived boundary conditions, such as solid walls, symmetry planes, and various inlets and outlets, along with some modelling issues that we face based on how we want to treat our open boundary conditions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Boundary conditions only get more complicated as we increase the modelling complexity. The more we want to resolve, the more unknown quantities we have to prescribe at the inlet for which we typically don't have any reasonable values or estimates at hand. Scale-resolved turbulence modelling is the prime example here. Imposing physically correct fluctuations at the inlet for Large-eddy Simulations (LES) and Direct Numerical Simulations (DNS) are still unsolved questions, even though some progress has been made here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you experience convergence issues and you are happy it is not due to your mesh, then check your boundary conditions. Is there a way to improve them? Do you understand all the options your solver exposes here, and could you tweak them to make your boundary conditions align better with the case you are solving? Be critical of your boundary conditions, and your simulations will improve!</p>
<!-- /wp:paragraph -->