<!-- wp:paragraph -->
<p>Running CFD simulations on a single core allows us to perform simple 2D simulations, perhaps even with turbulence models activated, to extract some simple results. However, once we want to run some more realistic cases of industrial or academic relevance, we often have to utilise parallelisation to receive simulation results in a fraction of the time compared to a single-core simulation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If parallelisation were a simple affair, i.e. simply telling our CFD solver how many cores to use and then expecting a proportional speed-up, we wouldn't need this article, and CFD engineers would not be forced to work with eccentric computer scientists to get good parallelisation performance.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Parallelisation is a simple topic at first glance, but the devil is in the details. We will learn about how parallel performance is achieved on high-performance computing (HPC) clusters, which hardware is used, how to achieve good parallel performance (and how to quantify it), as well as the cost of parallelisation. We will also look at concrete code examples for parallelising a simple CFD solver using common parallelisation approaches for running simulations in parallel on the CPU and GPU.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you have the feeling that parallelisation is a topic you haven't spent much time with but ought to give it some attention, then this article is for you. It shows you how to extract the most computational power out of your simulations, how to use computational resources responsibly, as well as what bottlenecks exist in parallel computing that still require ongoing research.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It is one of those articles that likely takes <em>a bit longer</em> to read through, so I hope you have a strong brew next to you. This article was produced using approximately 31 TWINGINGS Earl Grey teas, 13 Meßmer Madame Grey teas, 17 17-grain Walnut-Almond teas, and about 5 KitKat hot chocolates. I recommend you consume the same. Here is to violent bladder failure.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading">Download Resources</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>All developed code and resources in this article are available for download. If you are encountering issues running any of the scripts, please refer to the <a href="https://cfd.university/blog/setting-up-a-programming-environment-to-develop-cfd-codes/#aioseo-notes-on-how-to-run-scripts-downloaded-from-cfd-university" target="_blank" rel="noopener" title="">instructions</a> for running scripts downloaded from this website.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul class="wp-block-list"><!-- wp:list-item -->
<li><strong>Download</strong>: <a href="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/heat1DCode.zip" title="">Parallelised Heat equation</a></li>
<!-- /wp:list-item --></ul>
<!-- /wp:list -->
 
<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" id="aioseo-in-this-series">In this series</h2>
<!-- /wp:heading -->

<!-- wp:shortcode -->
[custom_category_posts_list category_slug="10-key-concepts-everyone-must-understand-in-cfd"]
<!-- /wp:shortcode -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" id="aioseo-in-this-article">In this article</h2>
<!-- /wp:heading -->

<!-- wp:aioseo/table-of-contents {"mode":"standalone","headings":[{"content":"Introduction","level":2,"anchor":"aioseo-introduction","blockClientId":"a3dba81f-463c-46be-a441-316c8261bb00","hidden":false,"editedContent":"","editedOrder":1,"headings":[]},{"content":"Flynn's taxonomy: The 4 types of parallelisation","level":2,"anchor":"aioseo-flynn's-taxonomy-the-4-types-of-parallelisation","blockClientId":"25d86b09-78fe-4da6-9309-80475fed20dd","hidden":false,"editedContent":"","editedOrder":2,"headings":[{"content":"Single instruction, single data (SISD)","level":3,"anchor":"aioseo-single-instruction-single-datasisd","blockClientId":"57811f67-19aa-42c9-a5ca-7c61093747f9","hidden":false,"editedContent":"","editedOrder":3,"headings":[]},{"content":"Single instruction, multiple data (SIMD)","level":3,"anchor":"aioseo-single-instruction-multiple-datasimd","blockClientId":"1fba944d-34af-490b-8cac-d445d5a7795a","hidden":false,"editedContent":"","editedOrder":4,"headings":[]},{"content":"Multiple instruction, single data (MISD)","level":3,"anchor":"aioseo-multiple-instruction-single-datamisd","blockClientId":"f02eb3d3-2683-4d35-b5b5-5e0bd95c17a5","hidden":false,"editedContent":"","editedOrder":5,"headings":[]},{"content":"Multiple instruction, multiple data (MIMD)","level":3,"anchor":"aioseo-multiple-instruction-multiple-datamimd","blockClientId":"122b2871-da2c-4750-8773-e69cfade74bd","hidden":false,"editedContent":"","editedOrder":6,"headings":[]}]},{"content":"Understanding the hardware our simulations run on","level":2,"anchor":"aioseo-understanding-the-hardware-our-simulations-run-on","blockClientId":"a372eaf2-7a3e-411c-a38a-5880c9afb1a5","hidden":false,"editedContent":"","editedOrder":7,"headings":[]},{"content":"Performance and bottlenecks","level":2,"anchor":"aioseo-performance-and-bottlenecks","blockClientId":"b22c0f3e-1c63-4a3c-868e-36e35dc5a80b","hidden":false,"editedContent":"","editedOrder":8,"headings":[{"content":"Amdahl's law","level":3,"anchor":"aioseo-amdahl's-law","blockClientId":"2a06f65f-7c0b-4865-b07d-698234d411de","hidden":false,"editedContent":"","editedOrder":9,"headings":[]},{"content":"Strong scaling","level":3,"anchor":"aioseo-strong-scaling","blockClientId":"49465f2c-c67b-4828-bae9-7c5249a0a63c","hidden":false,"editedContent":"","editedOrder":10,"headings":[]},{"content":"Weak scaling","level":3,"anchor":"aioseo-weak-scaling","blockClientId":"f10f7b7a-9f27-4f35-b9d7-bc32fafc8c14","hidden":false,"editedContent":"","editedOrder":11,"headings":[]},{"content":"The optimal number of cores for your simulation","level":3,"anchor":"aioseo-the-optimal-number-of-cores-for-your-simulation","blockClientId":"c04404d5-8796-498b-b671-04781d01e7ab","hidden":false,"editedContent":"","editedOrder":12,"headings":[]},{"content":"The roofline memory model","level":3,"anchor":"aioseo-the-roofline-memory-model","blockClientId":"87af68b5-4fb2-40a1-8ea2-b0edf5f9225b","hidden":false,"editedContent":"","editedOrder":13,"headings":[]},{"content":"Using space-filling curves","level":3,"anchor":"aioseo-using-space-filling-curves","blockClientId":"8b93e3ae-3c00-4096-8b38-d2e81d506790","hidden":false,"editedContent":"","editedOrder":14,"headings":[]},{"content":"The gold standard: Graph partitioning-based domain decomposition","level":3,"anchor":"aioseo-the-gold-standard-graph-partitioning-based-domain-decomposition","blockClientId":"c8fc59a1-d462-4e25-a961-690a7a03a939","hidden":false,"editedContent":"","editedOrder":15,"headings":[]}]},{"content":"Parallelisation frameworks","level":2,"anchor":"aioseo-parallelisation-frameworks","blockClientId":"af728dd8-b038-4ad4-9cc1-0e46f7a8a30f","hidden":false,"editedContent":"","editedOrder":16,"headings":[{"content":"Shared and distributed memory approaches","level":3,"anchor":"aioseo-shared-and-distributed-memory-approaches","blockClientId":"08bf4de0-6047-4ae5-a82a-13c1f24745aa","hidden":false,"editedContent":"","editedOrder":17,"headings":[{"content":"Race conditions","level":4,"anchor":"aioseo-race-conditions","blockClientId":"de134342-847e-4ce1-a5bb-2126f41423af","hidden":false,"editedContent":"","editedOrder":18,"headings":[]},{"content":"Deadlocks","level":4,"anchor":"aioseo-deadlocks","blockClientId":"a6eed34e-8d34-4553-918f-1213ee1ae71d","hidden":false,"editedContent":"","editedOrder":19,"headings":[]}]},{"content":"A sequential example code","level":3,"anchor":"aioseo-a-sequential-example-code","blockClientId":"8b5bfbcb-8ca0-4af3-95c6-2e4254e000ed","hidden":false,"editedContent":"","editedOrder":20,"headings":[]},{"content":"OpenMP","level":3,"anchor":"aioseo-openmp","blockClientId":"76d4c044-0cd7-4ca8-a60b-bdfcb0b768b8","hidden":false,"editedContent":"","editedOrder":21,"headings":[]},{"content":"CUDA","level":3,"anchor":"aioseo-cuda","blockClientId":"b065fe8c-0224-47a8-8eda-a6b9ab9a57f9","hidden":false,"editedContent":"","editedOrder":22,"headings":[]},{"content":"Messenger Passing Interface (MPI)","level":3,"anchor":"aioseo-messenger-passing-interfacempi","blockClientId":"4e28bcc7-dbe7-4197-bc4d-57823c21b9e3","hidden":false,"editedContent":"","editedOrder":23,"headings":[]},{"content":"Case study: Comparing speed-up for different parallelisation strategies","level":3,"anchor":"aioseo-case-study-comparing-speed-up-for-different-parallelisation-strategies","blockClientId":"f90aa386-68f9-46e9-8318-dd783d4252aa","hidden":false,"editedContent":"","editedOrder":24,"headings":[]}]},{"content":"Challenges in code parallelisation for CFD applications","level":2,"anchor":"aioseo-challenges-in-code-parallelisation-for-cfd-applications","blockClientId":"7e9d8f21-cd0f-4e8b-a4ab-0e38ec2f0da6","hidden":false,"editedContent":"","editedOrder":25,"headings":[{"content":"Parallelisations of multigrid solvers","level":3,"anchor":"aioseo-parallelisations-of-multigrid-solvers","blockClientId":"8acaa769-f3a4-42ef-b027-f2dd7309d2c8","hidden":false,"editedContent":"","editedOrder":26,"headings":[]},{"content":"Parallel input and output (I/O)","level":3,"anchor":"aioseo-parallel-input-and-outputio","blockClientId":"f03e65e5-79f1-489d-8380-f6813d82811c","hidden":false,"editedContent":"","editedOrder":27,"headings":[]},{"content":"Coupling of multiphysics solver","level":3,"anchor":"aioseo-coupling-of-multiphysics-solver","blockClientId":"5c67d7ce-8164-4149-b3a7-de9d61a7540d","hidden":false,"editedContent":"","editedOrder":28,"headings":[]},{"content":"Parallelisations for adaptive mesh refinement (AMR)","level":3,"anchor":"aioseo-parallelisations-for-adaptive-mesh-refinementamr","blockClientId":"60520b62-a6d1-4537-b79e-239b507ec354","hidden":false,"editedContent":"","editedOrder":29,"headings":[]},{"content":"Issues in the age of exascale computing","level":3,"anchor":"aioseo-issues-in-the-age-of-exascale-computing","blockClientId":"ba71f47f-3b14-42b0-a978-c89c9c20a5cf","hidden":false,"editedContent":"","editedOrder":30,"headings":[]}]},{"content":"Summary","level":2,"anchor":"aioseo-summary","blockClientId":"6bf7f706-84c2-4521-8f9b-04b1a8408ac9","hidden":false,"editedContent":"","editedOrder":31,"headings":[]}]} -->
<div class="wp-block-aioseo-table-of-contents"><ul><li><a href="#aioseo-introduction">Introduction</a></li><li><a href="#aioseo-flynn's-taxonomy-the-4-types-of-parallelisation">Flynn's taxonomy: The 4 types of parallelisation</a><ul><li><a href="#aioseo-single-instruction-single-datasisd">Single instruction, single data (SISD)</a></li><li><a href="#aioseo-single-instruction-multiple-datasimd">Single instruction, multiple data (SIMD)</a></li><li><a href="#aioseo-multiple-instruction-single-datamisd">Multiple instruction, single data (MISD)</a></li><li><a href="#aioseo-multiple-instruction-multiple-datamimd">Multiple instruction, multiple data (MIMD)</a></li></ul></li><li><a href="#aioseo-understanding-the-hardware-our-simulations-run-on">Understanding the hardware our simulations run on</a></li><li><a href="#aioseo-performance-and-bottlenecks">Performance and bottlenecks</a><ul><li><a href="#aioseo-amdahl's-law">Amdahl's law</a></li><li><a href="#aioseo-strong-scaling">Strong scaling</a></li><li><a href="#aioseo-weak-scaling">Weak scaling</a></li><li><a href="#aioseo-the-optimal-number-of-cores-for-your-simulation">The optimal number of cores for your simulation</a></li><li><a href="#aioseo-the-roofline-memory-model">The roofline memory model</a></li><li><a href="#aioseo-using-space-filling-curves">Using space-filling curves</a></li><li><a href="#aioseo-the-gold-standard-graph-partitioning-based-domain-decomposition">The gold standard: Graph partitioning-based domain decomposition</a></li></ul></li><li><a href="#aioseo-parallelisation-frameworks">Parallelisation frameworks</a><ul><li><a href="#aioseo-shared-and-distributed-memory-approaches">Shared and distributed memory approaches</a><ul><li><a href="#aioseo-race-conditions">Race conditions</a></li><li><a href="#aioseo-deadlocks">Deadlocks</a></li></ul></li><li><a href="#aioseo-a-sequential-example-code">A sequential example code</a></li><li><a href="#aioseo-openmp">OpenMP</a></li><li><a href="#aioseo-cuda">CUDA</a></li><li><a href="#aioseo-messenger-passing-interfacempi">Messenger Passing Interface (MPI)</a></li><li><a href="#aioseo-case-study-comparing-speed-up-for-different-parallelisation-strategies">Case study: Comparing speed-up for different parallelisation strategies</a></li></ul></li><li><a href="#aioseo-challenges-in-code-parallelisation-for-cfd-applications">Challenges in code parallelisation for CFD applications</a><ul><li><a href="#aioseo-parallelisations-of-multigrid-solvers">Parallelisations of multigrid solvers</a></li><li><a href="#aioseo-parallel-input-and-outputio">Parallel input and output (I/O)</a></li><li><a href="#aioseo-coupling-of-multiphysics-solver">Coupling of multiphysics solver</a></li><li><a href="#aioseo-parallelisations-for-adaptive-mesh-refinementamr">Parallelisations for adaptive mesh refinement (AMR)</a></li><li><a href="#aioseo-issues-in-the-age-of-exascale-computing">Issues in the age of exascale computing</a></li></ul></li><li><a href="#aioseo-summary">Summary</a></li></ul></div>
<!-- /wp:aioseo/table-of-contents -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" id="aioseo-introduction">Introduction</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We all remember our humble beginnings in CFD. For me, it was the classical NACA 0012 simulation at a zero-degree angle of attack. While I rarely jump out of my seat these days when I see the contour plots around this airfoil, back then, I was blown away. It was so powerful that I decided that CFD is my calling, my passion, my future. I even went as far as changing my Facebook profile picture to this contour plot (is Facebook still alive?).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Chances are, your first simulation wasn't much different, at least in terms of complexity. You likely ran a tutorial case that could be executed on your PC or laptop in a reasonable amount of time. Perhaps you made some changes to the input, played around with the test cases and, like me, realised that changes to the input had drastic effects on the simulation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In my case, changing the angle of attack so that the airfoil would stall meant that convergence was no longer given. I found that fascinating and wanted to know more; others would have, understandably, given up, but then again, those would likely not commit to reading an unnecessarily long article on parallelisation and high-performance computing in CFD with the odd unhinged commentary.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Eventually, you and I gained confidence in our CFD skills, and we wanted to simulate our own cases, likely something more exciting than a 2D channel flow. So, we created 3D geometries and then realised that our PCs or laptops would not be able to run those simulations in a few minutes. I remember having my laptop and PC at that time running in parallel, both doing one simulation each and both running for about 24 hours per simulation. That was my first serious attempt at CFD; yours may have been similar.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But then, I was introduced to the world of high-performance computing (HPC). HPC to an aspiring CFD practitioner is like the discovery of Viagra for a retired Person; it's a game changer (or starter?). All of a sudden, I was able to run simulations in less than an hour that would otherwise take me days. This was reason enough to get acquainted with HPC, even though there was a step learning curve (I also had an HPC assignment due, which <em>likely</em> contributed to my motivation).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When we are dealing with HPC, we typically mean HPC clusters, which sometimes are also called supercomputers, because whoever came up with this name was suffering a lack of serious creativity. Here are my takes:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>The Mother of all FLOPs (MOAF)

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Clusterfuck

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Cache Me If You Can

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>An HPC cluster is nothing but a bunch of PCs chained together. The simplest cluster we can think of is a bunch of Raspberry Pies linked together. There is even an official <a href="https://www.raspberrypi.com/tutorials/cluster-raspberry-pi-tutorial/" target="_blank" rel="noopener" title="">tutorial by the makers of Raspberry Pi</a>, showing you how you can do that. It is weirdly affordable, and you can decide next time you buy a new gaming PC if you really need that or your own HPC cluster on your desk.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While the Raspberry Pi example is good to understand how a cluster works, if we need serious computing power, as we do for CFD applications, we really want to use dedicated hardware. All major chip manufacturers offer dedicated compute hardware to build clusters, and these are somewhat different to what you would find in PCs and laptops. The main difference is speed and performance. They have more cores, more memory, and a network connection so fast that it would melt your router (<em>maybe</em>).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Twice a year, <a href="https://www.top500.org/lists/" target="_blank" rel="noopener" title="">TOP500</a> uploads a list of the 500 fastest <s>clusterfucks</s> HPC clusters in the world. They list, among other details, the number of cores, the performance, as well as the power required to keep the cluster running. The performance is measured in how many floating-point operations can be done per second on the cluster. The unit is PFLOPs, or Peta Floating-point Operations Per second, where Peta stands for [katex]10^{15}[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we designed a new cluster, and we could get a staggering 1 PFLOPs in performance, we could perform [katex]10^{15}[/katex] multiplications/divisions/additions/subtractions per second on floating point numbers. Let's put this into perspective. If we have a mesh with 10 billion cells, we have [katex]10^{10}[/katex] cells. We can perform [katex]10^{15} / 10^{10} = 10^5[/katex], or 100,000 operations per second on <strong>each cell</strong>. Imagine what you could simulate with 10 billion cells. <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/the-origin-of-turbulence-and-direct-numerical-simulations-dns/" target="_blank" rel="noopener" title="">Direct Numerical Simulations</a> (DNS) would be the norm.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Where would this impressive cluster rank in the TOP500? Nowhere. 1 PFLOPs in performance isn't impressive any more, and we likely wouldn't even make the top 1000. These days, we have achieved exascale computing. That is, instead of measuring performance in PFLOPs, we use EFLOPs, or Exa FLOPs. Exa stands for [katex]10^{18}[/katex], and the best supercomputers in the world go beyond 1 EFLOPs.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>All of this performance needs to be leveraged, and this is where code parallelisation comes in. We can't just write a CFD solver and then hope that our HPC cluster will be able to run it. If we write software without consideration given to parallelisation, we can't use more than one core. There is no point running our software on a 10-million-core cluster if we can only use one of them.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, we need to parallelise our code, meaning we have to modify our code so it can use more than 1 core. With that come unique challenges, and I want to explore those in this article, as well as performance metrics that help us to measure if we have achieved a good parallel performance, and some frameworks we can use to parallelise our code.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We have our work cut out for ourselves; let us see how we can do that.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" id="aioseo-flynn's-taxonomy-the-4-types-of-parallelisation">Flynn's taxonomy: The 4 types of parallelisation</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Flynn's taxonomy allows us to identify 4 separate parallelisation approaches based on instruction and data parallelism. If we are dealing with multiple instructions, each processor will work on separate instructions. If we have multiple data sets, this means that processors work on different data. An overview of Flynn's taxonomy is given in the following figure:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"400px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/flynns_taxonomy.png" alt="A schematic overview of Flynn's taxonomy into single and multiple data and instructions." class="wp-image-5550" style="width:400px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://en.wikipedia.org/wiki/Flynn%27s_taxonomy" target="_blank" rel="noopener" title="">Wikipedia</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>When I first saw this classification, I had difficulties understanding it; it seemed a bit abstract. So let's breathe some life into this figure and give examples for each quadrant.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-single-instruction-single-datasisd">Single instruction, single data (SISD)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Single instruction, single data (SISD) is the paradigm you will be most familiar with. It means we have a single instruction, executed by a single processor, and it is working on a piece of data. If you have ever written a simple CFD solver, even just a code to solve a model equation like the heat diffusion, advection, or Burgers equation, you wrote a SISD program.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You had a single core working through your instructions, e.g. first compute the gradients, then perform the time integration, then update the solution, etc. All of this was performed by a single processor, and all of this was done one at a time. In terms of data, that was coming from RAM, and all of that RAM was available to you. Thus, your processor used only one set of instructions, and it was operating in a single set of memory. This is also called a sequential application.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-single-instruction-multiple-datasimd">Single instruction, multiple data (SIMD)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Single instruction, multiple data (SIMD) is the most important parallelisation category for us in CFD. When we talk about code parallelisation, we talk about SIMD parallelisation. Code parallelisation means that we now use more than one processor to run our code. All processors execute the same instruction, but they operate on different data.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In practice, this means that each processor will still perform the same steps as in our previous example, i.e. each processor will compute gradients, then integrate in time, etc. They will all work at the same time but on different data. This means that if I want to parallelise my code and I run a simulation with a 10 million cell mesh on 4 processors, each processor will perform the gradient calculation, time integration, etc., on only 2.5 million cells.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The speed-up, then, is coming from the fact that for each individual processor, it seems like the problem size is only 2.5 million cells, rather than the full 10 million cells, and so in an ideal world, we would expect (or rather, hope) that we can a 4-times faster simulation with 4 processors compared to a single processor simulation (e.g. SISD).</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-multiple-instruction-single-datamisd">Multiple instruction, single data (MISD)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Multiple instruction, single data (MISD) is a concept that only really exists for completeness in Flynn's taxonomy. While this <em>parallelisation</em> does exist in the real world, it does not make sense in the world of high-performance computing. The reason is that MISD performs multiple different instructions, but all on the same data. If we take the example from before, each processor gets the full 10 million cells mesh. If they all have to operate on it, we won't see a speed-up.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So why would we ever use this? In systems where redundancies are important, MISD is the way to go. For example, an aeroplane measures airspeed with 3 different sensors. It does that because knowing the airspeed is the difference between flying and stalling (and thus falling out of the sky). Thus, the onboard computers that calculate the airspeed are getting their input from three separate sensors (which all provide the same data), and because we have more than one computer, we have multiple instructions operating on this single dataset.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, MISD is an important paradigm, but just not in high-performance computing.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-multiple-instruction-multiple-datamimd">Multiple instruction, multiple data (MIMD)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>If you like complexity, then Multiple Instruction, multiple data (MIMD) is for you. It contains the same multiple data concept we already saw in SIMD, and this really is where computational gains are coming in (breaking a larger problem down into smaller subdomains and solving these smaller subdomains for faster simulation times).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With MIMD, we open ourselves up to multiphysics problems. The simplest and most studied one would be Fluid-Structure Interactions (FSI). Here, we solve a CFD problem and couple that with an FEA solver. Both the CFD and FEA solver have their own data to work on (multiple data). A CFD solver also would have different instructions compared to a FEA solver (multiple instructions), e.g. there is no "solve continuity equation" in the FEA solver, nor is there a "compute displacements and von Mises stresses" in the CFD solver.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Whenever we are coupling two or more solvers together, we get into multiple instructions territory. As long as we leverage multiple data as well, we have a viable parallelisation strategy. The challenges arise here in determining which resources to allocate to which solvers. If we want to perform a single time integration between CFD and FEA, then the FEA solver may only take 1/5 of the time to update the timestep compared to the CFD solver. If we give them the same resources, the FEA solver will waste most of them.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, we need to think about how to balance resources allocated to each solver, and this is known as <em>load balancing</em>. This is a crucial aspect in high-performance computing, and if we don't have a good load balance in our simulation, all of our code parallelisation is pointless.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For completeness, load balancing also affects SIMD, i.e. if we have 10 million cells and 4 processors, we want to make sure that each processor gets an equal amount of work (i.e. 2.5 million cells). If we give 3 processors just 1 million cells and the remaining processor 7 million cells, then we are going to have a load imbalance. On paper, this may seem like a simple problem, but in reality, it isn't, and we will talk a lot more about the challenges later when we deal with domain decomposition techniques.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" id="aioseo-understanding-the-hardware-our-simulations-run-on">Understanding the hardware our simulations run on</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Understanding computer hardware is really important if you want to understand how performance is achieved (or lost). You may think, for example, that once your code is parallelised, you get an automatic speed-up if you use more processors. This is certainly the approach I see new students make. Whenever I ask them why they are using 96 processors for their simulation, the answer is usually "<em>because that is the maximum I am allowed to use</em>". That is the wrong answer.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you have access to a CFD solver, set up a simple test case, something with 10000 cells or less and then run this on 1 processor and the max number of processors available to you. Say you have a 4-core CPU, then run this with 4 processors. What you will see is that your 4-processor simulation is slower than your 1-processor simulation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The opposite can also happen. Say you set up a simulation to run on a single core. You then parallelise your code and run the simulation on 4 processors. You would expect the simulation to speed up by, at most, a factor of 4. You measure the speed up, and you see that your actual speed up is 5. All of this can be explained by understanding the computer hardware.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Some time ago, my beloved custom-built CFD workstation PC died (I say custom-built CFD workstation, this is the excuse we give ourselves to splurge on a high-spec PC to run some CFD simulations, only to <em>realise</em> that your <em>CFD workstation</em> is also an excellent gaming rig. The amount of yoghurt and excavators I have delivered to Scotland in <a href="https://store.steampowered.com/app/227300/Euro_Truck_Simulator_2/" target="_blank" rel="noopener" title="">European Truck Simulator 2</a> is embarrassingly high ... just me?).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I must have told that story before, but in a nutshell, driving at night gives probably the best immersion, but trucks also have quite a few gears, and so I was busy shifting gears while traversing the Scottish Highlands. It turns out that if your partner tries to sleep in the same room, those gear shifts are really annoying, and she told me as much. Suffice it to say, I no longer have access rights to my steering wheel.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In any case, that PC died, and so I bought another somewhat decent PC, at least spec-wise. It had a GIGABYTE motherboard, a brand I had no idea existed before, but it seemed legit, so I didn't question it. The PC arrived, worked a good 2 months, so the PC could no longer be returned, and at that point, the PC started to crash hard. 10 bluescreens of death or more were common per day, and they would happen out of the blue (no pun intended).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>After trying to reinstall Windows about 10 times, changing hardware, and examining crash dumps, I was ready to give up on my PC. And then, I saw this video:</p>
<!-- /wp:paragraph -->

<!-- wp:embed {"url":"https://www.youtube.com/watch?v=qtCY53Zwru4","type":"video","providerNameSlug":"youtube","responsive":true,"className":"wp-embed-aspect-16-9 wp-has-aspect-ratio"} -->
<figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
https://www.youtube.com/watch?v=qtCY53Zwru4
</div></figure>
<!-- /wp:embed -->

<!-- wp:paragraph -->
<p>Apparently, the motherboard I had came with malware on the hardware level. No matter what changes I made to my operating system, the motherboard would randomly crash my PC, and that's also why all of the crash dumps would not make any sense whatsoever. I upgraded the BIOS, but even that wasn't working. So, the issue may have been somewhere else entirely, but I could not be bothered investigating this further.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I told my line manager that my PC died and I needed a new <em>CFD workstation</em>. I got another beefy machine, and while I use it for work (I am writing this article currently on it), it is also exceptionally well-suited to play <a href="https://www.rocketleague.com/en/" target="_blank" rel="noopener" title="">Rocket League</a> on it. Who would have thought?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There is a point to make here (believe it or not). I thought I could tell you about this PC story and then transition to the PC hardware. I wanted to take a picture of that PC (for some reason, I still hold on to it) and show you the motherboard, RAM, CPU, GPU, hard disk, etc. and then go through each component and say something like "this is the most expensive picture I ever took", as in, I can't use it anymore as a PC, so it is essentially an expensive photo model. But then I took the picture, and this is what I got:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"500px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/shitty_pc_internals.jpg" alt="A pretty bad PC, not worth its weight in gold!" class="wp-image-5550" style="width:500px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Wow, I can show you where the fan is sitting, and that's probably it. Why is there so much empty space (and dust)? It is not just a bad PC, it's also a pretty bad photo model. Turns out I should have just googled a motherboard picture and saved you from my random sidebar, but you are still here, so you get partial blame, too.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's look at a normal motherboard:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"800px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/motherboard.png" alt="A schematic overview of Flynn's taxonomy into single and multiple data and instructions." class="wp-image-5550" style="width:800px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://unsplash.com/photos/a-close-up-of-a-computer-motherboard-on-a-white-surface-OKBfiF6GERE" target="_blank" rel="noopener" title="">Unsplash</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Most will likely be familiar with this. We have our central processing unit (CPU) in the middle, slightly to the right (hidden under the metallic cover). Below that are 4 slots to insert random access memory (RAM) modules, and to the left are 2 Peripheral Component Interconnect (PCI) slots for graphical processing units (GPUs). Well, there are other things we could put here, but typically, we only place GPUs here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I like this motherboard because on the top right, it states: "TUF GAMING Z590 MILITARY GRADE PERFORMANCE". What exactly is military-grade performance? I know that products sometimes boast military-grade durability when they follow, for example, the <a href="https://en.wikipedia.org/wiki/MIL-STD-810" target="_blank" rel="noopener" title="">military standard</a> for stress testing. But what is military-grade performance? As <a href="https://melmagazine.com/en-us/story/what-does-military-grade-mean-marketing" target="_blank" rel="noopener" title="">one source</a> succinctly puts it: Military-grade is just military-grade marketing bullshit. Moving on.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can summarise that a normal PC, or laptop, will have a CPU, some RAM, some main memory (hard disk), as well as potentially some add-on devices like a GPU. Add some cooling for CPUs and GPUs to avoid overheating, and you have yourself a PC. Probably, I am not telling you anything new here. But let's now explore what a high-performance computing cluster looks like.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The following schematic shows how an HPC cluster is structured.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"700px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/hpc_cluster_schematic.png" alt="The details of a compute node with its sockets, RAM< and cooling." class="wp-image-5550" style="width:700px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://www.researchgate.net/figure/High-level-organization-of-the-Blue-Gene-L-supercomputer-All-65-536-compute-nodes-are_fig1_220439485" target="_blank" rel="noopener" title="">Almasi et al. 2003</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Starting on the right, we have the entire HPC cluster. Its size is usually large enough to warrant building an entire building around it, which is sometimes misleadingly called a data centre (though data centres can also be interpreted as a catch-all name for anything from long-term storage (e.g. Dropbox), to cloud computing, to high-performance computing clusters).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The HPC cluster, or system, is made up of individual cabinets. Each of these cabinets will house a number of racks (which are called node boards in the schematic above), which contain a number of compute nodes (called compute cards in the schematic above). If you are talking to a <em>professional</em>, they may just use the word node, and it appears that the infantile urge to abbreviate everything (LOL, ROFL, LMAO, yes, I know, I'm old) does not stop when you have a PhD (which is an abbreviation as well, now that I think about it ...).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Each node (oh no, I am one of <em>them</em>), I mean, each compute node, may contain one or more sockets. There are <a href="https://www.youtube.com/watch?v=3JaOVs9amMk&list=RD3JaOVs9amMk&start_radio=1" target="_blank" rel="noopener" title="">different names for the same thing</a>, but a socket is equivalent to a CPU on a consumer PC or laptop. Essentially, each socket will contain a number of so-called cores, or processors. On a consumer PC, we may have a 4-core CPU, but in HPC land, we typically have quite a few more per socket, starting at 16 cores, and going up to 64 or even 128 cores.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's look at some real examples. The figure below shows a typical HPC cluster, as you may find it in the wild.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"700px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/hpc_cluster.jpg" alt="The inside room of an HPC cluster with racks of compute nodes left, right, and center." class="wp-image-5550" style="width:700px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://www.researchluxembourg.org/en/a-first-high-performance-computing-call/" target="_blank" rel="noopener" title="">Research Luxembourg</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Again, whoever is setting up HPC clusters seems to spend a lot of effort on making HPC clusters look sexy. Some will plaster wallpapers all over the place, some will install mood lighting, and how is this different from a <a href="https://en.wikipedia.org/wiki/Script_kiddie" target="_blank" rel="noopener" title="">script kiddie</a> spending way too much on LED lights for their <em>gaming</em> PC?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The more I think about it, people working in HPC are just grown-up kids. And after this thought entered my mind, I just couldn't stop thinking that everyone in the Harribo commercials is just someone working as an HPC admin. I mean, how is the following not an annual meet-up of HPC admins?</p>
<!-- /wp:paragraph -->

<!-- wp:embed {"url":"https://www.youtube.com/watch?v=qv64gSHZJl8","type":"video","providerNameSlug":"youtube","responsive":true,"className":"wp-embed-aspect-16-9 wp-has-aspect-ratio"} -->
<figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
https://www.youtube.com/watch?v=qv64gSHZJl8
</div></figure>
<!-- /wp:embed -->

<!-- wp:paragraph -->
<p>Congratulations, you just watched an advert, and no, of course I'm not getting paid for this (did you really think Harribo is sponsoring me?). Moving on.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Within each cabinet, we have our racks, each stuffed with compute nodes, and this is shown below:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/hpc_cluster_collection_of_nodes.jpg" alt="The details of one single rack containing several compute nodes." class="wp-image-5550" style="width:600px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://www.ctoservers.com/openfoam-computational-fluid-dynamics-hpc-cluster-180-xeon-cpu-cores--672gb-memory--ssd-2tb-sas-1810-p.asp" target="_blank" rel="noopener" title="">CTO Servers</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>If you click through to CTO servers, you'll see that this beauty is sold as a stand-alone OpenFOAM HPC cluster. And I may add, looking at the specs, it is very reasonably priced ... I might get one for myself ... (I'm not, (and, no, again, not getting paid to promote them either, just think this is a cool product, but I love bare metal hardware, you can sell me anything)).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we take one of the compute nodes out of the rack, we start to see hardware that finally resembles a consumer PC or laptop. This is shown below:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"700px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/hpc_cluster_node.png" alt="The details of a compute node with its sockets, RAM< and cooling." class="wp-image-5550" style="width:700px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://www.advancedclustering.com/act_systems/hpc-compute-node/" target="_blank" rel="noopener" title="">Advanced Clustering Technologies</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Here, we have two sockets in the centre, both shielded by a metallic heat exchanger device. Each socket may contain 16, 32, 64, or 128 cores, typically, and so if we have two of these sockets per node, we may end up with a total of 32, 64, 128, or 256 cores per node. That is some serious computing power! To either side of the sockets, we have our main memory (RAM), and we have some fans at the bottom.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Other compute nodes may additionally house a small GPU as an add-on, though we can also get entire GPU nodes. If you want to have some fun, google "what is the most expensive Nvidia GPU". At the time of writing, the H100 is still leading the market with its ~£30,000 price tag. For the same money, you can almost get a Tesla Model S, and I am sure we are not far away from Nvidia's GPU becoming more expensive than electric cars.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I mean, at this rate, we may see celebrities start to wear Nvidia GPUs as status symbols instead of jewellery or fashion brands. Me: "Create a picture of a celebrity of your choice wearing a Nvidia GPU like a status symbol". ChatGPT:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"250px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/nvidia_status_symbol.png" alt="A made-up celebrity scratch wearing a GPU like a necklace. Weird and silly." class="wp-image-5550" style="width:250px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>There are three possibilities for how we can create our HPC system. Either we have a homogeneous system, using only CPUs or GPUs, or we have a heterogeneous system, having a mix of CPUs and GPUs. Most HPC systems these days are heterogeneous and cater for both CPU and GPU applications, though you will find more and more dedicated GPU clusters, which are predominantly used for AI, so we can create a pointless cartoon impression of celebrities wearing GPUs as status symbols.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another important aspect of HPC clusters is their network. Nodes and cabinets are typically connected through a very high-throughput and low-latency network. A common choice here is the <a href="https://en.wikipedia.org/wiki/InfiniBand" target="_blank" rel="noopener" title="">InfiniBand</a> standard. As we will see, in most of the cases we are interested in (SIMD CFD applications), our bottleneck is memory transfer, and we spend a lot of effort squeezing the last bit of performance out of our code by placing the data as close as possible next to each other to reduce memory transfer time.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are different mechanisms by which we can achieve that, and we will look at them later in this article. But for now, I think we have gotten a good overview of the HPC hardware and architecture. Let us now explore how we can measure performance in our codes, some bottlenecks for our performance, as well as some considerations that are less commonly discussed in the HPC literature.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" id="aioseo-performance-and-bottlenecks">Performance and bottlenecks</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>OK, so we have access to a few cores now, either through our CPU on our laptop/PC, heck, even our smartphones these days come with an 8-core CPU (this will age like milk ...), we want to leverage them. We may even have access to a decent cluster, and we may be able to use a few hundred cores, for example. Should we always use all of the computational resources we have available?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For each simulation we run, there is an optimal number of cores, and so we want to know at which level of parallelism (i.e. how many cores) we get the most performance (reduction in computational time). Beyond that point, we will start to increase the computational cost (i.e. we use more cores, requiring more energy), and the performance will decrease (increase in computational time).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, we want to find out what the optimum number of cores is. There is no one-size-fits-all answer, and the optimum number of cores is a code-specific number. But there are ways in which we can establish that numerically, and so in this section, we will look at this in more detail.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The optimum number of cores is not the only thing we want to look at, though, even though the answer may be that we should be running our simulation on 128 cores for 2 days, we should ask ourselves if we really need to. Do we need to run this simulation? This question seems odd, and is probably never asked, but once we look into the economics of running large-scale simulations, we realise that we are quite heavily polluting the atmosphere with [katex]CO_2[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So the question: "Are we getting enough information out of this simulation to justify the electricity usage and [katex]CO_2[/katex] release" becomes a relevant and highly important question.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, if we want to run a <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/the-introduction-to-large-eddy-simulations-les-i-wish-i-had/" target="_blank" rel="noopener" title="">Large Eddy Simulation (LES)</a> around an airfoil at various angle of attacks, just to get a better prediction of the critical (stall) angle of attack, compared to a much cheaper <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/all-you-need-to-know-about-rans-turbulence-modelling-in-one-article/" target="_blank" rel="noopener" title="">Reynolds-averaged Navier-Stokes (RANS)</a> simulation, we should calculate the expected electricity usage and [katex]CO_2[/katex] release for both cases and make a judgement on whether we can justify the cost for obtaining a single value with a somewhat improved predictive quality.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We may come to the conclusion that no, it is not justified, and that perhaps other approaches can be explored. For example, we can create a 2D RANS mesh with a lot more resolution than our 3D LES grid and get a <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/advanced-rans-and-hybrid-rans-les-turbulence-modelling-in-cfd/#aioseo-going-beyond-fully-turbulent-the-transitional-rans-models" target="_blank" rel="noopener" title="">transitional RANS</a> model to predict the stall angle with perhaps a slightly less accurate prediction, but with a significantly reduced computational cost.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>These trade-off considerations are not commonly done. CFD practitioners are not seeing the energy bill, nor do they see any environmental reports on how their HPC usage contributes to their [katex]CO_2[/katex] footprint.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I bring this up because I generally observe a lack of awareness in my students when they run a simulation. They get upset when they can't run as many simulations as they want for their MSc thesis, but then run simulations on the cluster that fail after some time because they were not thoroughly tested. Sometimes these simulations don't even add value, and so my original question, "Are we getting enough information out of this simulation to justify the electricity usage and [katex]CO_2[/katex] release" is not that strange after all and highly relevant!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's now discuss a few metrics we can use to assess the parallel performance, and then circle back to the environmental considerations afterwards.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-amdahl's-law">Amdahl's law</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><a href="https://en.wikipedia.org/wiki/Amdahl's_law" target="_blank" rel="noopener" title="">Amdahl's law</a> is a simple yet very educational law we can use to assess parallel performance. It is so simple that it is easy to understand, yet it gives us some surprising results, especially if we have never seen it before.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's think about parallelism for a moment. Our goal is to use more than one core in the hope that our simulation time will reduce proportionally to the number of cores that we are using. As a simple example, we may say that a simulation may run exactly for 32 minutes using a single core. Then, if I use 2 cores, I would hope that my simulation only takes 16 minutes. If I use 32 cores, I would hope that my simulation only takes 1 minute. That is parallelisation in a nutshell.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But there are things which cannot be parallelised. For example, if I run on 32 cores and I want to print something to the console, like my residuals, or some information about the current time step, like the timestep size and total elapsed simulation time, only one processor will do that. If all 32 processors did that, we would get the same information printed 32 times.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Writing data to the hard drive is another aspect that is difficult to parallelise, although there are non-trivial options to do this with MPI I/O and HDF5, for example, it is a task that may also be done by only one processor. So, there will always be some portion of the code that cannot be parallelised, and we will never get a code with 100% parallelism.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>How could we express that mathematically? Let's say that [katex]T[/katex] is the total time it takes to run our simulation, so 32 minutes on 1 core, 16 minutes on 2 cores, and so on. Then, we can introduce two additional times. [katex]T_{par}[/katex] is the execution time of the code that can be parallelised, while [katex]T_{no-par}[/katex] is the part of the code that cannot be parallelised (writing to the console, or hard drive, for example). Thus, the total time is:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
T=T_{no-par} + T_{par}
\tag{1}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>So far so good (and simple). Now, let us try to express [katex]T_{no-par}[/katex] and [katex]T_{par}[/katex] as functions of [katex]T[/katex] alone. For that, we will introduce a fraction [katex]f[/katex] that is in the range of [katex][0,1][/katex]. A value of [katex]f=0.8[/katex], for example, would say that 80% of our code can be parallelised. The way we could determine that, for example, is to go through each line of our code and see if it is executed in parallel or not. Then we may have 80 lines of code that run in parallel out of 100 lines of code, so [katex]f=80/100=0.8[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can now start to weight the contributions in Eq.(1) with:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
T_{no-par} = (1-f)T\\
T_{par} = fT \\
T = (1-f)T + fT
\tag{2}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>So, we have now found a way to express the total computational time as a weighted sum of the parts of the code that can be parallelised and that cannot. Let's now also consider the speed-up [katex]s[/katex]. This is the factor by which we reduce our computational time after parallelising our code. Let's make the example simple. Let's say [katex]f=1[/katex], so everything can be parallelised. Then, we have:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
T=fT\tag{3}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we wanted to compute the speed-up, we would have to divide the right-hand side by [katex]s[/katex], i.e. we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
T=\frac{f}{s}T\tag{4}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now, we can say [katex]f=1[/katex], so if we use 32 cores for our 32-minute simulation, we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
1\, min=\frac{1}{32}32\, min\tag{5}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>But now let's extend that for cases where [katex]f[/katex] isn't 100%. So we bring back our weighted sum from Eq.(2). This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
T = (1-f)T + \frac{f}{s}T
\tag{6}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We do not divide [katex](1-f)T[/katex] by [katex]s[/katex] because that is, by definition, the part of the code that cannot be parallelised, and so we cannot speed up this part of the code. Therefore, only the part that can be parallelised will benefit from the speed-up.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Eq.(6) will give us the time it takes to run our simulation on [katex]p[/katex] processors. We can denote this time by [katex]T(p,f)[/katex], where we also include the fraction of the code that can be parallelised, i.e. [katex]f[/katex]. Thus, Eq.(6) becomes:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
T(p,f) = (1-f)T + \frac{f}{s}T
\tag{7}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Remember that [katex]T[/katex] is the total time it takes to run the simulation. On a single processor, this would be [katex]T(1,f) = T[/katex] by definition, because there is nothing to parallelise on a single core (we could also say that [katex]f=0[/katex]). This would give us the same result, i.e.:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
T(1,f) = (1-0)T + \frac{0}{s}T = T\tag{8}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>If we wanted to know the speed-up as a function of the fraction of the code that can be parallelised, i.e. [katex]f[/katex], we compute the ratio of [katex]T(1,f)/T(p,f)[/katex]. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{T(1,f)}{T(p,f)} = \frac{T}{(1-f)T + \frac{f}{s}T}
\tag{9}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can simplify this equation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{T(1,f)}{T(p,f)} = \frac{T}{(1-f)T} + \frac{T}{\frac{f}{s}T} = \frac{1}{1-f}\frac{T}{T} + \frac{1}{\frac{f}{s}}\frac{T}{T} = \frac{1}{1-f} + \frac{1}{\frac{f}{s}} = \frac{1}{(1-f) + \frac{f}{s}}
\tag{10}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is an important finding, so let me write the final result again so it stands out better:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{T(1,f)}{T(p,f)} = \frac{1}{(1-f) + \frac{f}{s}}
\tag{11}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is Amdahl's law, and it tells us that we can compute the theoretical speed-up knowing only the portion of our code that can be parallelised [katex]f[/katex] and the speed-up [katex]s[/katex]. We can use this to determine upper bounds for our parallelisation efforts. This is shown in the next figure:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/amdahls-law.png" alt="Amdahl's law plotted, where the x-axis shows the number of processors and the y-axis the speed-up. Lines are shown in a log-log plot for different parallelisation fractions of f." class="wp-image-5550" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>What I have done here is to plot the speed up, on the y-axis, we can expect for any number of cores, given on the x-axis. I have also plotted the theoretical best parallelisation, that is, if all of our code can be run in parallel. This is shown as the theoretical best line, and this corresponds to [katex]f=1[/katex]. I have plotted how our speed-up converges to a fixed value, regardless of how many processors we are using (we are assuming here that the speed-up [katex]s[/katex] is proportional to the number of cores).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, we can see that there are diminishing returns if we use more and more processors, and we can even compute the upper bound with Amdahl's law, what the best performance [katex]s_{opt}[/katex] is that we can expect. To do that, we have to compute:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
s_{opt} = \lim_{s\rightarrow \infty}\frac{1}{(1-f) + \frac{f}{s}} = \frac{1}{1-f}\tag{12}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Thus, the best speed up is determined not by the part of the code that can be parallelised, but rather by the part that cannot be parallelised, which is [katex]1/(1-f)[/katex]. So, we can find [katex]s_{opt}[/katex] numerically for different values of [katex]f[/katex] as:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>[katex]f=0.01 \rightarrow s_{opt} = 1.01[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>[katex]f=0.10 \rightarrow s_{opt} = 1.11[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>[katex]f=0.20 \rightarrow s_{opt} = 1.25[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>[katex]f=0.50 \rightarrow s_{opt} = 2.00[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>[katex]f=0.80 \rightarrow s_{opt} = 5.00[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>[katex]f=0.90 \rightarrow s_{opt} = 10.00[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>[katex]f=0.99 \rightarrow s_{opt} = 100.00[/katex]

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>This means that the number of cores we have available is not really important. Much more important is how well our code has been parallelised. Even if 99% of our code can execute in parallel, we can expect, at best, a speedup of 100. So, if we have access to, say, 1000 cores, we wouldn't be able to use all of them. We would be limited by the theoretical speed-up of 100, at most. In order to use all 1000 cores, we would first have to ensure that we have <em>at least</em> 99.9% of our code parallelised.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>These numbers may seem frightening, but in reality, it isn't that difficult to achieve parallelisation of 99.9% or even more. Look at scientific articles where people run their simulations with 10,000 cores or more successfully, i.e. seeing a corresponding speed-up. It is possible.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Having said that, I should also state that we like to cheat a bit in CFD (everybody is doing it, so that makes it Ok, right?). We typically ignore large portions of our code, and only measure the part of the code that has been parallelised. Things like reading a mesh, allocating memory, etc., are not considered. We only look at our time or iteration loop, which can, in general, be easily parallelised. This is where most of the computational time is spent, which justifies this approach.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The takeaway message is that Amdahl's law tells us that we cannot just throw an infinite number of processors at our problem; eventually, we will reach a ceiling beyond which we cannot expect more performance.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Amdahl's law is a good theoretical model to sensibilise ourselves to the fact that there are diminishing returns as we increase the number of cores. However, in reality, it is very difficult to know what the fraction [katex]f[/katex] is of our code (it turns out, just counting the lines of code isn't a reliable indicator, and even worse, if we have 1 million lines of code or more, who's got the time to do that?).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, we need a different metric that embodies the same information as Amdahl's law, but we can access that information by just measuring the performance of our code. This is where weak and strong scaling come in, and these are discussed in the next sections.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-strong-scaling">Strong scaling</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>The strong scaling measures the speed-up of a parallel code execution. We keep the problem size the same and only change the number of cores. We want to measure how the speed-up changes as we increase the number of cores. We can define the speed-up as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
s(p) = \frac{T(1,N)}{T(p,N)}
\tag{13}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We use a slightly different notation here compared to the previous section. Here, [katex]p[/katex] is the number of cores we are using, just as before, but [katex]N[/katex] is now the problem size. In our case, it would typically be the number of cells in our mesh. If we are dealing with a finite element discretisation, [katex]N[/katex] would be the number of degrees of freedom (since we can have more than a single integration point per cell). Regardless of which approach we chose, [katex]N[/katex] is always proportional to some characteristic size we can state about our problem.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The time it takes to run the simulation on one core is given as [katex]T(1,N)[/katex]. The time it takes to run the simulation on [katex]p[/katex] cores is [katex]T(p,N)[/katex], and the ratio of the two gives us the speed-up, as seen in Eq.(13). Let's look at some sample numbers, which were taken from <a href="https://hpc-wiki.info/hpc/Scaling" target="_blank" rel="noopener" title="">HPC-wiki</a>. The table below shows typical numbers you may find when you measure the execution time of your code as you increase the number of cores.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table class="has-fixed-layout"><thead><tr><th class="has-text-align-center" data-align="center">Number of cores (required nodes)</th><th class="has-text-align-center" data-align="center">Measured time (in seconds)</th></tr></thead><tbody><tr><td class="has-text-align-center" data-align="center">1 (1 node)</td><td class="has-text-align-center" data-align="center">64.4</td></tr><tr><td class="has-text-align-center" data-align="center">2 (1 node)</td><td class="has-text-align-center" data-align="center">33.9</td></tr><tr><td class="has-text-align-center" data-align="center">4 (1 node)</td><td class="has-text-align-center" data-align="center">17.4</td></tr><tr><td class="has-text-align-center" data-align="center">8 (1 node)</td><td class="has-text-align-center" data-align="center">8.7</td></tr><tr><td class="has-text-align-center" data-align="center">16 (1 node)</td><td class="has-text-align-center" data-align="center">4.8</td></tr><tr><td class="has-text-align-center" data-align="center">32 (1 node)</td><td class="has-text-align-center" data-align="center">2.7</td></tr><tr><td class="has-text-align-center" data-align="center">64 (2 nodes)</td><td class="has-text-align-center" data-align="center">1.6</td></tr><tr><td class="has-text-align-center" data-align="center">128 (4 nodes)</td><td class="has-text-align-center" data-align="center">1.0</td></tr><tr><td class="has-text-align-center" data-align="center">256 (8 nodes)</td><td class="has-text-align-center" data-align="center">1.4</td></tr><tr><td class="has-text-align-center" data-align="center">512 (16 nodes)</td><td class="has-text-align-center" data-align="center">3.7</td></tr><tr><td class="has-text-align-center" data-align="center">1024 (32 nodes)</td><td class="has-text-align-center" data-align="center">4.7</td></tr><tr><td class="has-text-align-center" data-align="center">2048 (64 nodes)</td><td class="has-text-align-center" data-align="center">21.5</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>In the left column, we see the number of cores required, as well as how many (compute) nodes we need. In this case, each compute node has 32 cores. On the right, we show the measured time it took to run a given simulation on the given number of cores.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We need to be careful how we obtain these time measurements. We can't just go to our cluster, run a simulation for a number of cores, record the time, and then move on. If we do that, we will get a lot of noise, or variance, in our results. Instead, we should run the same simulation over and over again. With a number of measurements available, we can now either compute the average time or take the shortest time. I have seen both approaches being used in the wild.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When CPUs are not in use, they are typically underclocked to save energy. So, if you throw your simulation onto a compute node that was idling for some time before you showed up with your (simulation) problems, it is likely that the process of bringing the compute node back up to speed will influence your measured compute time. In this case, we may want to give the compute node a task to do for a few seconds before we start measuring simulation times.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we compute the speed-up now based on the time measurements we saw above in the table, then we can plot it against the number of cores. This is shown in the figure below on the left:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"800px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/strong_scaling.png" alt="Result of strong scaling. The left plot shows the number of cores vs. the measured speed up, and that there is an optimum at around 128 cores. Afterwards, the speed-up reduces. On the right, the efficiency is plotted, showing that this is monotonically decreasing." class="wp-image-5550" style="width:800px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>I have shown here two lines; the first (dashed) line shows the best possible speed-up. That is, if we use [katex]p[/katex] processors, then a speed-up of [katex]p[/katex] is the best possible scenario we can expect. While we see that the measured speed-up, shown as a solid blue curve, follows this trend initially, it starts deviating from it relatively soon. At around 128 cores, we see a peak. Afterwards, the speed-up is going down again.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is the expected behaviour. In order to understand that, we need to know more about how code parallelisation works (and we will look at that in more detail). But in a nutshell, imagine we want to compute the gradient of the velocity field in the continuity equation. Thus, we may have a finite difference approximation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\nabla\cdot\mathbf{u}=\frac{\partial u}{\partial x} + \frac{\partial v}{\partial y} + \frac{\partial w}{\partial z} = 0\\[1em]
\nabla\mathbf{u}\approx \frac{u_{i+1, j,k} - u_{i-1,j,k}}{2\Delta x} + \frac{v_{i, j+1,k} - v_{i,j-1,k}}{2\Delta y} + \frac{w_{i, j,k+1} - u_{i,j,k-1}}{2\Delta z} = 0\tag{14}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's look at [katex]u_{i+1, j,k}[/katex] and [katex]u_{i-1, j,k}[/katex]. We said before that in order to achieve faster code execution, we may split a 10-million-cell problem over 4 processors, where each processor is now solving only a 2.5-million-cell problem. This means that our original mesh is now chopped up into smaller chunks. But, if we compute the solution near or at the boundary of one of these subdomains, then we may find that [katex]u_{i+1, j,k}[/katex] is still on our domain, but [katex]u_{i-1, j,k}[/katex] isn't.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It turns out that [katex]u_{i-1, j,k}[/katex] is on the neighbouring subdomain, and so we have to request now a copy of that from our neighbour. So, we send a request, and we wait. Imagine you need a vital piece of information, but you don't have it. But, you know who has it. So, you may send that person an email and wait for their response. Once they get back to you, you can continue to work, but in the meantime, you are waiting for a response before you can continue.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The same is true for our request to get data for [katex]u_{i-1, j,k}[/katex]. Even though the communication is instant, it has to go through the network (or, if the data is close to us, through the CPU), but one way or another, we have to copy memory around. As we saw in the computer hardware section, accessing memory is costly and much slower than the speed of our CPUs.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, a bit of communication is fine, and we can hide it behind the work we are doing on our CPU. But there is a point where communication will become so costly that it dominates our simulation. At that point, we no longer see a speed-up, but rather, a slowdown. This is what we are seeing in the left figure above. Using more than 128 cores will slow down our simulation again.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Since we keep the problem size the same, i.e. let's say we use 10 million cells, as we use more processors, the subdomain that each processor works on becomes smaller and smaller. If we have 1 processor, then it will work on 10 million cells; if we have 2, each will work on 5 million cells; if we have 4, each processor will work on 2.5 million cells, and so on.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, with an increase in the number of cores, we have a decrease in the problem size and thus less computational work to do per core. But, with an increase in the number of processors, we also have an increase in communication (we now have more processors talking to each other). There is a point where there is no more speed-up, as we are not spending enough time on computing but rather on waiting for communications to finish.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another measure that we commonly compute is the efficiency. This is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
E(p, N) = s(p,N) / p
\tag{15}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The efficiency checks the speed-up for a given number of processors. Say we get a speed-up of 8 using 10 processors, then, if we divide that by the number of processors (10), we get an efficiency of 8/10 = 0.8, or 80%. The ideal speed up would be 10 instead of 8, and so the efficiency measures how far we are away from the ideal speed-up. This is computed and shown in the figure above on the right.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we now take what we have learned on Amdahl's law and strong scaling, it may seem that we are doomed. No matter what we try, it appears that there is no way to efficiently use a large number of cores. To a certain extent, this is true. Yes, it is difficult to make a code as efficient as possible in using parallel resources. For this reason, you will find commercial CFD solver developers spending a lot of effort in improving their parallel code performance.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, there are lots of ways in which you can cheat with your strong scaling results and make it look really efficient, when in reality, it is not. Academics seem to be among the worst offenders, either due to incompetence (not understanding the limit of strong scaling results) or just being mischievous.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The first thing we have to set is a baseline problem with strong scaling. Let's say, for the sake of argument, that we get the highest speed-up when we have 100,000 cells per core. If we add more processors, we get fewer cells per core, and so we see a slowdown. If I now set my baseline problem on which I investigate my strong scaling to be 1 million cells, then I will see my strong scaling results indicating that 10 cells is ideal. If I use more than 10 processors, my performance will decrease again.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, if my baseline problem is 10 million cells or even 100 million cells, then the optimal number of processors is 100 or 1000, respectively. The quality of my strong scaling results is only as good as my pain tolerance to wait for that first simulation to finish. Remember, on 1000 cores, running a 100 million cell simulation is fast. But on 1 core, it will be, well, about 1000 times longer. If I can afford to wait days for the simulations on a single core to finish, then I get excellent strong scaling results.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, the strong scaling itself is not very informative; what we also should always report is the problem size, so that we can work out how large the problem is per core at its optimum. Knowing this number is far more important than the strong scaling result itself; however, even this number can be tampered with and made arbitrarily small.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, commercial codes typically can go down to 50,000 cells per core. If you reduce the problem size further, you will lose performance. Open-source CFD solvers can go down to about 100,000. Well, these are some experiential values, and your experience may differ, but as an order of magnitude guestimation, these values are good to remember.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, above we said that the problem with decreasing the number of cells per processor is problematic because we don't have enough computations to do, and so the time we wait for communications becomes the limiting factor. We can exploit that and just make our code perform more computations than are necessary. In this way, we have again enough computations to perform, and so we can reduce the number of cells per processor before it becomes less efficient again.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I have seen a code where each computation per cell was done twice. Not due to malicious purposes, i.e. showing impressive strong scaling results (although the authors of the code also did that), but rather due to laziness. It was easier to perform the computation twice, as this would allow for a simpler data structure in the code. Thus, from the outset, the code was slow to begin with (a code with an optimised data structure would likely be twice as fast).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, when it came to parallelising this code, they would see pretty good strong scaling, and they would get close to commercial solvers in terms of how many cells per core would be an optimum for their solver. By artificially increasing the number of computations you have to do, of course, you get a lower number of cells per core as the optimum, but this behaviour is no different to lying on your tax returns (which, last time I checked, is illegal).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But there is one more thing we need to discuss, and that is something that may be difficult to grasp, or perhaps put down to as a measurement error, when in reality, a perfectly good explanation exist. Take a look at the following plot:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/superscalar_strong_scaling.png" alt="An example of strong scaling where some measurements show performance that goes beyond the ideal performance, i.e. we get efficiencies that are greater than 1 (or 100%)." class="wp-image-5550" style="width:600px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://hemelb-dev.github.io/HemeLB-Carpentries/03-benchmarking-and-scaling/index.html" target="_blank" rel="noopener" title="">HemeLB</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>First of all, these strong-scaling results are shown as a log-log plot, while we used a semi-log plot thus far, so it will look slightly different (it is more common to use the semi-log plot that we have used before). But have a closer look at the measurements, what is going on with the second and third measurements? This is not a measurement error, and it is not the result of averaging measurements or manipulating them in some other way. The speed-up we are seeing is real.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But how can we get a speedup that is larger than the theoretical best performance? In other words, if we have, say, a speed up of 2.2 for 2 cores, then our efficiency, according to Eq.(15), is [katex]E=2.2/2 = 1.1 = 110%[/katex]. We have an efficiency that is greater than 1, or 100%, something seems to be off here. But let's look at our computer hardware a bit closer:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"500px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/CPU_architecture.png" alt="A schematic overview of a computer with the CPU, RAM, hard drive and network component." class="wp-image-5550" style="width:500px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>As we have discussed, a CPU consists of several cores, or processors, but they also have a number of caches, typically three levels. The L1 and L2 (level 1 and level 2) caches are sitting next to each core and are local to that core, but the L3 (level 3) cache is shared among all cores on the CPU. When data is required from main memory (RAM), the CPU will request the relevant data to be copied into the L3 cache. Each core will then take from that L3 cache what it needs and put that into its L2 and L1 cache.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The reason we do that is speed. The CPU is so fast that if we were to always read memory directly from main memory (RAM), it would take so long that most of the time the CPU would be waiting for memory. The solution is caches. It is the same reason we do grocery shopping. When we want to cook, we don't go to the supermarket and buy the stuff we need, but rather get a bunch of ingredients upfront and then, when we want to use them, we go to the fridge and food cupboard and get what we need.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this analogy, the supermarket is RAM, and our fridge/food cupboard is our cache. When we need memory, the CPU requests data and places it in the L3 cache so each core can use it, which is equivalent to us going to the supermarket and getting a bunch of things which we can store at home so they are there when we need them. While the supermarket has so much capacity that it has pretty much anything we could ever need, our fridge and food cupboard have limited space.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The trade-off, thus, is the capacity for access speed. I can get anything I want in the supermarket, but it will take time to get it. But if I can get what I need from my fridge or food cupboard, it is there, and access time is basically zero. The same is true for RAM and caches. Accessing memory from RAM is slow, but accessing memory from our caches is fast. In the case of L1 caches, it can be as little as a single clock cycle (which means our CPU has the data available when it needs it and doesn't have to wait for it).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The following figure shows access times vs. capacity for different memory modules, which helps to illustrate this point. Note that these numbers are approximate, so the order of magnitude is more important than the absolute value.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"700px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/memory_access_times.png" alt="Comparison of memory access times for registers, caches, RAM, and hard drives and their respective storage." class="wp-image-5550" style="width:700px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>The CPU will only work with registers, which are sitting next to each core. Their data is coming from the L1 cache, and so on. We can see that the smaller the memory modules are in capacity, the faster they can load memory. The reason is that memory needs to be indexed, which can take time. If you park your car in a parking area that takes 20 or 2000 cars, in which of these parking areas will you, on average, find your car quicker? The smaller the parking area, the faster the access time, and the same is true for memory.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, how does all of this relate back to our strong scaling results? Well, let's use the figure above and see what happens if our baseline simulation consumes 2 MB of storage. Arguably, this is a very small problem, but let's go with this example. We run this example on 1 core and, because this problem is so small, it does fit entirely into our L3 cache. No need to go to main memory.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We now perform our strong scaling measuring campaign and realise that for 2 and 4 cores, we get an efficiency of more than 1, or 100%. The reason here is that we split our original 2 MB problem now amongst 2 and 4 processors. Thus, each processor will get a problem size that is now either 1 MB or 0.5 MB, respectively. Looking at our memory hierarchy above, we can see that this is now just about small enough so that the entire problem fits into the L2 cache.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Since the L2 cache has faster access times than the L3 cache, we do see a speed-up that goes beyond the predicted theoretical best. What we have to realise here is that the theoretical best performance was predicted based on the single-core simulation, which took place in the L3 cache. But once we break down our problem, eventually it will fit into smaller caches, where the theoretical best speed-up is different.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, since we compare our results against the theoretical best based on the single core simulation, we can get efficiencies that are above 1, or 100%, i.e. we see speed-ups that go beyond what is <em>theoretically</em> possible. This behaviour is called <strong>superlinear scaling</strong>, or <strong>superscalability</strong>, and is just a consequence of our memory hierarchy.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-weak-scaling">Weak scaling</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In strong scaling, we took a fixed problem size (e.g. the number of cells in the mesh) and measured the speed-up for an increasing number of processors. This meant that the problem size per processor was getting smaller and smaller as we increased the number of processors. In weak scaling, on the other hand, we keep the problem size per processor the same.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, if we simulate a problem of 1 million cells on a single core, then, in weak scaling, we would have to use a problem size of 2 or 4 million if we measured their weak scaling for 2 or 4 processors, respectively. The question then becomes, why would we do that? If we keep the problem size the same per core, we would expect to see the same computational times, or not?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's think about what happens when we increase the number of processors. Initially, we only use a single core. Even if we increase the number of cores to a handful, we are likely still on the same compute node. As we increase our number of cores, we start to use more than a single compute node. If we increase the number of cores even further, we will start to use compute nodes that are further apart in space.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>At first, these compute nodes are within the same cabinet, but then, as we use more and more cabinets, our communication has to go through the network, which is now separated in space. The further apart these compute nodes are, the longer it takes to send data over the network.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Consider this: HPC clusters use optical (glass) fibres in their network. This allows them to send data at almost the speed of light, i.e. [katex]c=300,000,000\, m/s[/katex] (approximately, let's not split hairs). The speed at which data is sent depends on the refractive index, which is a ratio of how fast light travels in a medium compared to a vacuum. In glass, this value is about [katex]n=1.5[/katex] for visible light, meaning that a signal in optical glass fibres may travel at:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
v=\frac{c}{n} = \frac{300,000,000}{1.5} = 200,000,000\,m/s\tag{16}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This means that it takes the network about [katex]1/200,000,000=5\,ns[/katex] (nanoseconds) to send data for 1 metre through the network. Our CPU, in the meantime, is able to perform calculations according to its clock cycle, which is about 2-3 GHz on HPC clusters. This means it takes the CPU about [katex]1/3,000,000,000=0.3\,ns[/katex] to perform one operation. If two nodes are separated now by one metre, the CPU can perform [katex]5/0.3\approx 16[/katex] operations while data is being sent over the network.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This does not include the time it takes to read data from RAM and put it onto the network, and write it back into RAM at its destination. What this calculation shows is that as our compute nodes are getting separated physically in space, the time it takes to send data becomes a bottleneck. Who would have thought that the speed of light is not fast enough for CFD applications!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Returning to our weak scaling problem, as we increase the number of cores, we don't just increase the number of communications that need to happen, similar to strong scaling, but we also test how the additional distance in space affects the communication speed.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In general, when we try to benchmark our CFD applications, we perform a strong scaling analysis, and usually, we are happy with that. Weak scaling is not often done. You only really need weak scaling if you are targeting really large simulations (1000 cores or more, let's say), but most of the time, this analysis will not give you any actionable insights to improve your parallel efficiency.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Weak scaling is usually much more important for those who maintain the HPC facilities and try to identify bottlenecks, or just to benchmark their system. If we performed two separate weak scaling tests on two different systems, we likely would get different results. In a sense, the weak scaling results are mostly influenced by the HPC system itself rather than our code.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, if we wanted to improve our code, especially our parallel efficiency, we would perform a strong scaling analysis and try to improve our communications here. Any improvements made in strong scaling would also show in weak scaling, though the bottleneck in weak scaling would still be the system that we use.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's look at another example, say we have to look at a simulation where we have kept the problem size the same. For the sake of argument, imagine we run a problem where the meh size is exactly 1 million cells per core, and we measure the computational time it takes as we add more and more cores, keeping the number of cells per core the same. Example measurements can be found in the table below:</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table class="has-fixed-layout"><thead><tr><th class="has-text-align-center" data-align="center">Number of cores (required nodes)</th><th class="has-text-align-center" data-align="center">Measured time (in seconds)</th></tr></thead><tbody><tr><td class="has-text-align-center" data-align="center">1 (1 node)</td><td class="has-text-align-center" data-align="center">0.58</td></tr><tr><td class="has-text-align-center" data-align="center">2 (1 node)</td><td class="has-text-align-center" data-align="center">0.63</td></tr><tr><td class="has-text-align-center" data-align="center">4 (1 node)</td><td class="has-text-align-center" data-align="center">0.72</td></tr><tr><td class="has-text-align-center" data-align="center">8 (1 node)</td><td class="has-text-align-center" data-align="center">0.79</td></tr><tr><td class="has-text-align-center" data-align="center">16 (1 node)</td><td class="has-text-align-center" data-align="center">0.89</td></tr><tr><td class="has-text-align-center" data-align="center">32 (1 node)</td><td class="has-text-align-center" data-align="center">0.97</td></tr><tr><td class="has-text-align-center" data-align="center">64 (2 nodes)</td><td class="has-text-align-center" data-align="center">1.03</td></tr><tr><td class="has-text-align-center" data-align="center">128 (4 nodes)</td><td class="has-text-align-center" data-align="center">1.26</td></tr><tr><td class="has-text-align-center" data-align="center">256 (8 nodes)</td><td class="has-text-align-center" data-align="center">2.41</td></tr><tr><td class="has-text-align-center" data-align="center">512 (16 nodes)</td><td class="has-text-align-center" data-align="center">4.59</td></tr><tr><td class="has-text-align-center" data-align="center">1024 (32 nodes)</td><td class="has-text-align-center" data-align="center">10.69</td></tr><tr><td class="has-text-align-center" data-align="center">2048 (64 nodes)</td><td class="has-text-align-center" data-align="center">22.01</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>We can now compute the efficiency again, this time expressed as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
E(p, N)=\frac{T(1,N)}{T(p,N)}\tag{17}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Thus, we take the time it took to run this simulation on one core (i.e. [katex]0.58s[/katex]) and compare that to subsequent simulations. In an ideal world, as the number of cores increases and the problem size per core remains the same, we would expect the computational time to be the same. While the computations don't change, the time we have to wait for data will increase, and so we will see a departure from a 100% efficiency. This is shown in the following figure:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"500px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/weak_scaling.png" alt="Result of weak scaling. The results are monotonically decreasing as we increase the problem size." class="wp-image-5550" style="width:500px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>This is all there is to weak scaling, really. But one question is still open. After we have done our strong and weak scaling, how can we determine the number of cores to use that is optimal for our simulation? This is the question we seek an answer to in the next section.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-the-optimal-number-of-cores-for-your-simulation">The optimal number of cores for your simulation</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Indeed, if we just did the strong and weak scaling to plot some fancy plots, we would have wasted quite a lot of computational resources for one figure. If this figure then never gets used, for example, in a publication, then what was the point of this exercise? Typically, we want to perform the strong scaling so we can compute an optimal problem size per core, that is, for how many cells per core do I still get a good speed up with a good parallel efficiency.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As we have seen both in the strong and weak scaling sections, it is impossible to get something with a parallel efficiency of 100%, unless we use a single core (at which point, we don't have parallelism, so this is a <a href="https://en.wikipedia.org/wiki/Pointless" target="_blank" rel="noopener" title="">pointless answer</a>). So, first we have to settle on a level of parallel efficiency we are happy with, and then we can try to identify a suitable problem size per core.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>A good rule of thumb is that 75% - 80% is an acceptable parallel efficiency, so when you perform your strong scaling, you look at which point you reach a value of [katex]0.75 \ge E(p, N) \ge 0.8[/katex] and then find the number of cores and the problem size. Say you achieved this value with 8 cores and your problem size was 1 million cells. Then, you can compute the optimal problem size as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
N_{opt} = \frac{N}{p|_{0.75 \ge E(p,N) \ge 0.8}} = \frac{1,000,000\,cells}{8\,cores} = 125,000\frac{cells}{cores}
\tag{18}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Once you have performed this analysis, you have generalised your strong scaling results and extracted some actionable insights. If I come along and I want to use your code, and my simulation uses 15 million cells, then you can tell me that the optimal number of cores is [katex]15,000,000/125,000=120[/katex]. Except, it isn't! The correct answer is either 64 or 128.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To understand that, let's consider the HPC hardware. We have our different cabinets and compute nodes, and we need to connect them all together. What is the optimum way to connect them? Well, HPC interconnection is a topic in itself, but let's just say that all of the common topologies we use, like the <a href="https://en.wikipedia.org/wiki/Hypercube_internetwork_topology" target="_blank" rel="noopener" title="">hypercube</a> or <a href="https://en.wikipedia.org/wiki/Torus_interconnect" target="_blank" rel="noopener" title="">Torus</a>, require [katex]2^m[/katex] connections (where [katex]m[/katex] is an integer). For example, if you follow the link to the hypercube, it will say:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><em>"Hypercube interconnection network is formed by connecting N nodes that can be expressed as a power of 2. This means if the network has N nodes it can be expressed as:"</em></p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
N=2^m\tag{19}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Similar observations can be made for the Torus interconnect. Thus, if we have [katex]2^m[/katex] network links connecting different compute nodes together, then it would make sense to have [katex]2^n[/katex] cores to efficiently use this network (where [katex]n[/katex] is an integer). If we use a number of cores that can not be expressed as [katex]2^n[/katex], then we don't utilise the network efficiently.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On the parallelisation side of things, there will be algorithms that expect us as well to use [katex]2^n[/katex] cores. Some algorithms are implemented in a way that expects either 2, 4, 8, 16, 32, ... cores, so that it can always divide a problem into 2 and then distribute that amongst cores. If I have one computation and want to split it into 2, I get 2 sub-problems to solve. If I divide this again by 2, I get 4 sub-problems. Divide that again by 2, I get 8, and so on.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If I come now with 12 cores, then I cannot efficiently distribute that problem. Our parallelisation framework will be able to handle 12 cores, but it has to do some additional work, which slows us down. If we just come with 16 cores instead, we can nicely subdivide our problem into 16 sub-problems, which allows for fast execution.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Coming back to our example of me wanting to use your code with 15 million cells, the answer is not 120 cores, but rather 64 or 128, both of which can be computed with [katex]2^n[/katex]. In this case, I would probably select 128, as this is really close to 120 and [katex]15,000,000/128\approx 117,000[/katex], so it is not miles away from the theoretical optimum (which will likely also contain some variance).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, when we want to determine the optimal number of processors, this is the generalised approach:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Perform strong scaling analysis of a problem size that is sufficiently large.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Compute the parallel efficiency and identify the number of cores required to retain a 75% - 80% efficiency.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Compute the optimal number of cores as we have done in Eq.(18). This will be your lower bound [katex]C_{lower}[/katex].

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Multiply the optimal number of cores by 2. This will be your upper bound [katex]C_{upper}[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Determine the value of [katex]n[/katex] for which the following inequality is satisfied: [katex]C_{lower} \le C_{given} / 2^n \le C_{upper}[/katex]. Here, [katex]C_{given}[/katex] is the number of cells of the problem we are trying to solve.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Calculate the number of cores as [katex]N_{cores} = 2^n[/katex].

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>You can do that, write your own calculator for that, or, <em>shameless plug</em>, use my <a href="https://chromewebstore.google.com/detail/cfd-toolbox/bcalbgngjglcapigdjlknojeoncdeomp" target="_blank" rel="noopener" title="">browser extension</a>, which has a parallel computation calculator that will do all of that for you. If you don't want to use the calculator, or even write your own, here are some good default values:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Assume that commercial CFD solvers will retain a parallel efficiency of about 75% - 80% for 50,000 - 100,000 cells per core.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Assume that in-house (academic) codes or open-source CFD solvers, unless touched and optimised by some HPC wizard, retain a parallel efficiency of 75% - 80% for 100,000 - 200,000 cells per core.

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>If I leave this discussion here, someone will inevitably point out a flaw that I have used throughout my discussion up to this point. I have always been referring to our problem size as the number of cells in our simulation. However, the number of cells is not necessarily a good indicator of the amount of work we do. For example, the work done on a 4-million tetrahedral-dominant mesh and a 1-million polyhedral-dominant mesh may be the same.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In reality, the number of faces, not the number of cells, determines our computational cost (assuming we are using a finite volume method). So, if you just want to be that extra bit pedantic, <em>or you are German</em>, then use the number of faces, not the number of cells. I was thinking how I could show you why Germans are the way they are, I don't think I can, but here is a good summary of <em>German values</em> ...</p>
<!-- /wp:paragraph -->

<!-- wp:embed -->
<iframe src="https://www.youtube.com/embed/gF2kl7K-sP0?si=AsVz1Onjm5YmoTzp" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen style="width:100%; aspect-ratio:16/9; border:0;"></iframe>
<!-- /wp:embed -->

<!-- wp:paragraph -->
<p>The music is <em>meh</em>, but the lyrics are, well, I shall not spoil them. If you are interested, <a href="https://lyricstranslate.com/en/deutschland-germany.html-0" target="_blank" rel="noopener" title="">here is a somewhat decent translation</a>. It really brings out that German arrogance that people in the world have come to love about us (I think ...).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The reason we use the number of cells to determine the computational cost is due to historical reasons. When we started to do CFD in earnest around the 1950s, with pioneering work of Lax, Friedrichs, Harlow, Welch, all was done in 1D and 2D on structured grids. Since structured grids only allow for a single cell type, it doesn't matter if we take the number of cells or the number of faces. The work will scale well with either metric.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Only once the finite volume method was introduced in 1971 by McDonald and, independently, in 1972 by MacCormack and Paullay, did we start to adopt new elements that could be treated by the finite volume method, including polygons (2D) and polyhedra (3D). Since polygons and polyhedra elements can have an arbitrary number of faces, using the number of cells is no longer a good indication for the computational work, as the finite volume method is face-based, that is, integrals/fluxes are evaluated at the faces.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Therefore, we ought to use the number of faces, and not the number of cells, when we talk about computational cost, but I suppose this is yet one more example of how CFD is full of <em>wonderful inconsistencies</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>People in the finite element community, however, have realised that the logic we are using is flawed, and so when they talk about problem sizes, they use the term <em>degrees of freedom</em>, which also accounts for the fact that you may have a different number of integration points per cell.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In any case, I have admitted the logical inconsistency, so you don't have to tell me that I am wrong.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-the-roofline-memory-model">The roofline memory model</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>When we did our strong scaling analysis, we wanted to identify when our performance is dropping. We used the efficiency to guide us in this case, and we ended up with the smallest problem size per core that still gives us an acceptable parallel efficiency.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's say after we have obtained this number, we realise that our code is just very slow, but we don't know where this is coming from. So, we want to benchmark our code to identify the bottleneck, so that we know which part of the code we have to improve. This is where the roofline model comes in. Arguably, it is a simple model, and much more sophisticated models are available, but it helps us to identify which bottleneck we have, and we have two possible solutions. Either we are:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Memory-bound

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Compute-bound

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>If we are compute-bound, it means that we are already utilising our CPU to its maximum capacity. We cannot squeeze more out of our CPU by giving it more work to do; if we wanted to get more performance, we would need to get a CPU with a faster clock cycle (i.e. get a CPU with more GHz).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we are memory-bound, however, then our CPU is not getting enough data to operate on. Either the CPU is not doing enough with that data before it requests new data, or our memory supply is not optimised. Typically, we have enough data for the CPU to work on, so if we are memory-bound, it usually indicates that we are very inefficient with our memory access.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's create an example to understand how memory access can cause a bottleneck and result in our application being memory-bound. Let's say we want to perform a simple vector matrix multiplication. This is something we routinely do in our applications, and so you may have a few of these in your code as well. Let's look at a very simple example:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#include \u0026lt;vector\u003e\n\nusing MatrixType = std::vector\u0026lt;std::vector\u0026lt;double\u003e\u003e;\nusing VectorType = std::vector\u0026lt;double\u003e;\n\nint main() {\n    int N = 1024;\n\n    MatrixType A(N, std::vector\u0026lt;double\u003e(N));\n    VectorType x(N);\n    VectorType b(N);\n    \n    // fill data for A, x, b. Not done here, a real application would do that.\n    // ...\n\n    // b = A * x\n    for (int j = 0; j \u0026lt; N; ++j) {\n        for (int i = 0; i \u0026lt; N; ++i) {\n            b[i] += A[i][j] * x[j]; \n        }\n    }\n\n    return 0;\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eMatrixType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eusing\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003eVectorType\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emain\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e N = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1024\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    MatrixType \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eA\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(N, \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(N));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    VectorType \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(N);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    VectorType \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eb\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(N);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // fill data for A, x, b. Not done here, a real application would do that.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // ...\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // b = A * x\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e j = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; j \u0026lt; N; ++j) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; N; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eb\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; += \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eA\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93;\u0026#91;j\u0026#93; * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;j\u0026#93;; \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":24,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>#include &lt;vector>

using MatrixType = std::vector&lt;std::vector&lt;double>>;
using VectorType = std::vector&lt;double>;

int main() {
 int N = 1024;

 MatrixType A(N, std::vector&lt;double>(N));
 VectorType x(N);
 VectorType b(N);
    
 // fill data for A, x, b. Not done here, a real application would do that.
 // ...

 // b = A * x
 for (int j = 0; j &lt; N; ++j) {
 for (int i = 0; i &lt; N; ++i) {
 b&#91;i&#93; += A&#91;i&#93;&#91;j&#93; * x&#91;j&#93;; 
 }
 }

 return 0;
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;vector&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">MatrixType</span><span style="color: #D4D4D4"> = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;&gt;;</span></span>
<span class="line"><span style="color: #C586C0">using</span><span style="color: #D4D4D4"> </span><span style="color: #4EC9B0">VectorType</span><span style="color: #D4D4D4"> = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">main</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> N = </span><span style="color: #B5CEA8">1024</span><span style="color: #D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    MatrixType </span><span style="color: #DCDCAA">A</span><span style="color: #D4D4D4">(N, </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;(N));</span></span>
<span class="line"><span style="color: #D4D4D4">    VectorType </span><span style="color: #DCDCAA">x</span><span style="color: #D4D4D4">(N);</span></span>
<span class="line"><span style="color: #D4D4D4">    VectorType </span><span style="color: #DCDCAA">b</span><span style="color: #D4D4D4">(N);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // fill data for A, x, b. Not done here, a real application would do that.</span></span>
<span class="line"><span style="color: #6A9955">    // ...</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // b = A * x</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> j = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; j &lt; N; ++j) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; N; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #9CDCFE">b</span><span style="color: #D4D4D4">&#91;i&#93; += </span><span style="color: #9CDCFE">A</span><span style="color: #D4D4D4">&#91;i&#93;&#91;j&#93; * </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;j&#93;; </span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>I have defined two types on lines 3-4 to allow me to create a matrix (consisting of two <code>std::vector</code>s arranged as a 2D matrix) and a vector (consisting of a single <code>std::vector</code>). I use these types to create the matrix <code>A</code> and the two vectors <code>x</code> and <code>b</code> on lines 9-11, using the number of elements per row/column as defined by <code>N</code> (which would be, for example, the number of cells in our mesh).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On lines 17-21, I perform the vector matrix product, i.e. [katex]b = Ax[/katex]. If your programming background is from Fortran, then this will look familiar to you. We have two loops, and we first loop over <code>j</code> (columns), and then over <code>i</code> (rows). The order in which we would access our matrix is shown in the following:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\begin{bmatrix}
1 & 4 & 7 \\[1em]
2 & 5 & 8 \\[1em]
3 & 6 & 9
\end{bmatrix}\tag{20}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Because we are accessing each column one after the other, we call this the column major ordering. But, we could have also reversed the loops and have:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"for (int i = 0; i \u0026lt; N; ++i) {\n    for (int j = 0; j \u0026lt; N; ++j) {\n        b[i] += A[i][j] * x[j]; \n    }\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; N; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e j = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; j \u0026lt; N; ++j) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eb\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; += \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eA\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93;\u0026#91;j\u0026#93; * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;j\u0026#93;; \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":5,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>for (int i = 0; i &lt; N; ++i) {
 for (int j = 0; j &lt; N; ++j) {
 b&#91;i&#93; += A&#91;i&#93;&#91;j&#93; * x&#91;j&#93;; 
 }
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; N; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> j = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; j &lt; N; ++j) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">b</span><span style="color: #D4D4D4">&#91;i&#93; += </span><span style="color: #9CDCFE">A</span><span style="color: #D4D4D4">&#91;i&#93;&#91;j&#93; * </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;j&#93;; </span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>In this case, the matrix would be accessed in the following order:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\begin{bmatrix}
1 & 2 & 3 \\[1em]
4 & 5 & 6 \\[1em]
7 & 8 & 9
\end{bmatrix}\tag{21}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Because we are going through the matrix row by row, we call this the row-major ordering. The question is, which of these is better suited to compute the vector matrix product? It all depends on how C++ stores variables, and it does that in row-major order. To confirm this, we could benchmark both vector matrix multiplications and see which is faster. I have done just that and used <a href="https://github.com/google/benchmark" target="_blank" rel="noopener" title="">Google Benchmark</a> to time both versions. There is a handy website that helps us do that called <a href="https://quick-bench.com/q/tmjK4fWtoAHPTAwiUFz-P2TWF2I" target="_blank" rel="noopener" title="">QuickBench</a>, which I have used.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The result from this comparison is shown below:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"800px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/matrix_multiplication_benchmark.png" alt="Comparison of the row major and column major access of our vector matrix multiplication. Row major shows half the compute time compared to column major access." class="wp-image-5550" style="width:800px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>What QuickBench is doing is to compute the time it takes to perform a no-operation (noop, great name!) function call (i.e. calling a function that doesn't do anything), and then comparing that time against the time it takes to compute our row major and column major matrix vector multiplication, so the y-axis is a non-dimensional unit of time.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, the smaller the bar, the shorter the execution time. We can see that the row-major matrix vector multiplication on the left (blue bar) takes about 1.8 times less time to compute than the column-major matrix vector multiplication. What we learn from this is that we should always use <code>i,j,k</code> loop variables, not <code>k,j,i</code> when looping over multidimensional arrays. But why?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Remember when we talked about the memory hierarchy, I said that whenever the CPU needs new data in its registers to perform a computation, it will request that data from the L1 cache. If it is available, then it can load that data quickly and continue its computations; otherwise, it will have to wait for the L1 cache to request the data from the L2 cache. If it is there, the L1 cache will get this data quickly; if it is not, the L2 cache needs to request it from the L3 cache, and the L3 cache may have to go to RAM to get the data.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Whenever the CPU request the next element in an array (be it a 1D vector or a multidimensional array), we don't just load a single element into our caches, but rather, we fill our caches with as much memory as possible so that when we request the next element, it will already be available. Whenever we request data, and it is already available in our cache, then we have a <em>cache hit</em>. If it is not available, we have a <em>cache miss</em>. Whenever we have a <em>cache miss</em>, we need to go back to the next cache or RAM to get additional data.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Getting the data will take time, and so we want to minimise <em>cache misses</em> as much as possible. The way to do that is to align our memory access with the way C++ stores its data. Let's take a simple example and say that we have the following matrix:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\begin{bmatrix}
1 & -1 & 2 \\[1em]
7 & 4 & -4 \\[1em]
5 & -3 & -2
\end{bmatrix}\tag{22}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's say that our CPU can hold 3 <code>double</code>s in their register. With a row major memory access, we would first load [katex]1,\, -1,\, 2[/katex] into our register. If we now also had the vector [katex]x[/katex] loaded into another register, then we could compute the first entry into our [katex]b[/katex] vector as [katex]1x_0 -1x_1 + 2x_2[/katex]. Since both the first row of our matrix and the vector [katex]x[/katex] are in our registers, we were able to perform this operation without going back to our caches to request additional data.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To complete the first row in our vector matrix multiplication, we have to, yet again, request a new line column from our matrix, now [katex]2,\, -4,\, -2[/katex], and we can calculate [katex]2x_2[/katex]. We can add that to the previous accumulated sum. Thus, to compute the first row, we had 3 memory loading instructions for our matrix using column-major memory access compared to 1 memory loading instruction for our row-major memory access.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you continue this for the second and third row, you will end up with 3 memory load instructions for row-major memory access and 9 memory load instructions for column-major memory access. Memory is expensive, even with a clever cache hierarchy, and for that reason, we see that column-major memory access is 1.8 times slower than row-major memory access in our benchmark performed above.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, the question then is, how do we know if our application is already saturated and using all the available power from our CPU (i.e. we have a compute-bound problem), or if we are having bad memory access and need to think about how to optimise this? This is where the roofline model comes in.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The roofline model defines two properties: the theoretical max performance of our CPU, measured in GFLOPs (giga floating point operations per second), that is, how many billion arithmetic operations can be performed on floating point numbers per second, and the operational intensity, measured in FLOPs/byte.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We need to define two units here. First, we have to consider the work performed. This is given the letter [katex]W[/katex], and this would be related to the work the CPU is doing, typically, how many floating point numbers it can work on per second. For this reason, we typically use GFLOPs when plotting the roofline model.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The second unit we need to look at is the memory traffic [katex]Q[/katex], and it measures how much data was requested by the CPU to perform its work [katex]W[/katex]. With both of these numbers defined, we can compute the arithmetic intensity [katex]I[/katex] as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
I=\frac{W}{Q}\tag{23}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This gives us a ratio, which essentially tells us how much data we need to perform a given number of operations. For example, let's look at the following two operations:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
a = a^2 + a \\[1em]
b = c * d\tag{24}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>In the first example, we need to load 1 floating point value $a$ to perform two floating point operations, and then we need to store one floating point number. Let's say that $a$ is a ```float```, which typically takes 4 bytes of storage. Then, we can say that we have 1 load and 1 store operation, which takes 8 bytes in total. We have 2 floating point operations, i.e. $a^2$ and then the addition of $a$ with that result. Then, our arithmetic intensity would be:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
I=\frac{W}{Q}=\frac{2}{8} = 0.25\,\, FLOPS/Byte \tag{25}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Let's look at the second example. We have two load instructions of $c$ and $d$, and one store instruction for $b$. We have one floating point operation, i.e. $c \cdot d$, so we have an arithmetic intensity of:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
I=\frac{W}{Q}=\frac{1}{12} = 0.08\dot{3}\,\, FLOPS/Byte \tag{26}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we need to look at the peak bandwidth of our system. The peak bandwidth is the maximum memory transfer rate between the CPU and memory. It is usually measured in GB/s. The easiest way to figure that out is to use a benchmark tool that will run some calculations, where the amount of memory to be transferred is known, so measuring the time it takes to transfer that data can be used to compute the bandwidth. A common benchmark is the [STREAM benchmark](https://github.com/jeffhammond/STREAM), and on my PC, I am getting values between 35 - 50 GB/s, depending on the operation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Knowing this value, we can now compute the performance as the product of the peak bandwidth, let's call that $\beta$, and the arithmetic intensity $I$. In our examples above, we would get the following performance:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
P = \beta\cdot I = 50\frac{GB}{s}\cdot 0.25\frac{FLOPS}{Byte} = 12.5\frac{GFLOPS}{s}\\[1em]
P = \beta\cdot I = 50\frac{GB}{s}\cdot 0.08\dot{3}\frac{FLOPS}{Byte} = 4.1\dot{6}\frac{GFLOPS}{s}\tag{27}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Later, after becoming a lecturer and seeing what effort goes into ensuring the highest ranking in the QS tables (with their own working groups within universities), I realised that the ranking correlates to academic excellence just as much as the import of fresh lemon correlates to road accident fatality rates. We can even plot this:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"500px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/p-hacking-example.png" alt="Example of p-hacking, correlating the amount of imported lemons to road accidents in the US." class="wp-image-5550" style="width:500px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://kaiserscience.wordpress.com/physics/the-scientific-method/data-dredging-and-p-hacking/" target="_blank" rel="noopener" title="">Kaiser Science</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Sure, there is a correlation, but if you think about this correlation for a second, you realise that this correlation is accidental. Of course it is. This is an example of <a href="https://en.wikipedia.org/wiki/Data_dredging" target="_blank" rel="noopener" title="">p-hacking</a>, an art of scientifically proving that there is a <em>mathematical</em> correlation which does not exist in <em>reality</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I have found that some universities will be at the top on merit; they are just excellent. Others are at the top because they know how to p-hack their way to the top. What I find disturbing in these rankings is that <em>output</em> and <em>impact</em> are the driving metrics. One could argue that academic conduct should be part of it as well, i.e., excellence in supervision, training new talent (students, researchers, etc.).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we were to include this, arguably, difficult-to-measure quantity in the ranking as well, we would see a very different ranking. Top universities are not known for getting their by treating their students and researchers with respect; I should know, I had to sign a contract whose terms, from an ethical research point of view, were questionable, to say the least. Well, this is my experience, yours may differ ...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Be that as it may, I was actually quite optimistic when I started at Imperial College. The year was 2013, and I met my two supervisors who would guide me through my research on Direct Numerical Simulations. Both of them were Greek, and I was German. Oh boy, did they have a field trip with me.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While the Greek debt crisis never really concerned me, all of a sudden, I felt the nation of Greece was looking for payback, and I was the recipient, on behalf of the German government. Here are just a few of the things they told my peers and me (I was part of a larger research group):</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>"You are viewed as the golden boys (whatever that meant, we were a mix of male and female researchers), you can't just take holidays whenever you want"

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>"For the amount of money we pay you, you are not allowed to make these mistakes"

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>In other words, if you take holidays and you continue to make mistakes, then you can't produce papers every other month. Research papers in good journals means research reputation and thus a higher ranking in the QS tables. This is a great system, which <em>certainly</em> isn't broken.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But let's look at these statements they made again. The first statement was told to one of my friends, who asked for some time off to go back to his home country to attend his grandfather's funeral, who had passed away just a few days prior. In the end, they settled on "I can't deny your request, but I am encouraging you not to go".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Great human skills on display, imagine the <em>scientific tragedy</em> by having to delay your paper submission by one week. I'm sure researchers around the world couldn't wait for more papers from us and spamming their F5 key, in the hope of being the first to read our <em>prestigious</em> research. I'm sure my supervisors actually believed this to be the case.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Or what about the second statement, you know, the one about not being allowed to make any mistakes. That was a meeting I had with both of my Greek supervisors, after I showed them the results of my code. There were some inconsistencies, but now I know how they came about. Back then, I did not, and so my supervisor asked me about my implementation and slayed me for how I implemented the Runge-Kutta time integration.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It wasn't a comfortable meeting, to put it mildly, but for exactly that reason, it is a meeting that is still very vivid in my mind. I still remember exactly the issue my supervisor had with my implementation, and of course, if your supervisor tells you you messed up, you shut up, go back, and fix it. At least that was what I thought based on the impressions they gave me.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The problem was, my implementation was correct, and my supervisor did not understand himself how to implement the Runge-Kutta method correctly, it seemed. I even pointed out his flaws in our meeting but he was not in a mood to be corrected. He played the "I am the supervisor, and not just any supervisor, I work at Imperial College (here we go again), you are just the stupid researcher. If I say it is correct, it is correct" card.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>After reading about it a few more times, looking at other people's codes, and consulting with authorities who I knew would be able to tell me if I was right or wrong, I realised that I was, indeed, right all along, and my supervisor was wrong. So much for <em>academic excellence</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The other problem was that I had to use his research code, written in good old Fortran 66. When the others and I in our research group started to use his code, we were told that half of the input parameters would not have any effect on the solution (i.e. they are there, but they are not yet implemented). The solver only understood a particular mesh file format, but there was no mesh generator available to generate meshes for the solver (and so we had to buy a license for ICEM-CFD to be able to use the solver).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On my PC, the solver would always crash after about 784 timesteps. My supervisor's response, "I don't know why this is happening, but it should work", which very quickly became his catchphrase. We ran his solver through valgrind and saw that a memory leak was present, but despite the evidence, he refused to accept that his solver was not working (2 weeks later, we received an email from him with a zip file attached that fixed the memory leak that didn't exist).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The solver had two numerical schemes implemented, the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/#aioseo-first-order-upwind-scheme" target="_blank" rel="noopener" title="">first-order upwind scheme</a>, and the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/space-and-time-integration-schemes-for-cfd-applications/#aioseo-central-scheme" target="_blank" rel="noopener" title="">second-order central scheme</a>. The first-order upwind scheme is stable, while the central scheme is <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/explicit-vs-implicit-time-integration-and-the-cfl-condition/#aioseo-second-order-central-explicit" target="_blank" rel="noopener" title="">uncondiotionally unstable</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In one of my first meetings, I was asked to produce some results to show that I can use the solver, and so I used the first-order upwind scheme. That triggered my supervisor, who lectured me on how first-order schemes are not good for scale-resolving turbulence simulations. Well, obviously, but the alternative was an unconditionally unstable scheme.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Again, putting his full ignorance on display, he told me to go back and run the same case with the central scheme. I did, and, as expected, the simulation blew up, and my contours were a collection of random noise. I showed it to my supervisor and thought this would put things to rest, but honestly, this is what he said: "Brilliant, you have successfully captured turbulence".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Looking at the contour plot (and I really should have kept that image ...), it was very clear that I did not generate turbulence but rather numerical instabilities. Sure, they look similar to turbulence, but I mean, there were so many tell-tale signs that it wasn't turbulence.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For starters, I was putting velocity in with, say, 1 m/s, but then I would get turbulent eddies that had 5 times the velocity, all close to the inlet, without any obstacles in their way. Sure, it looked turbulent, but also not physical. I mean, the fact that this was a 2D simulation within a channel, the Reynolds number was about 100, and the grid wasn't able to resolve any turbulent scales should have been a pretty big hint, but again, I was told I was wrong and needed to fix it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>My solution was to implement a higher-order scheme, so we would avoid the first-order upwind issue while gaining accuracy, but that was seen as wasted time. My time was better spent obtaining results my supervisor would sign off on (which I knew were wrong) and publishing these in reputable journals, essentially attaching my name to these physically incorrect results. I knew that any reviewer would see through these instantly and call me out for them, and I had a feeling I knew how my supervisor would react.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I was at my wits' end and didn't know how to really get out of the corner my supervisor put me in, and so I pulled the emergency brake, handed in my notice and left. Looking back, that was one of the best decisions I have made.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But, there is a point here, and I realise I have spent much more time on my Imperial College drama than was perhaps necessary. When I (and my peers) were running our supervisor's solver on our internal HPC cluster, we were quickly contacted by the HPC admin and effectively got a soft ban on using the system. They said that all of our accounts were now limited to a certain number of cores. I don't remember the exact number, but it was around 100 cores, definitely not enough for the Direct Numerical Simulations we wanted to perform.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The HPC team reviewed the scaling results of our supervisor's code, and seeing those results was reason enough to enact the ban on using more cores. It was seen as electricity waste. Let's look at the reasons.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>First of all, the communications weren't done very well, and a lot of time was wasted here. Some effort went into optimising the communications, and we need to look at the communications and their bottlenecks before we can understand this problem better. We'll do that in just a bit when talking about MPI. That was just one issue, though.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The other issue was the load balancing. Our code was just horrible at assigning work to other cores, and thus, we needed a new and better domain decomposition approach. Domain decomposition was done in the following way: Decide how many times you want to cut the mesh in the x, y, and z directions. This will give you the number of regions in the x, y, and z directions, and their product is the number of sub-domains and cores we need to run the simulation. Let's look at an example:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"500px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/aircraft_domain_decomposition.png" alt="Example of a simple domain decomposition for an aircraft, where the domain is split in the x and y direction separately, irrespective of the underlying geometry." class="wp-image-5550" style="width:500px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://aia.springeropen.com/articles/10.1186/s42774-024-00200-5" target="_blank" rel="noopener" title="">Yang and Yang 2025</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Here, we have decided that we will cut the domain once in the horizontal direction and once in the vertical direction. This will yield 2 regions in each direction, and so the number of sub-domains here is [katex]2\cdot 2=4[/katex]. This is what we can see in the figure above as well. Now, it doesn't take an Imperial College graduate to realise that this is perhaps not the best way of splitting work (or sub-domains).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>How can we ensure that each processor is getting the same number of cells? Well, we can't! We simply divide our domain into equal geometric chunks and <em>hope</em> that all will have an equal number of cells per sub-domain. And, as we all know, good science starts with a healthy portion of <em>hope</em> and <em>belief</em>. I refer to this approach as the <em>simple</em> or <em>naive</em> domain decomposition approach. It works well on Cartesian grids, or on a whiteboard in the classroom, but not in reality for even slightly more complex geometries.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, I worked on writing a new domain decomposition approach, where the number of cells per sub-domain would be taken into account. I also exploited the fact that we were only using structured grids for channel flows, so I could simplify my domain decomposition application. This is a sketch of what I essentially did:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"700px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/simple_domain_decomposition.png" alt="Example of a simple domain decomposition approach, where the mesh inside a channel is sliced normal along the flow direction, accounting for the number of cells in each sub-domain for good load balancing. " class="wp-image-5550" style="width:700px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>First, I would count how many cells there are in the mesh. In the example above, we have 192 cells. Then, I decide how many cores I want to use. In the example above, I am using 8 cores. Then I can compute that I will need [katex]192/8=24[/katex] cells per core to achieve good load balancing. So, I start at the left, I count how many cells are in the first layer, and if there are fewer than 24 cells, then I go to the next layer.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once I have exactly 24 cells or more in my sub-domain, I insert a slice and say all the cells to the left are now part of the first sub-domain. I continue going through the mesh and check where I should place my next slices. In this way, I approximately have the same number of cells per sub-domain, while also somewhat minimising the inter-processor boundaries.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are better ways to deal with this issue, but using this domain decomposition approach, along with the improvements we saw in the communications, allowed us to get much better strong scaling results, and we were taken off the naughty list and allowed to run our simulations on the cluster again.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Before we finish this section, let's look at how domain decomposition is done in OpenFOAM. It actually has a few different domain decomposition approaches implemented, such as the hierarchical one, which is doing essentially what I have implemented for our channel flow example. It allows the user to specify how many sub-domains should be created in the x, y, and z directions, and OpenFOAM will try to cut the domain in such a way that the number of cells per region is approximately the same.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There is one more domain decomposition approach, which is simply called "simple". An example of that can be found in the <a href="https://develop.openfoam.com/Development/openfoam/-/blob/master/tutorials/incompressible/pimpleFoam/LES/periodicHill/transient/system/decomposeParDict?ref_type=heads" target="_blank" rel="noopener" title="">periodic hill</a> case. This is working as we have discussed before, i.e. we tell OpenFOAM how many sub-domains we want in the x, y, and z direction, which are then split into geometrically equal portions, without any considerations given to the number of cells per sub-domain.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>My memory may serve me badly, but I have the feeling that the <em>simple</em> domain decomposition was used quite a bit in early tutorials, which now seem to have switched to <em>hierarchical</em>. I just wonder, is it any surprise that OpenFOAM has its origin at Imperial College? This poor domain decomposition approach seems to run in the family. (OK, I stop now ...)</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-using-space-filling-curves">Using space-filling curves</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>To be honest, this is probably the first, and probably also the last time you hear about space-filling curves in the context of domain decomposition approaches. That doesn't mean they are not good, quite on the contrary, space-filling curves are easy to construct, dividing a domain into sub-domains with the same number of cells per sub-domain is even simpler, and we do get a quite good ratio of cells per sub-domain to inter-processor boundaries.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>They really are something magical, at least to me, but that is mostly my Stockholm syndrome speaking. During COVID-19, we all did weird stuff, didn't we? For me, it was the summer of 2020 that stands out the most. Being on paid furlough by the university, with no kids yet to look after, and the Kim dynasty being busy with <a href="https://en.wikipedia.org/wiki/Korean_drama" target="_blank" rel="noopener" title="">K-dramas</a>, I had some time on my hands and so decided to get lost in the wonderful world of Peano and Hilbert space-filling curves.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Someone mentioned to me that their in-house solver used space-filling curves as their domain decomposition approach, and naturally, as a <em>professional</em> domain decomposition developer myself, I was instantly hooked, but I had no idea what these space-filling curves were. So I asked, "What are these space-filling curves"? He responded, "I have no idea, mate". Great ... So I looked for help, and spent the summer of 2020 with Michael Bader in bed (with <a href="https://www.amazon.co.uk/Space-Filling-Curves-Introduction-Applications-Computational/dp/3642310451/ref=sr_1_2?sr=8-2" target="_blank" rel="noopener" title="">his book</a>, I should clarify. Boy, this is going to be awkward when Frau Bader is reading this ...)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So why are these wonderful objects not used more commonly, at least in the field of CFD? Well, it always comes down to the non-linear term and turbulence; the two things structural (FEA) people fear more than the Greeks fear the Germans. Once we understand space-filling curves better, I will show you their Achilles' heel and why we don't use them, especially since better alternatives are available (discussed in the next section).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But before you say "OK, I don't need to hear more, I'll go straight to the next section", let me indulge you a bit in the fascinating world of space-filling curves. You'll learn something you had no idea you needed to know, and you probably will forget most of it, yet it is somehow incredibly satisfying to learn. I know, I make a horrible salesman, I guess there is a reason why I work in academia ...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>First, we need to learn about <a href="https://en.wikipedia.org/wiki/Turtle_graphics" target="_blank" rel="noopener" title="">turtle graphics</a>. Turtle graphics consists of a turtle, which can either move forward, turn left, or turn right, and we can specify the turning angle. The turtle can also draw its path, so we can follow its trajectory. Take a look at the following two examples:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"700px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/turtle_graphic_example.png" alt="Two examples of a turtle traversing over a Cartesian grid, leaving behind its travel path. " class="wp-image-5550" style="width:700px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>On the left, we start at the bottom left, and our initial direction is to the right (you could say, in the positive x direction). We define our forward direction as [katex]F[/katex], which means that our turtle is moving from one cell to the next in the current direction of travel. We further define turns to the left (counter-clockwise) as [katex]-[/katex] and turns to the right (clockwise) as [katex]+[/katex]. Each turn will be exactly 90 degrees. With a starting position and a starting direction, we can now define the steps the turtle makes for the left example as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
FF-F-F+FF+FF\tag{28}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>For the example on the right, we start now at the bottom right and define our initial starting direction in the negative x direction. With that in mind, we can define the path of the turtle as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
FFF+F+FFF-F-FFF+F+FFF\tag{29}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We say that the path travelled by the turtle on the left is not a space-filling curve, as it has not gone through each cell. The turtle on the right, however, does produce a space-filling curve, as it has travelled through all cells. There are many ways in which we can construct a space-filling curve, but some will have better properties than others, and we will see that in a second.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But before that, we have to talk about the <a href="https://en.wikipedia.org/wiki/L-system" target="_blank" rel="noopener" title="">Lindenmayer system</a>, usually abbreviated as just an L-system. Here is the Wikipedia definition of the L-system:</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><em>An L-system or Lindenmayer system is a parallel rewriting system and a type of formal grammar. An L-system consists of an alphabet of symbols that can be used to make strings, a collection of production rules that expand each symbol into some larger string of symbols, an initial "axiom" string from which to begin construction, and a mechanism for translating the generated strings into geometric structures.</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you understand a word of it, congratulations, I don't (and keep in mind that I already know what an L-system is). There is a simple test you can do to see if you understand the L-system from the introductory paragraph on Wikipedia. The L-system was originally developed to describe the growth of bacteria and branching structures like algae. If you think this makes sense, then you are the clever one. But I am dumb and need things explained to me like I am 5 years old, so allow me to offer my explanation as well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We already looked at a complete example of an L-system: our turtle graphics. An L-system consists of 4 aspects, which formalise the path of the turtle, the growth of bacteria or algae, or other branching structures. This is essentially the grammar that was mentioned in the definition above. These 4 aspects are:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Variables

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Constants

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Axiom

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Rules

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Let's apply that to our turtle example. We didn't have any variables in our system, and we will need a bit of explaining before we understand what variables are in the context of an L-system. The constants we had were [katex]-[/katex], [katex]+[/katex], i.e. for turning, and [katex]F[/katex], for moving forward.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The Axiom, sometimes also called the starter or initiator, essentially tells us our initial condition, for example, a starting direction, but more commonly, they refer to a starting rule, which brings me to the final point. Rules define how branching structures develop, or, in our example, how the turtle is moving. Let us write out the L-system for our first turtle example in full:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Variables: None

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Constants: [katex]F[/katex], [katex]+[/katex], [katex]-[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Axiom: [katex]F[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Rules: [katex]F \rightarrow FF-F-F+FF+FF[/katex]

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>So far, so good, but we rarely come up with systems in mathematics without some form of generalisation. So far, I have only said that L-systems are used to describe the path of a turtle, but I also mentioned that they can be used for branching structures. If you think about branching structures, especially in a mathematical sense, you may be thinking about <a href="https://en.wikipedia.org/wiki/Fractal" target="_blank" rel="noopener" title="">fractals</a>, and you would be right. Probably the most famous fractal is the Mandelbrot set, shown in the following:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"320px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/mandelbrot_sequence.gif" alt="A continuous zoom into the Mandelbrot set, showing that it continues to generate fractal shapes that become infinitely small. " class="wp-image-5550" style="width:320px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://en.wikipedia.org/wiki/File:Mandelbrot_sequence_new.gif" target="_blank" rel="noopener" title="">Wikipedia</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>So, the L-system helps us describe branching, or fractal structures. Take an example of some simple shapes shown in the figure below, we can <em>branch</em> these structures by creating the same base shape (shown on the left) with smaller elements of itself. So, we can also say that our branching structures, or fractals, are self-similar.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"500px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/generation_of_fractal_shapes.png" alt="Sequence of fractal generations. Starting with a basic shape, like a square or a triangle, each next iteration shows how this shape is repalced by a collection of smaller shapes, which are the same as the original shape. " class="wp-image-5550" style="width:500px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://mathworld.wolfram.com/Fractal.html" target="_blank" rel="noopener" title="">Wolfram Mathworld</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Once we have replaced the original shape with smaller elements of itself, we can replace these elements with smaller elements again, and this can be repeated until infinity, and the same principle was used to generate the animated GIF shown previously.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ok, we are almost there, so now we can apply this thinking to space-filling curves, and we can see why this becomes important. The following figure shows two special kinds of space-filling curves: the <a href="https://en.wikipedia.org/wiki/Hilbert_curve" target="_blank" rel="noopener" title="">Hilbert curve</a> and the <a href="https://en.wikipedia.org/wiki/Peano_curve" target="_blank" rel="noopener" title="">Peano curve</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"400px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/space_filling_curve_construction.png" alt="Example of a Hilbert and Peano space-filling curve, with the Hilbert curve looking like an upside-down U, and the Peano curve like an N (with some imagination)." class="wp-image-5550" style="width:400px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Yes, people have gotten fame for drawing curves like these in the past, different times, I suppose. But in all seriousness, usually it is difficult to appreciate the complexity behind an elegant solution that generalises to something as simple as the Peano and Hilbert curves.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Both of these curves are excellent for traversing a computational mesh and going through each cell. They do that by applying the same principles of fractals we have seen above. Let's take the Hilbert curve as an example. In the figure above, we can say that the Hilbert curve currently goes through a 4-cell mesh. If we apply some mesh refinement, by halving the distance in x and y, for example, we can create a finer grid. In a sense, we have applied fractal thinking to mesh generation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can do the same with our space-filling curve as well, as shown in the following:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"800px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/hilbert_fractal_example.png" alt="Example of a Hilbert curve, and how we can apply it for grids that get smaller. The Hilbert curve is replaced by a fractal representation, until each cell is again covered by a Hilbert curve. " class="wp-image-5550" style="width:800px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Here, we replace the original Hilbert space-filling curve with its fractal representation. Doing that means that we still cover the entire mesh. I have connected the individual Hilbert curves with an orange line to show that this space-filling curve is <em>continuous</em>. I was mocking Hilbert for making his name on a simple geometry curve, but in reality, his curve is not just space-filling, but also continuous, and that is a restriction on our set of curves which is far more difficult to prove mathematically.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So the question is, how can we generalise this using the L-system? The key is to introduce variables. Let's write out the L-system for a Hilbert space-filling curve, and then we'll discuss it:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Variables: [katex]A[/katex], [katex]B[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Constants: [katex]F[/katex], [katex]+[/katex], [katex]-[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Axioms: [katex]A[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Rules:

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>  - [katex]A \rightarrow +BF−AFA−FB+[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>  - [katex]B \rightarrow −AF+BFB+FA−[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>OK, let's start with what is simple. The constants are the same as in our turtle graphic example. To construct a space-filling Hilbert curve, well, we could get away with the definition of [katex]F\rightarrow F+F+F[/katex], right? At least if we look at the first iteration of the Hilbert curve, i.e. the left-most curve in the previous figure, then this rule would be sufficient to construct such a space-filling Hilbert curve. But, this system would not generalise to larger meshes (i.e. mesh refinement, as seen on the right of the figure).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, we introduce variables, and it is the variables which provide us with the power of fractals. Let me give you an analogy. If we want to compute the Fibonacci sequence, we can do that with the following recursive equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
F_i = F_{i-1} + F_{i-2}\quad \forall\, i\ge 2 \tag{30}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We require that [katex]i[/katex] is not smaller than 2, and as long as that is the case, and we use the initial data [katex]F_0=0[/katex] and [katex]F_1=1[/katex], we can compute any Fibonacci number based on this recursive equation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With space-filling curves, it is sort of the same idea. If we look at the rules, we see that both [katex]A[/katex] and [katex]B[/katex] are defined recursively. The key to understanding this rule is that we don't draw variables; we only draw constants according to our L-system. But how do we deal with [katex]A[/katex] and [katex]B[/katex] then?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, we first need to define how often we want to refine our Hilbert curve. In the figure above, we were drawing the original Hilbert curve on the left. So, this curve is said to be at iteration zero (no refinement done to the original curve). But, to its right, the Hilbert curve was refined once, and so we say that this is the first iteration of the Hilbert curve. If we refine the mesh further and use a further refined Hilbert curve, then we get the second, third, fourth, ... iteration of the Hilbert curve.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For our rules in the L-system, it means that we have to apply the number of iterations to the rules, i.e. substitute [katex]A[/katex] and [katex]B[/katex] into themselves. Once we have done that for all iterations, we are done. At that point, we simply remove (or ignore) any variables, and only draw the path according to [katex]F[/katex], [katex]+[/katex], and [katex]-[/katex] instructions. Let's show that for iterations 0 and 1.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For iteration 0, we said we don't need to substitute anything, and so we can simply remove all occurrences of [katex]A[/katex] and [katex]B[/katex] from our rules. This gives us:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Iteration 0:

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>  - The rule for [katex]A[/katex] was: [katex]A \rightarrow +BF−AFA−FB+[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>  - The drawing instructions for [katex]A[/katex] become [katex]A \rightarrow F−F−F[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>  - The rule for [katex]B[/katex] was: [katex]B \rightarrow −AF+BFB+FA−[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>  - The drawing instructions for [katex]B[/katex] become [katex]A \rightarrow F+F+F[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Since our axiom (starting point) for the Hilbert curve is [katex]A[/katex], and in the zeroth iteration, [katex]A[/katex] does not depend on [katex]B[/katex], we can ignore [katex]B[/katex] in the zeroth iteration. But, we see one important detail here, and the reason why we have both [katex]A[/katex] and [katex]B[/katex] defined: [katex]A[/katex] is constructing the Hilbert curve in a counterclockwise direction, while [katex]B[/katex] is defining it in a clockwise direction. We need that to be able to change directions; otherwise, we would not be able to construct a <em>continuous</em> space-filling curve.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Try to draw both [katex]A[/katex] and [katex]B[/katex] on paper; once you do, the system will make sense. The zeroth iteration is something you may be able to do in your head, but let's look at the first iteration and see how this is done. Remember, we have to insert [katex]A[/katex] and [katex]B[/katex] into itself however many iterations we have. So, in our case, we have the first iteration and so have to substitute [katex]A[/katex] and [katex]B[/katex] once into itself. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Iteration 1:

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>  - The rule for [katex]A[/katex] was: [katex]A \rightarrow +BF−AFA−FB+[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>  - The rule for [katex]B[/katex] was: [katex]B \rightarrow −AF+BFB+FA−[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>  - Inserting [katex]A[/katex] and [katex]B[/katex] once into itself results in: [katex]A \rightarrow +(−AF+BFB+FA−)F−(+BF−AFA−FB+)F(+BF−AFA−FB+)−F(−AF+BFB+FA−)+[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>  - Inserting [katex]A[/katex] and [katex]B[/katex] once into itself results in: [katex]B \rightarrow −(+BF−AFA−FB+)F+(−AF+BFB+FA−)F(−AF+BFB+FA−)+F(+BF−AFA−FB+)−[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, we can again either remove or ignore any occurrences of [katex]A[/katex] and [katex]B[/katex] to get the drawing instructions. This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
A \rightarrow +(−AF+BFB+FA−)F−(+BF−AFA−FB+)F(+BF−AFA−FB+)−F(−AF+BFB+FA−)+ \\[1em]
A \rightarrow +(−F+F+F−)F−(+F−F−F+)F(+F−F−F+)−F(−F+F+F−)+ \\[1em]
A \rightarrow +−F+F+F−F−+F−F−F+F+F−F−F+−F−F+F+F−+ \\[1em]
A \rightarrow F+F+F−FF−F−F+F+F−F−FF−F+F+F\tag{31}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>For [katex]B[/katex], we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
B \rightarrow −(+BF−AFA−FB+)F+(−AF+BFB+FA−)F(−AF+BFB+FA−)+F(+BF−AFA−FB+)− \\[1em]
B \rightarrow −(+F−F−F+)F+(−F+F+F−)F(−F+F+F−)+F(+F−F−F+)− \\[1em]
B \rightarrow −+F−F−F+F+−F+F+F−F−F+F+F−+F+F−F−F+− \\[1em]
B \rightarrow F−F−F+FF+F+F−F−F+F+FF+F−F−F\tag{32}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, I have done the following things: first, I have removed all occurrences of [katex]A[/katex] and [katex]B[/katex]. Then, I have removed the parentheses, which were only there to help us see where we have inserted [katex]A[/katex] and [katex]B[/katex] into themselves. We end up with a few instructions that cancel each other out. For example, we get a few [katex]+-[/katex] and [katex]-+[/katex] instructions, which basically state "turn clockwise by 90 degrees, then turn counterclockwise by 90 degrees", and vice versa. So we can ignore those instructions as well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What we end up with is again a system that only depends on [katex]F[/katex], [katex]+[/katex], and [katex]-[/katex]. We also see that we sometimes get [katex]F[/katex] twice in a row. If that is the case, just draw two lines, both of the same length as any previous line you drew. To make this clear, the following figure shows how the first iteration of the Hilbert curve looks for [katex]A[/katex] and [katex]B[/katex]:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/first_iteration_hilbert_curve.png" alt="The first iteration of the Hilbert curve, drawn for both A and B. A and B are just mirror images of each other. " class="wp-image-5550" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>As we can see, [katex]A[/katex] and [katex]B[/katex] produce the same curve; they are just a mirror image of each other. You might be wondering how I determined the starting direction. Well, I picked one at random. The shape will be rotated by 90/180/270 degrees if you pick another direction, and as we will see in a second, regardless of the initial starting direction we pick, we still get a space-filling curve, no matter what.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Based on the L-system, we can now divide our mesh more and more, and then we have to keep fractalising (probably not a word) our Hilbertious curves (definitely not a word). And, because I am a sucker for space-filling curves, of course, I have written a Python script to do that. Here are the first 5 iterations of the Hilbert curve:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"1000px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/hilbert_curve_5_iterations.png" alt="Example of the Hilbert curve for the first 5 iterations of mesh refinement and subsequent application of the fractal Hilbert curves. " class="wp-image-5550" style="width:1000px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>If you want to test your knowledge now, here is the L-system for the Peano curve:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Variables: [katex]A[/katex], [katex]B[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Constants: [katex]F[/katex], [katex]+[/katex], [katex]-[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Axioms: [katex]A[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Rules:

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>  - [katex]A \rightarrow AFBFA+F+BFAFB−F−AFBFA[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>  - [katex]B \rightarrow BFAFB−F−AFBFA+F+BFAFB[/katex]</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I have implemented that as well in my Python script, and the first 5 iterations for it are shown in the following as well:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"1000px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/peano_curve_5_iterations.png" alt="Example of the Peano curve for the first 5 iterations of mesh refinement and subsequent application of the fractal Peano curves. " class="wp-image-5550" style="width:1000px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>OK, we went quite far without talking about domain decomposition. So here it comes. We know how long our Hilbert or Peano space-filling curves are. Every time we draw a line with an [katex]F[/katex] instruction, we have just extended the curve by 1. So, for example, in the zeroth iteration of the Hilbert curve, the curve is 3 units long, while the Peano curve is 8 units long. In the first iteration, the Hilbert curve is 15 units long, while the Peano curve is 80 units long.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we compare that to the number of cells, then we see that in the zeroth iteration, we have 4 cells for the Hilbert curve and 9 cells for the Peano curve. For the first iteration, this increases to 16 and 81 cells, respectively. Comparing that with the length of each respective curve, we see that the connection between the number of cells and the line segments (LS) of each space-filling curve is:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
N_{cells} = N_{LS} + 1\tag{33}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Another property is that space-filling curves are localised. That means they fill up one area entirely before they move to another area. Both of these properties make space-filling curves ideal domain decomposition tools!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We take the number of line segments and divide it by the number of processors. This will give us the number of cells per sub-domain. All we have to do now is go along the space-filling curve and flag these cells, as well as count them, until we reach the number of cells required per sub-domain. All of the cells we have flagged will now be part of that sub-domain. We then continue to flag the next set of cells, which will be part of the next sub-domain, and again, we do that until we have reached the required number of cells per sub-domain.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Because space-filling curves are local, i.e. they try to fill up the space in one area before expanding, they will also give us a pretty good inter-processor boundary distribution, i.e. one where we minimise the number of cells in the inter-process boundaries per sub-domain. It isn't perfect, but considering that we don't have to spend any thought on it, it is pretty decent.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's do that for our Hilbert and Peano space-filling curves. In the following, I am dividing three iterations of each curve into 16 sub-domains so I can solve each with 16 cores. Each sub-domain, or rather, each curve per sub-domain, is now being plotted with a different colour so we can see which cells belong to which sub-domain. Also, the space-filling curve is no longer continuous. Well, it is, I have just not plotted it this way to show where the curve breaks into different sub-domains.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For the Peano curve, I am getting the following:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"1000px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/peano_curve_with_16_CPUs.png" alt="Example of the Peano curve for 3 iterations of mesh refinement and subsequent application of the fractal Peano curves. In addition, the space-filling curve is split into 16 equal sized curves and coloured differently, to show which cells would be part of which processor should we use this curve as a domain decomposition approiach. " class="wp-image-5550" style="width:1000px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>I just said that we get a pretty decent inter-processor boundary by default, but the Peano curve doesn't seem to have an interest in doing this. Well, let's have a look at the Hilbert curve and see how it handles the domain decomposition:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"1000px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/hilbert_curve_with_16_CPUs.png" alt="Example of the Hilbert curve for 4 iterations of mesh refinement and subsequent application of the fractal Peano curves. In addition, the space-filling curve is split into 16 equal sized curves and coloured differently, to show which cells would be part of which processor should we use this curve as a domain decomposition approiach. " class="wp-image-5550" style="width:1000px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Pretty good, don't you think? As I said, it isn't perfect, and with a bit of tweaking, we can certainly improve things, but given that our domain decomposition essentially consists of only splitting the space-filling curve into equally long pieces, we are getting a pretty good result for not trying very hard.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>OK, let's change things up a bit. Now I want to use 9 cores, let's see how our Peano and Hilbert curves are doing now. For the Peano curve, I am getting:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"1000px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/peano_curve_with_9_CPUs.png" alt="Example of the Peano curve for 3 iterations of mesh refinement and subsequent application of the fractal Peano curves. In addition, the space-filling curve is split into 9 equal sized curves and coloured differently, to show which cells would be part of which processor should we use this curve as a domain decomposition approiach. " class="wp-image-5550" style="width:1000px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>And for the Hilbert curve, I am getting:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"1000px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/hilbert_curve_with_9_CPUs.png" alt="Example of the Hilbert curve for 4 iterations of mesh refinement and subsequent application of the fractal Peano curves. In addition, the space-filling curve is split into 9 equally sized curves and coloured differently, to show which cells would be part of which processor, should we use this curve as a domain decomposition approach. " class="wp-image-5550" style="width:1000px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>The results seem to be reversed. Can you work out why? Look at the zeroth iteration of the Hilbert and Peano curve. The Hilbert curve needs a 2 by 2 grid, while the Peano curve requires a 3 by 3 grid. In computer science, everything is binary-based, i.e. we use binary numbers and the number of cores on a CPU follows a base 2 distribution (i.e. it follows [katex]N_{cores} = 2^N[/katex] where [katex]N[/katex] is an integer).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We already discussed that for this reason, it is best if the number of cores follows the same base 2 distribution rule when we determine the optimal number of cores. And so, having a base 2 by 2 grid to start our space-filling curve aligns well with our needs in computer science for everything to be based on multiples of 2.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Should we ever decide to ditch our binary number basis in computer science for a ternary number basis (base-3), then Peano curves will shine, as they are already based on a 3 by 3 grid.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, if we are using space-filling curves as a domain decomposition approach, Hilbert curves are the ones we want to use. I should say, though, that there are quite a few more space-filling curves out there. For example, the <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_curve" target="_blank" rel="noopener" title="">Sierpinski curve</a> and <a href="https://en.wikipedia.org/wiki/Z-order_curve" target="_blank" rel="noopener" title="">Z-order curve</a> (also known as the Morton space-filling curve) are two examples which are quite popular.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, when I was working with the Discontinuous Galerkin (DG) method, having several integration points per face, all of these were arranged with a Z-order curve. This was important because I was using an implementation where all elements/cell types were projected onto a unit element, and I needed to make sure that the integration points on the faces matched with their neighbours, so a consistent order was required. So, spacing-filling curves have much more subtle use cases as well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The Sierpinski curve, on the other hand, can be used for triangular and tetrahedral meshes, extending the idea of space-filling curves to unstructured grids as well. So, before you get all excited and want to create your own space-filling curve, there isn't much space left for more curves. It seems this space is filled already (OK, I stop now).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another beautiful property of space-filling curves is that mesh refinement is something they handle out of the box without any problem. Take a look at the following example, where the Hilbert space-filling curve is traversing a grid with different levels of refinement:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"300px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/hilbert_space_filling_curve_with_refinement.png" alt="The Hilbert space-filling curve with a locally refined mesh, showing how this curve adapts to the different mesh refinement levels. " class="wp-image-5550" style="width:300px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>So, it seems, space-filling curves are the future in domain decomposition, right? I wish this were the case, but it is not. They work really well if all we ever want to deal with are Cartesian grids, or even Cartesian cut-cell grids with some modifications. But I'm afraid it is not that simple.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While Cartesian grids are definitely again on the rise in CFD, with almost every commercial and some open-source CFD solvers advocating the use of a Cartesian grid for <em>the most part</em> of the domain, Cartesian grids have one strong weakness: the number of cells required to resolve boundary layer flows becomes excessive!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For this reason, we typically build our 3D volume mesh first and then add inflation layers on top of that, which are far more economical than using Cartesian grids to resolve the boundary layer. The cells of the Cartesian mesh which overlap with the inflation layers are then removed, and both grids are then connected.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Doing this will destroy our space-filling curves, and so, if we are interested in even just moderately complex 3D turbulent flows, space-filling curves are not here to save the day (but at least now you have an idea about them and perhaps feel also slightly intrigued by them, just as much as I do).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, if we want to come up with a general domain decomposition approach, we have to leave the wonderful world of space-filling curves behind us and start looking at graph partitioning and how this can be applied to any type of mesh.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And, if you happen to teach CFD at Imperial College, don't worry, you can skip the next section. I don't want to be the one telling you Santa Claus isn't real, so keep using your hierarchical domain decomposition approach and be happy with it. Instead, here is a German proverb (I'll even translate it for you): <em>"The dumbest farmers have the biggest potatoes"</em>. While me and the others talk about graph-partitioning, I'll let you figure out what it means for you and your domain decomposition approach.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-the-gold-standard-graph-partitioning-based-domain-decomposition">The gold standard: Graph partitioning-based domain decomposition</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let me start this section with an example that all of us should be familiar with: Group work. As a student, you will at some point likely have gone through group work during your studies, as a graduate, you will know this better under the name teamwork, and as an academic, well, you will have to organise and coordinate group work activities.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We all know that there is always a chance that people don't get along in a group, and that can reduce the productivity of the entire group. When I started to teach at the university, the person coordinating one of the group projects I was involved with put students into groups at random, with predictable results: there were conflicts in each group, and overall, the group project suffered from it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That person told the students that it is important to have a <em>professional working relationship</em> and be functional as a group, even if you don't get along personally. The same academic was embroiled in many conflicts at work, all due to personal reasons, going as far as putting colleagues in hospital. Leading by example.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In any case, let's look at a possible group formation. The table below shows 3 groups, where each group contains 3 students. We can assume that students are put into groups at random or in alphabetical order. It doesn't really matter how we put them into their groups, but the important fact is that we provided the group structure, and the students were not allowed to group themselves into groups.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table class="has-fixed-layout"><tbody><tr><td><strong>Group 1</strong></td><td><strong>Group 2</strong></td><td><strong>Group 3</strong></td></tr><tr><td>Student 1</td><td>Student 4</td><td>Student 7</td></tr><tr><td>Student 2</td><td>Student 5</td><td>Student 8</td></tr><tr><td>Student 3</td><td>Student 6</td><td>Student 9</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>We can ask each student now which group members they would have preferred to stay with (for example, their friends). Let's say we get the following answer:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Student 1 wants to stay with Student 8 and Student 9

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Student 2 wants to stay with Student 5 and Student 7

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Student 3 wants to stay with Student 4 and Student 6

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>If we wanted to visualise this, we could express the table above slightly differently, in visual form. The figure below shows each student represented as a vertex (numbered 1 to 9). We then connect the vertices (students) who would like to work together. We arrange them into 3 columns, like the table above, where we have students (vertices) 1 to 3 on the left, students (vertices) 4 to 6 in the middle, and students (vertices) 7 to 9 on the right.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"300px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/graph_example_students_unordered.png" alt="A graph representation showing students as vertices and edges as friendship connections between students (vertices). " class="wp-image-5550" style="width:300px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>What this figure shows us is how many connections there are between groups, and this representation is known as a graph. We can now see that we have 3 connections (which are called edges in a graph) from students (vertices) in group 1 to group 3, but no connection from group 2 to group 3, for example. If we now change the group composition so that we respect the preference of students, then we end up with the following graph representation:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"300px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/graph_example_students_ordered.png" alt="A reordered view of the graph that represents friendships between students. If re-arranged, no edges cross, and all friends stay in the same group. " class="wp-image-5550" style="width:300px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>This looks much cleaner, doesn't it? Let's change this example to a company. We have three groups working on the same product. Some people work together (for example, the CAD and CFD engineer may work closely together), while others do not work together (for example, finance and the CAD or the CFD engineer). We have three offices in three different cities.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In each group, we can represent employees as vertices. And, if they have to work closely together (on a daily basis, for example), we can connect these vertices (employees) through an edge in our graph. So, instead of thinking of the edges in our graph as friendships, these show now the dependencies of who is working together.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Using the same two graphs we saw before, we can see that the first graph will result in a lot of communications between the three different groups in the three different cities (we assume, again, that the three different teams/groups are separated by the three different columns). If we imagine the cities to be spread around the world, we may have a situation where one employee is waiting for an answer from someone else who is currently not working because they may be several time zones ahead or behind. Not good for productivity!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we, instead, arranged all employees as seen in the second graph so that there are no edges across teams/groups, then all communication can happen internally, and all groups could work independently.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now imagine that instead of students or employees, the graph represents our computational mesh. Each vertex corresponds to a cell in our mesh (so, in our example above, we would have 9 cells), and each edge represents which cells (vertices) are connected, i.e. they share a face and are neighbouring cells.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we create such a graph of our computational mesh, then we can use this graph representation for our domain decomposition. We simply divide the number of vertices in our graph by the number of processors we want to use for our parallel computation. This will give us a good load balance. But how do we group cells (vertices) together so that we have the least amount of communications across inter-processor boundaries?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, the edges represent neighbouring elements, and communications are always done between neighbouring elements. For example, if I am trying to solve the heat diffusion equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial T}{\partial t} = \alpha\frac{\partial^2 T}{\partial x^2},\tag{34}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>and I use a finite-difference approximation of the form:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
T_{i}^{n+1} = T_i^n + \frac{\alpha\Delta t}{(\Delta x)^2}\left(T_{i+1}^n - 2T_i^n + T_{i-1}^n\right)\tag{35}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>then I can say that for cell [katex]i[/katex], the neighbouring cells are located at [katex]i+1[/katex] and at [katex]i-1[/katex]. If, for example, [katex]i+1[/katex] is on a different sub-domain and solved for by a different processor, then I will need to communicate with that processor to give me [katex]T_{i+1}^n[/katex]. However, I don't care, for example, about [katex]T_{i+7}^n[/katex], because this is not my direct neighbour at location [katex]i[/katex] and thus not part of my finite-difference approximation for [katex]T_i^{n+1}[/katex]. Therefore, I will only need values for [katex]T[/katex] from the direct neighbours of cell [katex]i[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With that knowledge in hand, we can try to cut our graph that represents the computational mesh into equal sub-domains (same number of vertices), subject to minimising the number of edges between the partitioned graph (minimising the number of neighbours between sub-domains, or, minimising the inter-processor boundary).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is the basic idea of graph partitioning and how we can use it for the task of domain decomposition. If we want to do that, though, we first need to know how we can create the graph in the first place.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I mentioned above that we create a graph by first drawing as many vertices as there are cells in the mesh, and then connecting those vertices with an edge that are next to each other in the mesh (neighbouring cells). Take, for example, the following structured mesh:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/mesh_connectivity_structured_grid.png" alt="This figure shows a structured mesh, where each cell is numbered. To the right, there is a matrix with the same number of columns and rows as the number of cells. A cross is shown within this matrix where two cells share a connection (i.e. neighbouring cells). " class="wp-image-5550" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>On the left, we see the 3 by 3 structured mesh, and each cell has its own cell ID. On the right, we see a matrix with crosses. A cross represents a neighbouring cell pair. So, for example, cell 1 and cell 2 are neighbours, and so in row 1, column 2, we have a cross. We also place a cross in row 2 and column 1, because the connection goes both ways (i.e. cell 2 is a neighbour of cell 1 (first row), but cell 1 is also a neighbour of cell 2 (second row)).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, we go through each row in the matrix, where the row ID corresponds to the cell ID, and we put a cross into each column, where the column ID corresponds to the cell IDs of neighbouring cells. If two cells are not neighbours, then there will be no cross. This representation is fairly common and represents a matrix structure.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Later, when we discretise our system of equation and we solve it, for example, with an implicit solver (i.e. we are solving the system [katex]\mathbf{Ax}=\mathbf{b})[/katex], then we would get the same matrix structure as seen above for [katex]\mathbf{A}[/katex], except that instead of crosses, we get numerical values. Cells with no crosses will have a zero. If you want to have some additional explanation with examples of how to construct this type of matrix, I have a dedicated article <a href="https://cfd.university/learn/how-to-compile-write-and-use-cfd-libraries-in-c/how-to-write-a-cfd-library-the-sparse-matrix-class/" target="_blank" rel="noopener" title="">on how to assemble these types of matrices</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can then use this matrix to identify neighbouring cells. For any given cell ID, we go into that row and check which columns have a cross. For example, cell 5 (row 5) has cells 2, 4, 5, 6, and 8 as neighbouring cells. Yes, we count 5 here as well, which is perhaps somewhat confusing, but only if we think of edges as neighbours. Technically speaking, the edges represent the cells that are required to compute an updated solution.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, to compute [katex]T_i^{n+1}[/katex], we don't just need its neighbouring values, i.e. [katex]T_{\pm 1}^n[/katex], but also the value at [katex]i[/katex] itself, i.e. [katex]T_i^n[/katex]. Thus, we say that cells depend on themselves, and that is why cell 5 has cell 5 listed as its <em>neighbour</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can now draw out the graph again, by placing all vertices (9 in total) and then connecting them so that each neighbouring cell is connected through an edge to its neighbour. We obtain the following graph:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"300px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/mesh_connectivity_structured_mesh_graph.png" alt="This figure shows a structured mesh, where each cell is numbered. To the right, there is a matrix with the same number of columns and rows as the number of cells. A cross is shown within this matrix where two cells share a connection (i.e. neighbouring cells). " class="wp-image-5550" style="width:300px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>This looks pretty much like our structured grid, doesn't it? However, we could have also drawn the graph in a completely different order, as seen below:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"300px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/mesh_connectivity_structured_mesh_graph_unordered.png" alt="This figure shows the same graph for the structured grid in the previous example, just with a different order. While each vertex is still connected to the same vertices as before, the graph looks visually completely different. " class="wp-image-5550" style="width:300px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>The graphs in the previous two figures are identical. You can verify that by looking at which vertices are connected, and you will see that they have exactly the same connections. Thus, a graph can be drawn arbitrarily, and some representation may help better see the inherent structure the graph represents, for example, a structured grid.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, imagine I asked you to partition your graph into three equally sized graphs, while minimising the number of edges between graphs. Go back to the previous graph, and you can see that two cuts, either horizontally or vertically, will result in 3 partitioned graphs. This is shown in the following for the first two figures:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/example_of_grap_partitionings.png" alt="This figure shows how we can split our structured mesh into three different sub-domains while trying to minimise the number of cut edges. " class="wp-image-5550" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>In the last example, I have cut the graph diagonally, which results in a total of 8 edges being cut (which means we have a total of 8 communications, or an average of 2.67 communications per sub-domain). Compare that to the vertical and horizontal cut, which results in only 6 total communications, or 2 per sub-domain, on average.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The nice thing about graph partitioning is that it only requires information about neighbouring cells, nothing else, and so this can be easily extended to unstructured grids as well. Take the following unstructured grid, for example, where I have shown the same matrix as in the previous example, where we can read neighbouring cell IDs directly for each cell by going to its corresponding row:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/mesh_connectivity_unstructured_grid.png" alt="This figure shows an unstructured mesh, where each cell is numbered. To the right, there is a matrix with the same number of columns and rows as the number of cells. A cross is shown within this matrix where two cells share a connection (i.e. neighbouring cells). " class="wp-image-5550" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We can construct the graph from this matrix as:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"300px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/mesh_connectivity_unstructured_mesh_graph.png" alt="This figure shows an unstructured mesh, where each cell is numbered. To the right, there is a matrix with the same number of columns and rows as the number of cells. A cross is shown within this matrix where two cells share a connection (i.e. neighbouring cells). " class="wp-image-5550" style="width:300px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We can now consider, again, how we would have to cut this domain so that we have the same number of vertices per sub-domain and the least number of edges that connect vertices between sub-domains.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The only thing we need now is some form of algorithm that can do that for us. We are in luck, people have thought about this problem a long time ago, and we simply have to pick whichever algorithm we prefer the most. A good algorithm to get started is the <a href="https://en.wikipedia.org/wiki/Kernighan%E2%80%93Lin_algorithm" target="_blank" rel="noopener" title="">Kernighan-Lin algorithm</a>, or K-L algorithm in short. It is rather slow, but with a few adjustments, it can be made performant again. So, let's review this algorithm.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The K-L algorithm takes an existing graph and will produce two balanced, disjoint (not-connected) graphs, where communications (edges between disjoint graphs) are minimised. We have to provide two disjoint graphs as an input, but we do not have to care whether they are already balanced (i.e. the edges between graphs are minimised). Some of you may have realised one limitation of the algorithm: we can only partition a graph into two graphs, not an arbitrary number of sub-graphs (equivalent to sub-domains in our case).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is yet again another reason why we should partition our mesh with [katex]2^N[/katex] sub-domains, with [katex]N[/katex] being an integer, because our algorithms work best for these cases. Having said that, modifications have been introduced to allow for an arbitrary number of sub-domains (disjoint graphs), though these are corrections and thus may not necessarily yield the most optimal graph. We are standing a much better chance if we stick to [katex]2^N[/katex] partitions.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's go through the algorithm step by step with an example graph, which is shown in the following figure:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"300px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/keringhan_lin_example_start.png" alt="This figure shows an example graph, where vertices are coloured in two different colours to show the partition they belong to. " class="wp-image-5550" style="width:300px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Here, I have already coloured the vertices based on an initial distribution I have come up with. Well, we can see that it is probably not optimal, but that is good, so we see how the K-L algorithm works and improves our partition. I have grouped the 8 vertices into two initial partitions as:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Graph [katex]A[/katex]: Vertices [katex]{1,\,2,\,3,\,4}[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Graph [katex]B[/katex]: Vertices [katex]{5,\,6,\,7,\,8}[/katex]

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>So you see, coming up with an initially partitioned graph isn't really a problem; we just assigned the first half of the vertices to subset [katex]A[/katex] and the second half of the vertices to subset [katex]B[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, the K-L determines the cost for each vertex, which is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
D(v) = E(v) - I(v) \tag{36}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]v[/katex] is any of the vertices, i.e. vertex 1 to 8 in our example, and [katex]E(v)[/katex] and [katex]I(v)[/katex] are the external and internal costs, respectively.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The internal cost is the number of edges for vertex [katex]v[/katex] that connect to other vertices in the same graph. That is, if [katex]v[/katex] is part of [katex]A[/katex], then any edge to vertices 1, 2, 3, or 4 would be counted as internal edges. If [katex]v[/katex] was part of [katex]B[/katex], then any edge connecting it to vertex 5, 6, 7 or 8 would be an internal edge. Thus, [katex]I(v)[/katex] is the number of edges that exist in the same graph.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The external cost, on the other hand, is the number of edges that connect [katex]v[/katex] with vertices in the other graph. Thus, if [katex]v[/katex] is in [katex]A[/katex], then any edge connecting it to 5, 6, 7, or 8 would be counted as an external cost. Similarly, if [katex]v[/katex] is in [katex]B[/katex], then any edge connecting it to vertices 1, 2, 3, or 4 would be an external edge as well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This sounds all wonderfully abstract, so let's see that with a concrete example. Take vertex 5, which is in [katex]B[/katex]. It has a total of 3 edges, and all of them point to vertices in [katex]A[/katex], so [katex]E(5) = 3[/katex]. There are no edges connecting it to vertices in [katex]B[/katex], and so [katex]I(5) = 0[/katex]. Thus, we can compute the cost as [katex]D(5) = E(5) - I(5) = 3 - 0 = 3[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We do this calculation now for each vertex, which results in the following table:</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table class="has-fixed-layout"><tbody><tr><td class="has-text-align-center" data-align="center">Vertex</td><td class="has-text-align-center" data-align="center">[katex]E(v)[/katex]</td><td class="has-text-align-center" data-align="center">[katex]I(v)[/katex]</td><td class="has-text-align-center" data-align="center">[katex]D(v)[/katex]</td></tr><tr><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">2</td></tr><tr><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">1</td></tr><tr><td class="has-text-align-center" data-align="center">3</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">1</td></tr><tr><td class="has-text-align-center" data-align="center">4</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">2</td></tr><tr><td class="has-text-align-center" data-align="center">5</td><td class="has-text-align-center" data-align="center">3</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">3</td></tr><tr><td class="has-text-align-center" data-align="center">6</td><td class="has-text-align-center" data-align="center">3</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">2</td></tr><tr><td class="has-text-align-center" data-align="center">7</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">-1</td></tr><tr><td class="has-text-align-center" data-align="center">8</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">0</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>Let's look at these values and the graph that we saw before. If we get a high value for [katex]D(v)[/katex], then we have lots of connections between [katex]A[/katex] and [katex]B[/katex] (or, rather, we have more external than internal edges). So, it stands to reason that we want to look at those vertices that have a high [katex]D(v)[/katex] value and see what we can do about them. The highest value is obtained for vertex 5, with [katex]D(5) = 3[/katex] as we have calculated before. However, if 5 had been part of [katex]A[/katex], then [katex]D(5)= -3[/katex], because now all edges would be internal edges.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, high values of [katex]D(v)[/katex] indicate potential of swapping in order to reduce the number of external edges (communications), while low values indicate that we want to keep them in the subset they are already in.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we stick with vertex 5, then we have established that swapping it with a point in [katex]A[/katex] would be beneficial. But which one? We need another equation that will determine which pair of vertices will provide the most optimal swap. For this simple example, we can likely work that out ourselves, but if our graph has, say, 76,584 vertices, it'll be <em>slightly</em> more complicated, so let us instead think about how we can achieve that.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We have established that vertex 5 in subset [katex]B[/katex] should swap with one of the vertices in subset [katex]A[/katex]. So, our goal is to find a vertex in [katex]A[/katex] that has a high value of [katex]D(v)[/katex] as well. This high value would indicate that a swap would be beneficial for that vertex as well. In our example, we see that both vertex 1 and 4 have a value of [katex]D(1) = 2[/katex] and [katex]D(4) = 2[/katex]. Thus, a swap between vertices 1 and 5 or 4 and 5 would be ideal.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Mathematically, we could say that we want to maximise [katex]D(a) + D(b)[/katex], where [katex]a[/katex] are vertices in [katex]A[/katex] (i.e. 1, 2, 3, and 4) and [katex]b[/katex] are vertices in [katex]B[/katex] (i.e. 5, 6, 7, and 8). Let's look at vertex pair 1 and 5. When we counted the external edges, we counted the connection from 1 to 5 when we computed the external cost for vertex 1, and we counted the connection between 5 to 1 when we computed the external cost for vertex 5, respectively. When we swap 1 and 5, this external edge will still exist.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Therefore, if we swap vertices 1 and 5, we will still retain this external edge, and it will appear twice, i.e. going from vertex 1 to 5 and going from vertex 5 to 1.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, if we say that we want to find the highest value of [katex]D(a) + D(b)[/katex], we need to subtract a value of 2 from it if, and only if, vertices [katex]a[/katex] and [katex]b[/katex] share an edge between them, to account for the fact that after the swap, this external edge still exists.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Putting all of this together, we can compute the so-called <em>Gain</em> of vertex pair [katex]a[/katex] and [katex]b[/katex] as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
Gain(a,b) = D(a) + D(b) - 2c_{a,b}
\tag{37}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]D(a)[/katex] and [katex]D(b)[/katex] are defined as before, and the additional term [katex]-2c_{a,b}[/katex] accounts now for a potential external edge between vertex [katex]a[/katex] and [katex]b[/katex]. The value of [katex]c_{a,b}[/katex] is 1 if an edge between [katex]a[/katex] and [katex]b[/katex] exists, otherwise it is 0. In our example, we have [katex]c_{a,b}=c_{1,5}=1[/katex], because both 1 and 5 are connected through an edge.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Therefore, the computed gain between [katex]a[/katex] and [katex]b[/katex] is reduced. Our goal is to find the maximum value of [katex]Gain(a,b)[/katex], so that we identify the best pair of vertices to swap. Thus, we have to compute the gain for each vertex pair. Remember, since [katex]a[/katex] is in [katex]A[/katex] and [katex]b[/katex] is in [katex]B[/katex], we only have to compute the gain of [katex]a[/katex] with elements in [katex]B[/katex], and vice versa. The following table shows this computation:</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table class="has-fixed-layout"><tbody><tr><td class="has-text-align-center" data-align="center">Vertex pairs</td><td class="has-text-align-center" data-align="center">[katex]D(a)[/katex]</td><td class="has-text-align-center" data-align="center">[katex]D(b)[/katex]</td><td class="has-text-align-center" data-align="center">[katex]c_{a,b}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]Gain(a,b)[/katex]</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{1,5}[/katex]</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">3</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">3</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{1,6}[/katex]</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">2</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{1,7}[/katex]</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">-1</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">1</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{1,8}[/katex]</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">2</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{2,5}[/katex]</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">3</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">2</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{2,6}[/katex]</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">1</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{2,7}[/katex]</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">-1</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">0</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{2,8}[/katex]</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">1</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{3,5}[/katex]</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">3</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">4</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{3,6}[/katex]</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">1</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{3,7}[/katex]</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">-1</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">-2</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{3,8}[/katex]</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">1</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{4,5}[/katex]</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">3</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">3</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{4,6}[/katex]</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">4</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{4,7}[/katex]</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">-1</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">1</td></tr><tr><td class="has-text-align-center" data-align="center">[katex]{4,8}[/katex]</td><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">0</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>We now pick the value with the highest gain, which is either vertex pair [katex]{3,5}[/katex] or [katex]{4,6}[/katex]. If we have two or more equally good choices, we pick one at random. So let's pick the first pair and swap vertex 3 with vertex 5. Our new updated subsets (sub-graphs) become:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Graph [katex]A[/katex]: Vertices [katex]{1,\,2,\,\mathbf{5},\,4}[/katex]

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Graph [katex]B[/katex]: Vertices [katex]{\mathbf{3},\,6,\,7,\,8}[/katex]

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>The corresponding visual representation is:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"300px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/keringhan_lin_example_first_iteration.png" alt="This figure shows an example graph, where vertices are coloured in two different colours to show the partition they belong to. The result shows an updated distribution after one iteration of the K-L algorithm. " class="wp-image-5550" style="width:300px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We now repeat this algorithm, but we lock down vertices 3 and 5. If we find in the next step that the highest gain involves either vertex 3 or 5, we cannot use it. If we did, we would just undo the work of the previous step, and we would never finish.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this example, we have already found one of the many optimal solutions. Vertex 2 has two external edges, and so we may be tempted to swap it with vertex 8. This would reduce the external edges for vertex 2 to a single external edge, but vertex 5 would also gain a new external edge, so we would not gain a lower number of external edges (and thus, we would still have the same number of communications).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, we have found our optimised graph from an initial partition of two subsets (sub-graphs, sub-domains, etc.). Now, if I left it at this, my inbox will be filled with hate speech of Imperial fanboys and fangirls, and probably rightfully so. Why? Let's look at the computational cost of the Kernighan-Lin algorithm.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When we compute the gain in Eq.(37), we have to evaluate each vertex pair [katex]a[/katex] and [katex]b[/katex]. Let's say we have 1 million cells in our mesh, and we want to split this into 2 sub-domains using the Kernighan-Lin algorithm. Then, we compute the gain for the first vertex (first cell in the mesh) against all 999,999 other vertices (cells) in our graph. Then, we go to the second cell, and we compute its gain with all 999,999 other vertices in the graph.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, for each vertex, we compute the gain with itself and 999,999 other vertices, and we have to do this a total of 1 million times for all cells involved in our mesh. This is pretty expensive (and this is an understatement!). But we are not done yet! All that we have done is swap a single vertex pair based on the best gain value. Once we have done that, we lock these two vertices and then repeat the process until there is no further gain. This expense is ludicrous!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When we want to define the time it takes for an algorithm to run, we use the <a href="https://en.wikipedia.org/wiki/Big_O_notation" target="_blank" rel="noopener" title="">big O notation</a>. It tells us the expense of an algorithm in terms of the number of elements [katex]n[/katex]. In our example, [katex]n[/katex] is the number of cells in our mesh, or vertices in the graph. We don't necessarily count every calculation, but we want to get an estimate for the algorithm's cost as an order of magnitude estimation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In our example, we saw that we have to compute the gain for each cell, and we do that with all cells except itself. We can express this cost as [katex]n\cdot (n-1)[/katex]. However, this is just a single evaluation, and we need to do that for each cell. Thus, we could write the computational cost as [katex](n\cdot(n-1))^2[/katex]. Now, as an order of magnitude, we can say that this is approximately equal to [katex](n\cdot(n-1))^2\approx n^2[/katex], and this is how we compute the cost for the first pass.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Next, we have to repeat this process for as many elements as we have in [katex]n[/katex]. However, since we already found one vertex pair to swap in the previous step, we don't need to consider it in the next step. Thus, each subsequent step in the Kernighan-Lin algorithm reduces in computational cost, which is expressed as [katex]\log(n)[/katex]. Therefore, the overall cost, using the big O notation, is: [katex]\mathcal{O}(n^2 \log(n))[/katex]. This is just ridiculous. Let me show you why.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's compute a few of these values. The following table shows, in the first column, the number of cells we could have in our mesh. These would then also represent the number of vertices in our graph that we want to partition. The second column computes the value for [katex]n^2 \log(n)[/katex]. The third column simply divides the second column by [katex]3\cdot 10^9[/katex], i.e. the number of operations a CPU can perform per second, typically. This assumes that all computation in the Kernighan-Lin algorithm can be performed in one clock cycle (we can't), but as an order of magnitude computation, this will do. In reality, the cost will be slightly higher here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, the third column gives us an idea of how long it would take to partition our graph, and the fourth column just provides the same value but now expressed in days, rather than seconds, to make the numbers easier to interpret.</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table class="has-fixed-layout"><tbody><tr><td class="has-text-align-center" data-align="center"><strong>Number of cells</strong></td><td class="has-text-align-center" data-align="center">[katex]\mathcal{O}(n^2 \log(n))[/katex]</td><td class="has-text-align-center" data-align="center"><strong>Cost in seconds</strong></td><td class="has-text-align-center" data-align="center"><strong>Cost in days</strong></td></tr><tr><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">[katex]0[/katex]</td><td class="has-text-align-center" data-align="center">[katex]0[/katex]</td><td class="has-text-align-center" data-align="center">[katex]0[/katex]</td></tr><tr><td class="has-text-align-center" data-align="center">10</td><td class="has-text-align-center" data-align="center">[katex]1\cdot 10^{2}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]3\cdot 10^{-8}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]4\cdot 10^{-13}[/katex]</td></tr><tr><td class="has-text-align-center" data-align="center">100</td><td class="has-text-align-center" data-align="center">[katex]2\cdot 10^{4}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]7\cdot 10^{-6}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]8\cdot 10^{-11}[/katex]</td></tr><tr><td class="has-text-align-center" data-align="center">1,000</td><td class="has-text-align-center" data-align="center">[katex]3\cdot 10^{6}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]1\cdot 10^{-3}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]1\cdot 10^{-8}[/katex]</td></tr><tr><td class="has-text-align-center" data-align="center">10,000</td><td class="has-text-align-center" data-align="center">[katex]4\cdot 10^{8}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]1\cdot 10^{-1}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]2\cdot 10^{-6}[/katex]</td></tr><tr><td class="has-text-align-center" data-align="center">100,000</td><td class="has-text-align-center" data-align="center">[katex]5\cdot 10^{10}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]2\cdot 10^{1}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]2\cdot 10^{-4}[/katex]</td></tr><tr><td class="has-text-align-center" data-align="center">1,000,000</td><td class="has-text-align-center" data-align="center">[katex]6\cdot 10^{12}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]2\cdot 10^{3}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]2\cdot 10^{-2}[/katex]</td></tr><tr><td class="has-text-align-center" data-align="center">10,000,000</td><td class="has-text-align-center" data-align="center">[katex]7\cdot 10^{14}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]2\cdot 10^{5}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]3[/katex]</td></tr><tr><td class="has-text-align-center" data-align="center">100,000,000</td><td class="has-text-align-center" data-align="center">[katex]8\cdot 10^{16}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]3\cdot 10^{7}[/katex]</td><td class="has-text-align-center" data-align="center">[katex]3\cdot 10^{2}[/katex]</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>We can see that if we have 10 million cells in our mesh, we can expect the Kernighan-Lin algorithm to take 3 days to find us an optimal partition. 10 million cells isn't a lot in CFD terms. If I give an assignment to students, I typically expect them to run simulations with roughly 10 million cells. In their research project, they may go up to 50 million cells, and simulations of my PhD students (and my own simulations) can easily reach 100 million cells.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But that is not the limit; both industry and academia are running simulations with billions of cells, and this is becoming the norm; it is no longer the exception. And so, if I run my simulation with 100 million cells, I don't want to wait 300 days before my Kernighan-Lin algorithm has found an ideal distribution to reduce communication cost; any sub-optimal domain decomposition (yes, even the Imperial College approach) would have been better, and I would have received my results earlier.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>And, keep in mind, that after the Kernighan-Lin algorithm is done, we have only divided the domain into 2 sub-graphs. We need to now repeat the same process for each sub-graph until we have reached the desired number of sub-graphs. No, thank you!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, while conceptually easy to understand, we use the Kernighan-Lin algorithm to explain how graph-partitioning works, but not in CFD codes. However, many other algorithms have been developed that use this algorithm as their baseline, and they simply improve on the bottleneck.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, the Fiduccia–Mattheyses algorithm is essentially an extension of the Kernighan-Lin algorithm, but it is so efficient that it reduces the computational cost from [katex]\mathcal{O}(n^2 \log(n))[/katex] to [katex]\mathcal{O}(E)[/katex], where [katex]E[/katex] is the number of edges. Thus, we have reduced the time complexity from something exponential to something linear, meaning our graph partitioning scales now linearly with our mesh size.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>How does the Fiduccia–Mattheyses algorithm achieve this? Well, in a nutshell, the first problem of the Kernighan-Lin algorithm is that it has to evaluate vertex pairs, which gives it an [katex]n^2[/katex] computational cost. In the Fiduccia–Mattheyses algorithm, we loop over vertices and swap them as we compute their gain. We keep a so-called bucket list that shows us the current highest gain, and we can think of it as a high-score system. Thus, if the current gain is not beating the high score, it may not be optimal to swap.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This reduces the complexity to having to loop over all edges [katex]E[/katex], and since we swap vertices as we visit them, we typically only have to do a few passes, at most, retaining the linear time complexity of [katex]\mathcal{O}(E)[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While this is a huge improvement, we don't stop there. The next thing we introduce are multilevel graph partitioning algorithm. The idea behind these algorithms is to reduce the original graph to a smaller graph. Take the following graph as an example:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/multilevel_graph_partitioning.png" alt="An example of a multilevel graph representation, where several vertices are lumped into a single vertex and all collapsed edges to other vertices are weighted based on the number of edges that were lost in the vertex collapse." class="wp-image-5550" style="width:600px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://www.computer.org/csdl/journal/td/2017/09/07859409/13rRUwhHcQE" target="_blank" rel="noopener" title="">Meyerhenke <em>et al.</em> 2017</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>On the left, we have our original graph. We see that there are only a few edges between each subset, where each vertex in a different subset is given a different colour and pattern. What we do now is to coarsen the graph to only a few vertices, as we see on the right. We don't care about all of the individual vertices in one subset, as these will anyway stay within that subset, but what we do care about is the number of external edges.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When we coarsen our graph, we will lose these external edges, and so what we do is to introduce a weight [katex]w[/katex] for each external edge. The weight represents the number of external edges that are represented by a single edge. We can see in the example below that the external edges on the right account for 1, 2, and 3 external edges that we see on the left, i.e. the original graph.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, when we calculate the gain between vertex pairs, instead of just counting external edges, we need to multiply each external edge by its weight to get the true gain, as each external edge potentially represents a number of external edges. After we have done the partitioning on the coarsened graph, we have to apply that again to the original graph.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We may wish to introduce several levels (i.e. different coarse graphs) and perform this step on each of these subgraphs, which improves the graph partitioning for each level and thus for the original graph, while keeping the computational cost low.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In spirit, this idea is very similar to how multigrids work in CFD applications, where we compute the solution first on a coarse grid with just a few hundred cells. This result will be inaccurate, but if we interpolate that now into a finer grid, we can compute a new solution that is more accurate, and since we have a better initial guess for the solution from the coarse grid, it won't take as long to compute a new solution, and the computational cost is overall reduced.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we now combine the Fiduccia–Mattheyses algorithm, for example, with multilevel graph partitioning algorithms, we can easily partition a mesh with several million cells into as many sub-domains as we want in a matter of seconds. Now that is what I call efficiency.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" id="aioseo-parallelisation-frameworks">Parallelisation frameworks</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Now that we have a good understanding of how parallel computations are enabled by hardware, how we can benchmark and find bottlenecks in parallel code, as well as how to efficiently distribute a computational mesh across several processors (sub-domains), it is time to look at some of the parallelisation frameworks that enable us to do computations in parallel.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this section, we will first look at the differences between shared and distributed memory models, and what that means to our parallelisation effort. Next, we will write a very simple unsteady, 1D heat-diffusion code that we then parallelise using both CPUs and GPUs.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-shared-and-distributed-memory-approaches">Shared and distributed memory approaches</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Whenever we pick a parallelisation strategy, the first question we have to ask ourselves is: "Do we want to use a shared or distributed memory approach"? This must be the first question we ask, because everything else derives from it (i.e. the domain decomposition approach, the parallelisation framework, the types of application we can and can't solve, and the list goes on).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's look at the following schematic to see what their differences are:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"800px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/shared_vs_distributed_memory.png" alt="Schematic view of a CPU with 4 cores, three levels of caches, of which two are local to each processor, and the third one is shared across all processors. All processors have access to the same RAM. On the left, we see an orange box around all processors, memory, and RAM, and the text Shared Memory above it. On the right, we see 4 individual orange boxes around each processor, their caches, and part of the third cache and the RAM. Above it, it says distributed memory. " class="wp-image-5550" style="width:800px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>What I have shown here is an orange box around various parts of the CPU. On the left, the orange box encloses all processors, or cores, including all local and shared caches, as well as the RAM. What this means is that each processor, or core, has access to all memory. Theoretically, it can see what is in the caches of other processors, but as we have discussed above, these caches only help us to bring data to the processor so that access times are accelerated. So, there is no need to access these <em>access accelerators</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Instead, what we mean by shared memory is that each processor has access to the entire RAM and can see what every other processor can see in memory as well, and each processor can access the same memory that any other processor can access as well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Distributed memory, on the other hand, says that each processor is separated from all of the other processors and gets its own private space in RAM. Thus, each processor will only be able to see their own private memory space in RAM, but not that of others. If one processor requires data from another processor's private memory space, it will need to request that, and the other processor needs to send that data.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Think of a simple analogy: If we go to a park, anyone can walk on the grass anywhere without any restrictions. We can access any part of the park by going there. This is like shared memory. Then, we redevelop that part and build houses, and each house gets its own private garden, which is fenced off. We can no longer go everywhere in the park (without trespassing, I suppose). This is our distributed memory model.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you play fetch with your dog in your garden and the ball lands in your neighbour's garden, you will have to request permission to enter their garden (or ask them to get it for you). This is the same as how a processor has to request data from another processor in the distributed memory model.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Earlier, I spent some time preaching that sending and receiving messages is slow, and so we want to avoid communication as much as we can. Now I am saying that shared memory does not have any communications (well, at least not in the sense that memory needs to be requested from other processors, but there are still communications, just substantially fewer). So shared memory is the clear winner here, right? Well, any serious CFD solver that is parallelised uses a distributed memory approach.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The problem with shared memory is that you have access to your RAM, and all processors can use it. This is great if you have a problem that is, say, just about big enough to be solved on 4 cores, and your CPU has 4 cores or more. But, once you start to have bigger and bigger simulations you want to solve, you will need more and more cores. However, with shared memory, the maximum number of cores you can request is the number of cores that have access to your RAM.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On a desktop PC, well, that is your CPU. You cannot put a second PC next to it and then split the work across both PCs, as you would now physically split the RAM. Your shared memory model needs to see all RAM in order to work, and it does not work if it is physically separated across two PCs. It is the same as playing fetch with your dog, except you and your dog are both in different parks.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we want to use more than one CPU and its RAM, we need a distributed memory approach. Think back to the beginning of this article, when we talked about the hardware that goes into an HPC cluster. It is packed with compute nodes, all having their own socket with cores and physically separated RAM. If you want to be able to make use of a supercomputer by using a large number of compute nodes, you need to be able to request data not just within the same CPU/socket, but from CPUs/sockets that are outside your compute node.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This brings us to the following selection criterion:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li><strong>Shared memory</strong>: We use shared memory if we expect our problem size to always fit within a single compute node with shared RAM. On a cluster, we may get as many as 128 cores; on a desktop PC or laptop, we would typically get something between 4 and 32 cores, depending on our CPU. Earlier, we said that 100,000 cells per core is a good rule of thumb for efficient parallelisation, so with 128 cores, we can compute CFD problems with 12.8 million cells efficiently.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Distributed memory</strong>: If we expect our problem size to not fit into a single compute node, or our desktop PC/laptop, then we need a distributed memory approach. If we ever plan to run a case with more than 12.8 million cells, then we likely need a distributed approach. General-purpose CFD solvers do not want to make any assumptions here and assume that you do, indeed, want to use more than a single compute node. For that reason, you will find a distributed memory model common to all major CFD codes.

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>While this selection criterion seems very binary, i.e. it is either one or the other, in reality, mixed approaches are more and more common, known either as Partitioned Global Address Space (PGAS) languages, or MPI-X. We will talk about MPI, the Message Passing Interface, in this section and see that this is the mother of all distributed memory approaches. The X in MPI-X can be any shared memory approach, and so we mix MPI (distributed memory) with some shared memory approach.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While the code does not get substantially more complicated, executing the code does not come without its challenges, and it does require dedicated hardware. You can't run PGAS or MPI-X codes on just your desktop PC or laptop, unless you decide to build your own cluster at home. You need some form of physically separated hardware in order for this approach to really work its magic, meaning you need to have access to some form of compute cluster.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Before we start writing our code to parallelise, I want to quickly introduce two common problems that you will come across in parallelised code that are sometimes difficult to spot, and so they will make your life a lot more difficult trying to track down bugs. These bugs only exist in the parallel code and not in the non-parallel (sequential) code.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-race-conditions">Race conditions</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>When I went to high school, a popular summer activity was to meet in the park to have a BBQ. Believe it or not, we were not the only ones thinking of meeting in the park for a BBQ, and despite its size, spanning several football/soccer pitches, finding an empty spot where you would not sit shoulder to shoulder with other groups was difficult. So, you had to be early to reserve your seat.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But then again, I grew up in Germany, and if there is one thing Germans are good at, it is arriving early to reserve your seat, which many tourists in hotels will have found out the hard way. And, in case you have never had the pleasure to observe the Germans in the wild, here you go, the sun-lounger Olympics in Rio:</p>
<!-- /wp:paragraph -->

<!-- wp:embed {"url":"https://youtu.be/CZ9L8KAjPA8?si=0rS6qhSsZ7h1tXXl","type":"video","providerNameSlug":"youtube","responsive":true,"className":"wp-embed-aspect-16-9 wp-has-aspect-ratio"} -->
<figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
https://youtu.be/CZ9L8KAjPA8?si=0rS6qhSsZ7h1tXXl
</div></figure>
<!-- /wp:embed -->

<!-- wp:paragraph -->
<p>What an absolute car crash. Anyhow. If I wanted to meet with my friends at a specific location, we had no idea if that particular spot would already be occupied or not. If we all agreed to meet at that point, only to find out that it was already occupied when we arrived, we had no way of finding each other (mobile phones were not common yet).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is a race condition, because there is a race to a particular location, and whoever comes first will get the spot and can do their BBQ there; everyone else can go back home (or, well, go somewhere else). But perhaps the next day, when we decide to meet at exactly the same place, we may end up being the first to arrive, and so we get our spot. There is no way of knowing in advance who will arrive first, and so, sometimes we get lucky, and we get our spot to do a BBQ, and sometimes we don't.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, let's translate that to parallel computing. A race condition is defined as two or more processors trying to access a particular memory location, potentially overwriting the value. So, you may have processors 1 and 2 trying to access memory location X. Both processors 1 and 2 expect the value stored at X to be, say, 10. Then, processor 1 gets there first and updates the value. Now, processor 2 gets there and instead of getting the value 10, it may get the value 20, which it does not expect, and so its computations will be wrong.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If, however, processor 2 got their first, which only wanted to read the value but not update it, it could do that, get the value for X, which should still be 10 if it got their first, and then afterwards, processor 1 could access the value and overwrite it. Depending on which processor comes first, we may get a different outcome, and this is, as already mentioned, a race condition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Don't worry, once you start programming in parallel, you will produce many race conditions; you can't avoid them. If you are <a href="https://www.versantus.co.uk/blog/vibe-coding-promise-and-pitfalls" target="_blank" rel="noopener" title="">vibe coding</a>, then expect lots of race conditions that ChatGPT can't save you from; LLMs are especially weak when it comes to parallelising code.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What is important is that you recognise when a race condition occurs so that you can check your memory access in your code. If you run your code on a single core and everything works fine, but results either sometimes work or you get wrong results with your parallel code, then you may have a race condition. At this point, you want to check how memory is being accessed or sent and received.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4 class="wp-block-heading" id="aioseo-deadlocks">Deadlocks</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Deadlocks are another common pitfall. Imagine you work in a group with others at work, and there is one particular step you have to do before you can start working on your project. For example, you may be tasked with simulating the flow over a particular geometry, meaning the first step in this process is to obtain the geometry. You task <em>the new guy</em> at work to obtain the geometry, and until you get your hands on the geometry, you cannot do anything productive.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It turns out that <em>the new guy</em> was in reality an intern, who had their first day at the company. On the same day, the intern was caught embezzling company property, and so the intern was fired on the spot. No one told you and your group, and so you are still waiting for the intern to come back with the geometry, which will never happen. This is a deadlock.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In the world of computing, a deadlock happens when one processor gets stuck in one task, typically in a loop that never finishes, i.e. we have an infinite loop. So, now one processor is trapped inside an infinite loop while all the other processors eventually come to a standstill because they need to get some data from that processor. But, because the processor is stuck in the loop, it cannot work on any data requests, just like all of your angry emails to the intern go unanswered, as the intern has lost access to their emails.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>A deadlock is easy to spot in that your code eventually stops and does not advance through the program anymore. Using <a href="https://a64.in/posts/caveman-debugging-using-live-templates/" target="_blank" rel="noopener" title="">caveman debugging</a> principles, we can place a few print statements here and there in our code to figure out the exact location that produces the deadlock (i.e. we look at the lines of code between the last print statement that was executed and the next print statement that wasn't).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Between these two print statements, something went wrong, and we can insert more and more print statements to narrow down the part of the code where the deadlock is coming from. It does not always have to be an infinite loop; there are other ways of producing a deadlock, so we don't necessarily always just look for loops.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, if every processor is sending data and waiting for a response from the processor it is sending data to, before going to the next step (which is receiving the data), no processor is actually in receiving mode, and so all processors will be stuck at the sending stage. This is a common deadlock new programmers will make in parallel computing, and we will look at this particular issue later in greater detail when dealing with MPI (where it most commonly occurs).</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-a-sequential-example-code">A sequential example code</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p><strong>All source code that is discussed in the following sections can be downloaded using the link provided at the beginning of the article</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ok, we need to establish a baseline, and so we will develop a simple CFD solver that will solve the heat diffusion equation as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial T}{\partial t} = \alpha\frac{\partial^2 T}{\partial x^2}
\tag{38}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>I will just use a simple <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-discretise-the-navier-stokes-equations/#aioseo-the-finite-difference-method-fdm" target="_blank" rel="noopener" title="">finite difference</a> approximation here, with an <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/explicit-vs-implicit-time-integration-and-the-cfl-condition/#aioseo-a-graphical-representation-of-explicit-and-implicit-methods" target="_blank" rel="noopener" title="">explicit time integration</a>, as this will make the discretisation very straightforward. Let's discretise each term together. For the time derivative, we use a <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-discretise-the-navier-stokes-equations/#aioseo-approximating-first-order-derivatives" target="_blank" rel="noopener" title="">first-order</a> approximation in time:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial T}{\partial t} \approx \frac{T_i^{n+1} - T_i^n}{\Delta t}
\tag{39}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>To approximate the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/how-to-discretise-the-navier-stokes-equations/#aioseo-approximating-second-order-derivatives" target="_blank" rel="noopener" title="">second-order derivative</a> on the right-hand side, we use a second-order central scheme as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{\partial^2 T}{\partial x^2} \approx \frac{T_{i+1}^n - 2T_i^n + T_{n-1}^n}{(\Delta x)^2}
\tag{40}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Inserting Eq.(39) and Eq.(40) into Eq.(38), we obtain the following discretised equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\frac{T_i^{n+1} - T_i^n}{\Delta t} = \alpha\frac{T_{i+1}^n - 2T_i^n + T_{n-1}^n}{(\Delta x)^2}
\tag{41}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>The index [katex]i[/katex] runs over our one-dimensional space direction, i.e. the [katex]x[/katex] direction, while the index [katex]n[/katex] indicates the time-level. When we start our simulation, at [katex]t=0[/katex], we start at time level [katex]n=0[/katex]. At this time level, we have to specify some initial solution for all values of [katex]T_i^n[/katex]. For example, we can just set everything to zero. If we do that, then all values of [katex]T_i^n[/katex] are known, and so we can put them on the right-hand side of Eq.(41). Multiplying by [katex]\Delta t[/katex] as well, results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
T_i^{n+1} = T_i^n + \Delta t \alpha\frac{T_{i+1}^n - 2T_i^n + T_{n-1}^n}{(\Delta x)^2}
\tag{42}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We can now further simplify the right-hand side by taking [katex](\Delta x)^2[/katex] outside the fraction, which produces the following equation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
T_i^{n+1} = T_i^n + \frac{\Delta t \alpha}{(\Delta x)^2}\left[T_{i+1}^n - 2T_i^n + T_{n-1}^n\right] \\[1em]
T_i^{n+1} = T_i^n + CFL\cdot\left[T_{i+1}^n - 2T_i^n + T_{n-1}^n\right]
\tag{43}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, I have introduced [katex]CFL=\alpha\Delta t/(\Delta x)^2[/katex] as the viscous CFL number. We usually only think of the inviscid CFL number when we talk about <em>the CFL number</em>, but in reality, we have both a viscous and inviscid definition; it's just that the inviscid CFL number usually dominates. Just for clarity, when I talk about the inviscid CFL number, I mean the following:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
CFL=u\frac{\Delta t}{\Delta x}
\tag{44}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]u[/katex] is some characteristic velocity (the velocity magnitude for incompressible flows, the speed of sound for compressible flows), and [katex]\Delta t[/katex] and [katex]\Delta x[/katex] are defined in the same way as above, i.e. they represent our step size in the [katex]x[/katex] and [katex]t[/katex] direction.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you use the Euler equation (where the viscosity is zero), then, of course, there is no viscous CFL number, and you only have the inviscid CFL number, i.e. Eq.(44).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In our case, since we use an explicit time integration, which provides us with a quick way of discretising our equation, we are limited in the time step size we can choose. For diffusion-dominated problems, the <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/explicit-vs-implicit-time-integration-and-the-cfl-condition/#aioseo-example-diffusion-equation" target="_blank" rel="noopener" title="">highest CFL number we can use is [katex]CFL_{\max}=0.5[/katex]</a>. This means that we have to compute our time step as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
CFL=\frac{\alpha \Delta t}{(\Delta x)^2} \\[1em]
\Delta t \le \frac{CFL_{\max}(\Delta x)^2}{\alpha}\tag{45}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>It's usually a good idea not to go all the way to [katex]CFL_{\max}[/katex], and so for all calculations that follow, I have set [katex]CFL=0.25[/katex]. In this way, we always compute a stable timestep based on our grid size and heat diffusion coefficient.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With this established, we need to write the code to solve this equation. The code is given below. Read through it and see if you can make sense of it. If you don't read through the code, you won't be able to understand the remaining sections on the various other parallelisation strategies. The code is written in C++ but does not use any object-oriented programming techniques to keep complexity to a minimum. Additional pointers are given below the code.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#include \u0026lt;iostream\u003e\n#include \u0026lt;vector\u003e\n#include \u0026lt;chrono\u003e\n#include \u0026lt;fstream\u003e\n#include \u0026lt;string\u003e\n\nint main(int argc, char* argv[]) {\n    // input parameters\n    const int numberOfPoints = static_cast\u0026lt;int\u003e(atoi(argv[1]));\n    const double leftBoundary = 0.0;\n    const double rightBoundary = 1.0;\n    const double CFL = 0.25;\n    const double heatDiffusionCoefficient = 0.01;\n    const double finalTime = static_cast\u0026lt;double\u003e(atof(argv[2]));\n    \n    // computed input paramters\n    const double dx = 1.0 / (numberOfPoints - 1);\n    const double dt = CFL * dx * dx / heatDiffusionCoefficient;\n    const int numberOfTimeSteps = static_cast\u0026lt;int\u003e(finalTime / dt);\n\n    // allocate memory for field arrays\n    std::vector\u0026lt;double\u003e T0(numberOfPoints); // T at time n\n    std::vector\u0026lt;double\u003e T1(numberOfPoints); // T at time n+1\n    std::vector\u0026lt;double\u003e x(numberOfPoints);\n\n    // create mesh\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        x[i] = dx * i;\n    }\n\n    // initialise field arrays\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        T0[i] = 0.0;\n        T1[i] = 0.0;\n    }\n\n    // set boundary conditions (important, set it for T1, not T0)\n    T1[0] = leftBoundary;\n    T1[numberOfPoints - 1] = rightBoundary;\n\n    auto startTime = std::chrono::high_resolution_clock::now();\n    // loop over all timesteps\n    for (int t = 0; t \u0026lt; numberOfTimeSteps; ++t) {\n        T0 = T1;\n\n        // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\n        for (int i = 1; i \u0026lt; numberOfPoints - 1; ++i) {\n            T1[i] = T0[i] + heatDiffusionCoefficient * dt / (dx * dx) * (T0[i + 1] - 2 * T0[i] + T0[i - 1]);\n        }\n    }\n    auto endTime = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u003e(endTime - startTime);\n    std::cout \u0026lt;\u0026lt; \u0022Executation time: \u0022 \u0026lt;\u0026lt; static_cast\u0026lt;double\u003e(duration.count()) / 1000 \u0026lt;\u0026lt; \u0022 seconds\u0022 \u0026lt;\u0026lt; std::endl;\n    \n    // compute error\n    double error = 0.0;\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        error += std::abs(T1[i] - x[i]);\n    }\n    error /= numberOfPoints;\n    std::cout \u0026lt;\u0026lt; \u0022Error: \u0022 \u0026lt;\u0026lt; error \u0026lt;\u0026lt; std::endl;\n\n    // output results\n    auto finalTimeString = std::to_string(finalTime);\n    finalTimeString = finalTimeString.substr(0, finalTimeString.find(\u0022.\u0022));\n    std::string fileName = \u0022results_sequential_\u0022 + finalTimeString + \u0022.csv\u0022;\n    std::ofstream file(fileName);\n    file \u0026lt;\u0026lt; \u0022x,T\u0022 \u0026lt;\u0026lt; std::endl;\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        file \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0022, \u0022 \u0026lt;\u0026lt; T1[i] \u0026lt;\u0026lt; std::endl;\n    }\n    file.close();\n\n    return 0;\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;chrono\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;fstream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emain\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargc\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar*\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[]) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // input parameters\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfPoints = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eatoi\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e leftBoundary = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e rightBoundary = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e CFL = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.25\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e heatDiffusionCoefficient = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.01\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e finalTime = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eatof\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // computed input paramters\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e dx = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e / (numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e dt = CFL * dx * dx / heatDiffusionCoefficient;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfTimeSteps = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(finalTime / dt);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // allocate memory for field arrays\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e // T at time n\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e // T at time n+1\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // create mesh\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = dx * i;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // initialise field arrays\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // set boundary conditions (important, set it for T1, not T0)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; = leftBoundary;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; = rightBoundary;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e startTime = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ehigh_resolution_clock\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003enow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // loop over all timesteps\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e t = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; t \u0026lt; numberOfTimeSteps; ++t) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        T0 = T1;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + heatDiffusionCoefficient * dt / (dx * dx) * (\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e endTime = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ehigh_resolution_clock\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003enow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e duration = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eduration_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003emilliseconds\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(endTime - startTime);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Executation time: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eduration\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecount\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e()) / \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1000\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot; seconds\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // compute error\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e error = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        error += \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eabs\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    error /= numberOfPoints;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Error: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; error \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // output results\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e finalTimeString = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eto_string\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(finalTime);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    finalTimeString = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efinalTimeString\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esubstr\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efinalTimeString\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::string fileName = \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;results_sequential_\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + finalTimeString + \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.csv\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::ofstream \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efile\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(fileName);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    file \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;x,T\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        file \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;, \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efile\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eclose\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":75,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>#include &lt;iostream>
#include &lt;vector>
#include &lt;chrono>
#include &lt;fstream>
#include &lt;string>

int main(int argc, char* argv[]) {
    // input parameters
    const int numberOfPoints = static_cast&lt;int>(atoi(argv&#91;1&#93;));
    const double leftBoundary = 0.0;
    const double rightBoundary = 1.0;
    const double CFL = 0.25;
    const double heatDiffusionCoefficient = 0.01;
    const double finalTime = static_cast&lt;double>(atof(argv&#91;2&#93;));
    
    // computed input paramters
    const double dx = 1.0 / (numberOfPoints - 1);
    const double dt = CFL * dx * dx / heatDiffusionCoefficient;
    const int numberOfTimeSteps = static_cast&lt;int>(finalTime / dt);

    // allocate memory for field arrays
    std::vector&lt;double> T0(numberOfPoints); // T at time n
    std::vector&lt;double> T1(numberOfPoints); // T at time n+1
    std::vector&lt;double> x(numberOfPoints);

    // create mesh
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        x&#91;i&#93; = dx * i;
    }

    // initialise field arrays
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        T0&#91;i&#93; = 0.0;
        T1&#91;i&#93; = 0.0;
    }

    // set boundary conditions (important, set it for T1, not T0)
    T1&#91;0&#93; = leftBoundary;
    T1&#91;numberOfPoints - 1&#93; = rightBoundary;

    auto startTime = std::chrono::high_resolution_clock::now();
    // loop over all timesteps
    for (int t = 0; t &lt; numberOfTimeSteps; ++t) {
        T0 = T1;

        // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space
        for (int i = 1; i &lt; numberOfPoints - 1; ++i) {
            T1&#91;i&#93; = T0&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (T0&#91;i + 1&#93; - 2 * T0&#91;i&#93; + T0&#91;i - 1&#93;);
        }
    }
    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds>(endTime - startTime);
    std::cout &lt;&lt; "Executation time: " &lt;&lt; static_cast&lt;double>(duration.count()) / 1000 &lt;&lt; " seconds" &lt;&lt; std::endl;
    
    // compute error
    double error = 0.0;
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        error += std::abs(T1&#91;i&#93; - x&#91;i&#93;);
    }
    error /= numberOfPoints;
    std::cout &lt;&lt; "Error: " &lt;&lt; error &lt;&lt; std::endl;

    // output results
    auto finalTimeString = std::to_string(finalTime);
    finalTimeString = finalTimeString.substr(0, finalTimeString.find("."));
    std::string fileName = "results_sequential_" + finalTimeString + ".csv";
    std::ofstream file(fileName);
    file &lt;&lt; "x,T" &lt;&lt; std::endl;
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        file &lt;&lt; x&#91;i&#93; &lt;&lt; ", " &lt;&lt; T1&#91;i&#93; &lt;&lt; std::endl;
    }
    file.close();

    return 0;
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;iostream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;vector&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;chrono&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;fstream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;string&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">main</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">argc</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">char*</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">[]) {</span></span>
<span class="line"><span style="color: #6A9955">    // input parameters</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfPoints = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #DCDCAA">atoi</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> leftBoundary = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> rightBoundary = </span><span style="color: #B5CEA8">1.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> CFL = </span><span style="color: #B5CEA8">0.25</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> heatDiffusionCoefficient = </span><span style="color: #B5CEA8">0.01</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> finalTime = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #DCDCAA">atof</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4">&#93;));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // computed input paramters</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> dx = </span><span style="color: #B5CEA8">1.0</span><span style="color: #D4D4D4"> / (numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> dt = CFL * dx * dx / heatDiffusionCoefficient;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfTimeSteps = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;(finalTime / dt);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // allocate memory for field arrays</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">T0</span><span style="color: #D4D4D4">(numberOfPoints);</span><span style="color: #6A9955"> // T at time n</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">T1</span><span style="color: #D4D4D4">(numberOfPoints);</span><span style="color: #6A9955"> // T at time n+1</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">x</span><span style="color: #D4D4D4">(numberOfPoints);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // create mesh</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93; = dx * i;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // initialise field arrays</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // set boundary conditions (important, set it for T1, not T0)</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93; = leftBoundary;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; = rightBoundary;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> startTime = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">high_resolution_clock</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">now</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #6A9955">    // loop over all timesteps</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> t = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; t &lt; numberOfTimeSteps; ++t) {</span></span>
<span class="line"><span style="color: #D4D4D4">        T0 = T1;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">        // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; i &lt; numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; - </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> endTime = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">high_resolution_clock</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">now</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> duration = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">duration_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">milliseconds</span><span style="color: #D4D4D4">&gt;(endTime - startTime);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Executation time: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #9CDCFE">duration</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">count</span><span style="color: #D4D4D4">()) / </span><span style="color: #B5CEA8">1000</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #CE9178">&quot; seconds&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // compute error</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> error = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        error += </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">abs</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; - </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    error /= numberOfPoints;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Error: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; error &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // output results</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> finalTimeString = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">to_string</span><span style="color: #D4D4D4">(finalTime);</span></span>
<span class="line"><span style="color: #D4D4D4">    finalTimeString = </span><span style="color: #9CDCFE">finalTimeString</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">substr</span><span style="color: #D4D4D4">(</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #9CDCFE">finalTimeString</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(</span><span style="color: #CE9178">&quot;.&quot;</span><span style="color: #D4D4D4">));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::string fileName = </span><span style="color: #CE9178">&quot;results_sequential_&quot;</span><span style="color: #D4D4D4"> + finalTimeString + </span><span style="color: #CE9178">&quot;.csv&quot;</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::ofstream </span><span style="color: #DCDCAA">file</span><span style="color: #D4D4D4">(fileName);</span></span>
<span class="line"><span style="color: #D4D4D4">    file &lt;&lt; </span><span style="color: #CE9178">&quot;x,T&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        file &lt;&lt; </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93; &lt;&lt; </span><span style="color: #CE9178">&quot;, &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">file</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">close</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>If any of the above wasn't clear, then here are some additional explanations for each code block section:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

    <!-- wp:list -->
<li><strong>Lines 1-5</strong>: We include some standard C++ header files here to do the following:
<ul class="wp-block-list"><!-- wp:list-item -->
<li><code>&lt;iostream&gt;</code>: Print information to the screen/console.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><code>&lt;vector&gt;</code>: Used for creating an array with data stored on the heap (i.e. in RAM). This allows us to create large arrays, and we don't have to know the size of the arrays at compile time, only at runtime.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><code>&lt;chrono&gt;</code>: Used for timing our code, so that we can compare performance between different parallelisation strategies.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><code>&lt;fstream&gt;</code>: Used to output the results to a <code>*.csv</code> file after the simulation is done.</li>
<!-- /wp:list-item -->

<!-- wp:list-item -->
<li><code>&lt;string&gt;</code>: Using 21st century technology to work with characters/strings, not the default <code>char</code> variable type</li>
<!-- /wp:list-item --></ul>
<!-- /wp:list --></li>

<!-- wp:list-item -->
<li><strong>Line 7</strong>: Defining the <code>main()</code> function and accepting command line arguments. We will use these command-line arguments to set the number of vertices in space and the end time. Thus, we can run different experiments without having to recompile the code.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 9-14</strong>: We set the default input parameter that will be used to set up our simulation. Note that the <code>numberOfPoints</code> and <code>finalTime</code> variables are set from the command line argument vector <code>argv</code>. The first entry in this vector, i.e. <code>argv[0]</code>, is the executable file name. <code>argv[1]</code> is the first command line argument, and <code>argv[2]</code> the second. If we do not provide any command-line arguments, the code will not execute. The function <code>atoi()</code> means character (a) to int. Command line arguments are always interpreted as characters, and so need to be converted to either an int (<code>atoi</code>) or a float (<code>atof</code>) before we can assign them to a variable that holds a number in C++.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 17-19</strong>: These are computed input parameters. The spacing is based on the number of points, and our domain is always 1 unit of length. As a minimum, we need 2 points in our domain (left and right boundary vertices). If we only have 2 points on each boundary, then the length from the left to the right boundary must be the same as the length of the domain. Thus, we need to subtract 1 from the <code>numberOfPoints</code> variable to get the correct spacing on line 17. This is known as the fencepost, or <a href="https://en.wikipedia.org/wiki/Off-by-one_error" target="_blank" rel="noopener" title="">off-by-one</a> error. To compute the number of time steps required to get to the final time, we divide the final time by the time step size <code>dt</code>. This may produce a floating point number, and so we force it to be an <code>int</code> by using the <code>static_cast<int></code> method, which will look at the result and round it down to the closest integer. For example, <code>static_cast<int>(4.9)=4</code>, so we don't round to the closest integer, we always round down to the closest integer.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 22-24</strong>: Here we allocate memory for our temperature arrays at time level [katex]n[/katex] (<code>T0</code>) and time level [katex]n+1[/katex] (<code>T1</code>), as well as for our coordinate array <code>x</code>.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 27-29</strong>: We create the mesh, which, for a 1D domain is very straightforward. We start at 0 and go all the way to 1. Multiplying the loop variable [katex]i[/katex] by the spacing [katex]dx[/katex] will create an array going from 0 to 1 (the length of the domain) in increments of [katex]dx[/katex] using <code>numberOfPoints</code> which we specified as a command line argument.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 32-35</strong>: Here we initialise the temperature array and ensure that the values everywhere are 0. This ensures that at the first time step, i.e. at [katex]t=0[/katex] and [katex]n=0[/katex], we have values for [katex]T^n[/katex] at each point [katex]i[/katex].

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 38-39</strong>: We set the boundary conditions. We set the left boundary at [katex]x=0[/katex] to [katex]T(0,t)=0[/katex] and the right boundary at [katex]x=1[/katex] to [katex]T(1,t)=1[/katex]. In other words, we essentially have set the boundary condition to be [katex]T(x,t)=x[/katex], i.e. the value of [katex]x[/katex] is the value we set in our temperature array. We will see later why this is advantageous. To see why it is important that we set <code>T1</code> and not <code>T0</code> here, see the explanation given for lines 43-50.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 41</strong>: We get the current timestamp. Then, on lines 51-53, after the computation is done, we get another time stamp and can compute the difference between the two. The difference will give us the total time it took to compute the solution. Note how we only time the time it takes to do the computation, not anything before than related to the setup/memory allocation/initialisation, etc., as the computation is usually the most time-intensive part.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 43-50</strong>: This is the time loop going over as many timesteps as we need to reach the final time (as computed on line 19). At the beginning of each time step, we set [katex]T<sup>n=T</sup>{n+1}[/katex]. We do that because at the beginning of each time step, we should have the latest solution available in [katex]T^{n+1}[/katex], or <code>T1</code>. Now we are going to the next time step, and so the previously computed solution at [katex]n+1[/katex] now becomes the available solution at [katex]n[/katex]. The first time we run the loop, i.e. when we have <code>t=0</code>, there is no solution from the previous time step, but we have to initialise the temperature array beforehand. Thus, it was important on lines 38-39 to set the boundary conditions for <code>T1</code>, as we are now copying these into <code>T0</code>. If we had set the boundary condition for <code>T0</code> instead on lines 38-39 and not for <code>T1</code>, we would lose them when line 44 is run for the first time. What we could then do is set the boundary conditions for <code>T0</code> every time step.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 47-49</strong> now compute an updated solution for [katex]T^{n+1}[/katex], or <code>T1</code>, by solving Eq.(43), and we loop over all points except the first and last in our temperature array, which are our boundary points. Furthermore, since we retrieve temperature values at <code>i+1</code> and <code>i-1</code>, we can't loop all the way to the first and last point, as we would now be trying to access memory that is beyond the allocated memory for our temperature array.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 56-61</strong>: Here, we compute the error. There is an analytic function available to compute the exact error for any point in time [katex]t[/katex], however, we can exploit the fact that the solution of the heat diffusion equation is essentially a linear blend between its boundary conditions. I said earlier that we set the temperature values at the left and right boundaries to the same value as the coordinate array [katex]x[/katex]. This means, once the solution has reached a fully developed state, the values of [katex]T[/katex] and [katex]x[/katex] will be the same, and so we would expect [katex]T=x[/katex] to be true. This is, however, only true if the solution has fully converged, and if we truncate the simulation before that, the error will be meaningless. However, we can later compare that we do get the same error value across different parallelisation approaches, which would indicate that the parallelisation itself has not introduced any alterations to the solution, which is a handy check.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 64-72</strong>: Here we simply output the solution to a <code>*.csv</code> file which can be easily processed by any plotting tool to look at the results visually. Later on, I will show results for all parallelisation approaches, and we will see that, indeed, [katex]T=x[/katex] is the case once the solution has converged to a steady-state solution.

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Hopefully, the code does make sense now with these additional pointers. To make our life easy, I will be using CMake to compile the code. For the sequential code above, it is probably not too difficult to compile everything manually, but once we have to bring in dependencies for our parallelisation frameworks, we'll see that CMake provides us with a clean and very easy-to-use interface.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To be honest, on UNIX operating systems, manual compilation, where we have to resolve dependencies ourselves, isn't that bad, but Windows, as always, is another matter. So why not embrace a cross-platform approach and never have to worry about <em>will my code compile on Windows, Linux, macOS, and my smart fridge?</em>. If you have never used CMake but are willing to give it a try, I have an entire series about it, which you can find here: <a href="https://cfd.university/learn/automating-cfd-solver-and-library-compilation-using-cmake/" target="_blank" rel="noopener" title="">Automating CFD solver and library compilation using CMake</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you want to have the quick introduction, <a href="https://cfd.university/learn/automating-cfd-solver-and-library-compilation-using-cmake/introduction-to-cmake-for-cfd-practitioners/#aioseo-cmake-in-action" target="_blank" rel="noopener" title="">start here</a>. In any case, the CMake file I'll be using is given below:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"cmake_minimum_required(VERSION 3.10)\n\nproject(parallelisationDemonstration\n  LANGUAGES CXX\n  VERSION 1.0.0\n  DESCRIPTION \u0022A project to demonstrate parallelisation in C++\u0022\n)\n\n# \u002d\u002d- Sequential code \u002d\u002d-\nadd_executable(heat1Dsequential \u0022src/heat1Dsequential.cpp\u0022)","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003ecmake_minimum_required\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(VERSION 3.10)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eproject\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(parallelisationDemonstration\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  LANGUAGES CXX\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  VERSION 1.0.0\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  DESCRIPTION \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;A project to demonstrate parallelisation in C++\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# \u002d\u002d- Sequential code \u002d\u002d-\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eadd_executable\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(heat1Dsequential \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;src/heat1Dsequential.cpp\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cmake","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":10,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>cmake_minimum_required(VERSION 3.10)

project(parallelisationDemonstration
  LANGUAGES CXX
  VERSION 1.0.0
  DESCRIPTION "A project to demonstrate parallelisation in C++"
)

# --- Sequential code ---
add_executable(heat1Dsequential "src/heat1Dsequential.cpp")</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #569CD6">cmake_minimum_required</span><span style="color: #D4D4D4">(VERSION 3.10)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">project</span><span style="color: #D4D4D4">(parallelisationDemonstration</span></span>
<span class="line"><span style="color: #D4D4D4">  LANGUAGES CXX</span></span>
<span class="line"><span style="color: #D4D4D4">  VERSION 1.0.0</span></span>
<span class="line"><span style="color: #D4D4D4">  DESCRIPTION </span><span style="color: #CE9178">&quot;A project to demonstrate parallelisation in C++&quot;</span></span>
<span class="line"><span style="color: #D4D4D4">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955"># --- Sequential code ---</span></span>
<span class="line"><span style="color: #569CD6">add_executable</span><span style="color: #D4D4D4">(heat1Dsequential </span><span style="color: #CE9178">&quot;src/heat1Dsequential.cpp&quot;</span><span style="color: #D4D4D4">)</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>As per CMake requirements, we specify the minimum CMake version that is required. I put 3.10 here; it doesn't really matter, as we won't be using any advanced CMake features here. Anything above CMake version 3.0 will do. Given that this version was released in November of 2018, you should probably be able to get a CMake version that is at least 3.10.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Next, we define our project and tell CMake that this is a C++ project (<code>LANGUAGE CXX</code>). The remaining metadata is optional but good practice. On line 10, we add an executable target, where we say that the executable <code>heat1Dsequential</code> depends on a single source file, which can be found in <code>"src/heat1Dsequential.cpp"</code>. This is the file we saw above.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This should be our project structure now:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"root\n├── build\n├── src/\n│   └── heat1Dsequential.cpp\n└── CMakeLists.txt","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eroot\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e├── build\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e├── src/\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e│   └── heat1Dsequential.cpp\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e└── CMakeLists.txt\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"plaintext","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":5,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>root
├── build
├── src/
│   └── heat1Dsequential.cpp
└── CMakeLists.txt</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #D4D4D4">root</span></span>
<span class="line"><span style="color: #D4D4D4">├── build</span></span>
<span class="line"><span style="color: #D4D4D4">├── src/</span></span>
<span class="line"><span style="color: #D4D4D4">│   └── heat1Dsequential.cpp</span></span>
<span class="line"><span style="color: #D4D4D4">└── CMakeLists.txt</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>The <code>CMakeLists.txt</code> file contains the CMake content we discussed above, and we have to create the <code>build</code> folder for CMake to support its <a href="https://johnfarrier.com/in-source-vs-out-of-source-builds/" target="_blank" rel="noopener" title="">out-of-source build philosophy</a>. If you have the same structure now, you can compile this code from your terminal using the following instructions (you have to be within the <code>build</code> folder for this to work):</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"cmake -DCMAKE_BUILD_TYPE=Release ..","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecmake\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-DCMAKE_BUILD_TYPE=Release\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e..\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>cmake -DCMAKE_BUILD_TYPE=Release ..</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">cmake</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-DCMAKE_BUILD_TYPE=Release</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">..</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"cmake \u002d\u002dbuild . \u002d\u002dconfig Release","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecmake\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u002d\u002dbuild\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u002d\u002dconfig\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003eRelease\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>cmake --build . --config Release</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">cmake</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">--build</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">.</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">--config</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">Release</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Depending on your build environment, you will now have an executable in your <code>build/</code> or <code>build/Release</code> directory. You can execute this file now by providing some command-line arguments. On Windows, you may write:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":".\\Release\\heat1Dsequential.exe 101 100","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\\Release\\heat1Dsequential.exe \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e101\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>.\Release\heat1Dsequential.exe 101 100</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">.</span><span style="color: #D4D4D4">\Release\heat1Dsequential.exe </span><span style="color: #B5CEA8">101</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">100</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>On UNIX, you may write something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"./Release/heat1Dsequential 101 100","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003e./Release/heat1Dsequential\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e101\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>./Release/heat1Dsequential 101 100</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">./Release/heat1Dsequential</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">101</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">100</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>If the executable is not located in the <code>Release</code> folder, you can remove this from your command to execute the sequential code. Great, if you followed along and executed the code, you should see that you get a pretty quick execution (of the order of milliseconds) and the error is also not too bad (of the order of 1e-5). So, the code seems to work, and we will later verify this also visually when we compare all parallelisation approaches.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Hopefully, this all made sense up until now. If it does, then we are ready to look at our first parallelisation strategy: OpenMP.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-openmp">OpenMP</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>OpenMP is a <strong>shared memory</strong> approach. As we have discussed before, this means we can only use as many cores as we have available in our PC/laptop, or as many cores as are connected to the same RAM. However, as you will see, we have to do very minor changes to our code (in comparison to other parallelisation approaches, that is).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is the core design principle behind OpenMP. The idea is that you profile your code (meaning, you time each section of your code and see how much time you spend in each) and then identify computational hotspots. In our example, we already know that the temperature update is going to be the only place where we do a lot of computation, so we don't have to profile the code in advance.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But, assuming we have done that for a more complex code, we can then identify areas that would most benefit from some parallelisation. We then add the parallelisation only to this part and hope that the overall computational cost will reduce.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you think back to Amdahl's law, which we discussed at the beginning of this article, then we said that we really need to parallelise as much as possible to stand even the tiniest chance of getting good performance beyond just a few processors. However, with OpenMP, we are restricted in the number of processors since we use a shared memory approach, so we are a bit relaxed here and don't necessarily need to parallelise everything, just the compute-intensive tasks.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For this reason, you will also sometimes hear people refer to OpenMP (and other, similar shared memory parallelisation frameworks) as loop-based parallelisation, as we typically parallelise compute-intensive loops with this approach. The idea is that if I have to run a loop over 1000 elements and I have 10 processors available, then each processor needs to only compute 100 elements, and so, hopefully, we get a 10 times boost in computational speed.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Though, as we have also discussed, setting up these different parallel regions will take some time, and so the speed-up will be lower than the theoretical maximum (10 in this example).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's see OpenMP in action. In the sequential code example, we saw that the time loop is given as:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"for (int t = 0; t \u0026lt; numberOfTimeSteps; ++t) {\n  T0 = T1;\n\n  // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\n  for (int i = 1; i \u0026lt; numberOfPoints - 1; ++i) {\n      T1[i] = T0[i] + heatDiffusionCoefficient * dt / (dx * dx) * (T0[i + 1] - 2 * T0[i] + T0[i - 1]);\n  }\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e t = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; t \u0026lt; numberOfTimeSteps; ++t) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  T0 = T1;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + heatDiffusionCoefficient * dt / (dx * dx) * (\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":8,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>for (int t = 0; t &lt; numberOfTimeSteps; ++t) {
  T0 = T1;

  // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space
  for (int i = 1; i &lt; numberOfPoints - 1; ++i) {
      T1&#91;i&#93; = T0&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (T0&#91;i + 1&#93; - 2 * T0&#91;i&#93; + T0&#91;i - 1&#93;);
  }
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> t = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; t &lt; numberOfTimeSteps; ++t) {</span></span>
<span class="line"><span style="color: #D4D4D4">  T0 = T1;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">  // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; i &lt; numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; - </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">  }</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Using OpenMP, we can now parallelise the for loop using this simple extension:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"for (int t = 0; t \u0026lt; numberOfTimeSteps; ++t) {\n  T0 = T1;\n\n  // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\n  #pragma omp parallel for shared(T0, T1, heatDiffusionCoefficient, dt, dx, numberOfPoints, numberOfTimeSteps)\n  for (int i = 1; i \u0026lt; numberOfPoints - 1; ++i) {\n      T1[i] = T0[i] + heatDiffusionCoefficient * dt / (dx * dx) * (T0[i + 1] - 2 * T0[i] + T0[i - 1]);\n  }\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e t = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; t \u0026lt; numberOfTimeSteps; ++t) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  T0 = T1;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#pragma\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eomp\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eparallel\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eshared\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eheatDiffusionCoefficient\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edt\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edx\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfPoints\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfTimeSteps\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + heatDiffusionCoefficient * dt / (dx * dx) * (\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":9,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>for (int t = 0; t &lt; numberOfTimeSteps; ++t) {
  T0 = T1;

  // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space
  #pragma omp parallel for shared(T0, T1, heatDiffusionCoefficient, dt, dx, numberOfPoints, numberOfTimeSteps)
  for (int i = 1; i &lt; numberOfPoints - 1; ++i) {
      T1&#91;i&#93; = T0&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (T0&#91;i + 1&#93; - 2 * T0&#91;i&#93; + T0&#91;i - 1&#93;);
  }
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> t = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; t &lt; numberOfTimeSteps; ++t) {</span></span>
<span class="line"><span style="color: #D4D4D4">  T0 = T1;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">  // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space</span></span>
<span class="line"><span style="color: #569CD6">  </span><span style="color: #C586C0">#pragma</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">omp</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">parallel</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">for</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">shared</span><span style="color: #569CD6">(</span><span style="color: #9CDCFE">T0</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">T1</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">heatDiffusionCoefficient</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">dt</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">dx</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">numberOfPoints</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">numberOfTimeSteps</span><span style="color: #569CD6">)</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; i &lt; numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; - </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">  }</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>That's it! We have added a <code>#pragma</code> statement, that, depending on how we compile the code, can either be ignored completely by the compiler (and thus, giving us again a sequential code), or it can be interpreted to parallelise the following loop if we instruct the compiler to do that.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's look at the arguments, we have <code>#pragma omp parallel</code>. The <code>omp</code> here is essentially just used to tell the compiler that what follows is OpenMP code and should be treated as such. The <code>parallel</code> directive tells the compiler that the following region should be done in parallel, i.e. we want to use more than just a single core (which, in OpenMP terminology, is called a thread). OpenMP allows us to further specify that what follows is a <code>for</code> loop, and so the parallel region will only be created for the for loop that follows.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Then, we have the <code>shared()</code> clause, which tells OpenMP which of the variables should be treated as shared variables. The opposite are private variables. Private variables are available only to the thread that is working on them. So, for example, if we said instead <code>private(T1)</code>, not <code>shared(T1)</code>, then each thread gets its own copy of <code>T1</code>. Each thread will then update its own private copy, but then once we exit the loop, how are we going to consolidate all of these individual (private) <code>T1</code> arrays?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, the solution is simple, declare <code>T1</code> as shared, and so each thread will directly update <code>T1</code> in RAM. Since all threads will work on a different portion of <code>T1</code>, we won't have a race condition here. For example, thread 0 may update elements 0-99 in <code>T1</code>, then, thread 1 will update elements 100-199, thread 2 will update elements 200-299, and so on. Each thread works on its own section within <code>T1</code>; we don't have a race condition, and so we can make <code>T1</code> shared.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are a bunch of additional options you can set in the <code>#pragma omp parallel for</code> command, but you don't really have to. These are optimisation things you can do, but you only really need to do that if you are doing something exotic within your loop. If you just have a simple loop like the example above, this is all you will need to do.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The problem is that we are now creating a new parallel region every time step. If we have thousands of time steps, then we create a new parallel region thousands of times. This is bad for performance, and so a much better way of dealing with this is to create the parallel region before the time loop starts (so we only spawn a new parallel region once).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is what I have done in the following parallelised code, and this is pretty much how you would implement an OpenMP parallelisation strategy for a more complex (and realistic) CFD solver as well. I have given the full code again, and I'll provide additional explanations below the code that are pertinent to OpenMP. If anything else in the code is unclear, refer back to the notes given in the previous section on the sequential code.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#include \u0026lt;iostream\u003e\n#include \u0026lt;vector\u003e\n#include \u0026lt;chrono\u003e\n#include \u0026lt;fstream\u003e\n#include \u0026lt;string\u003e\n\n#include \u0026lt;omp.h\u003e\n\n// Usage: ./heat1DOpenMP \u0026lt;numberOfPoints\u003e \u0026lt;finalTime\u003e \u0026lt;numberOfThreads\u003e\nint main(int argc, char* argv[]) {\n    // input parameters\n    const int numberOfPoints = static_cast\u0026lt;int\u003e(atoi(argv[1]));\n    const double leftBoundary = 0.0;\n    const double rightBoundary = 1.0;\n    const double CFL = 0.25;\n    const double heatDiffusionCoefficient = 0.01;\n    const double finalTime = static_cast\u0026lt;double\u003e(atof(argv[2]));\n    omp_set_num_threads(atoi(argv[3]));\n    \n    // computed input paramters\n    const double dx = 1.0 / (numberOfPoints - 1);\n    const double dt = CFL * dx * dx / heatDiffusionCoefficient;\n    const int numberOfTimeSteps = static_cast\u0026lt;int\u003e(finalTime / dt);\n\n    // allocate memory for field arrays\n    std::vector\u0026lt;double\u003e T0(numberOfPoints); // T at time n\n    std::vector\u0026lt;double\u003e T1(numberOfPoints); // T at time n+1\n    std::vector\u0026lt;double\u003e x(numberOfPoints);\n\n    // create mesh\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        x[i] = dx * i;\n    }\n\n    // initialise field arrays\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        T0[i] = 0.0;\n        T1[i] = 0.0;\n    }\n\n    // set boundary conditions (important, set it for T1, not T0)\n    T1[0] = leftBoundary;\n    T1[numberOfPoints - 1] = rightBoundary;\n\n    auto startTime = std::chrono::high_resolution_clock::now();\n    // loop over all timesteps\n    #pragma omp parallel shared(T0, T1, heatDiffusionCoefficient, dt, dx, numberOfPoints, numberOfTimeSteps)\n    {\n        #pragma omp single\n        {\n            std::cout \u0026lt;\u0026lt; \u0022Running with \u0022 \u0026lt;\u0026lt; omp_get_num_threads() \u0026lt;\u0026lt; \u0022 threads\\n\u0022;\n        }\n        for (int t = 0; t \u0026lt; numberOfTimeSteps; ++t) {\n            #pragma omp for\n            for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n                T0[i] = T1[i];\n            }\n\n            // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\n            #pragma omp for\n            for (int i = 1; i \u0026lt; numberOfPoints - 1; ++i) {\n                T1[i] = T0[i] + heatDiffusionCoefficient * dt / (dx * dx) * (T0[i + 1] - 2 * T0[i] + T0[i - 1]);\n            }\n        }\n    }\n\n    auto endTime = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u003e(endTime - startTime);\n    std::cout \u0026lt;\u0026lt; \u0022Executation time: \u0022 \u0026lt;\u0026lt; static_cast\u0026lt;double\u003e(duration.count()) / 1000 \u0026lt;\u0026lt; \u0022 seconds\u0022 \u0026lt;\u0026lt; std::endl;\n    \n    // compute error\n    double error = 0.0;\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        error += std::abs(T1[i] - x[i]);\n    }\n    error /= numberOfPoints;\n    std::cout \u0026lt;\u0026lt; \u0022Error: \u0022 \u0026lt;\u0026lt; error \u0026lt;\u0026lt; std::endl;\n\n    // output results\n    auto finalTimeString = std::to_string(finalTime);\n    finalTimeString = finalTimeString.substr(0, finalTimeString.find(\u0022.\u0022));\n    std::string fileName = \u0022results_OpenMP_\u0022 + finalTimeString + \u0022.csv\u0022;\n    std::ofstream file(fileName);\n    file \u0026lt;\u0026lt; \u0022x,T\u0022 \u0026lt;\u0026lt; std::endl;\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        file \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0022, \u0022 \u0026lt;\u0026lt; T1[i] \u0026lt;\u0026lt; std::endl;\n    }\n    file.close();\n\n    return 0;\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;chrono\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;fstream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;omp.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e// Usage: ./heat1DOpenMP \u0026lt;numberOfPoints\u0026gt; \u0026lt;finalTime\u0026gt; \u0026lt;numberOfThreads\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emain\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargc\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar*\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[]) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // input parameters\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfPoints = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eatoi\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e leftBoundary = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e rightBoundary = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e CFL = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.25\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e heatDiffusionCoefficient = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.01\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e finalTime = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eatof\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eomp_set_num_threads\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eatoi\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e3\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // computed input paramters\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e dx = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e / (numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e dt = CFL * dx * dx / heatDiffusionCoefficient;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfTimeSteps = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(finalTime / dt);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // allocate memory for field arrays\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e // T at time n\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e // T at time n+1\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // create mesh\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = dx * i;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // initialise field arrays\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // set boundary conditions (important, set it for T1, not T0)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; = leftBoundary;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; = rightBoundary;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e startTime = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ehigh_resolution_clock\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003enow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // loop over all timesteps\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#pragma\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eomp\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eparallel\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eshared\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eheatDiffusionCoefficient\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edt\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edx\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfPoints\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfTimeSteps\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#pragma\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eomp\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003esingle\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Running with \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eomp_get_num_threads\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot; threads\u003c/span\u003e\u003cspan style=\u0022color: #D7BA7D\u0022\u003e\\n\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e t = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; t \u0026lt; numberOfTimeSteps; ++t) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#pragma\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eomp\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efor\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e                \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e            // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#pragma\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eomp\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efor\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e                \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + heatDiffusionCoefficient * dt / (dx * dx) * (\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e endTime = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ehigh_resolution_clock\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003enow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e duration = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eduration_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003emilliseconds\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(endTime - startTime);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Executation time: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eduration\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecount\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e()) / \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1000\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot; seconds\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // compute error\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e error = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        error += \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eabs\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    error /= numberOfPoints;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Error: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; error \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // output results\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e finalTimeString = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eto_string\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(finalTime);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    finalTimeString = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efinalTimeString\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esubstr\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efinalTimeString\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::string fileName = \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;results_OpenMP_\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + finalTimeString + \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.csv\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::ofstream \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efile\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(fileName);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    file \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;x,T\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        file \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;, \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efile\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eclose\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":91,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>#include &lt;iostream>
#include &lt;vector>
#include &lt;chrono>
#include &lt;fstream>
#include &lt;string>

#include &lt;omp.h>

// Usage: ./heat1DOpenMP &lt;numberOfPoints> &lt;finalTime> &lt;numberOfThreads>
int main(int argc, char* argv[]) {
    // input parameters
    const int numberOfPoints = static_cast&lt;int>(atoi(argv&#91;1&#93;));
    const double leftBoundary = 0.0;
    const double rightBoundary = 1.0;
    const double CFL = 0.25;
    const double heatDiffusionCoefficient = 0.01;
    const double finalTime = static_cast&lt;double>(atof(argv&#91;2&#93;));
    omp_set_num_threads(atoi(argv&#91;3&#93;));
    
    // computed input paramters
    const double dx = 1.0 / (numberOfPoints - 1);
    const double dt = CFL * dx * dx / heatDiffusionCoefficient;
    const int numberOfTimeSteps = static_cast&lt;int>(finalTime / dt);

    // allocate memory for field arrays
    std::vector&lt;double> T0(numberOfPoints); // T at time n
    std::vector&lt;double> T1(numberOfPoints); // T at time n+1
    std::vector&lt;double> x(numberOfPoints);

    // create mesh
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        x&#91;i&#93; = dx * i;
    }

    // initialise field arrays
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        T0&#91;i&#93; = 0.0;
        T1&#91;i&#93; = 0.0;
    }

    // set boundary conditions (important, set it for T1, not T0)
    T1&#91;0&#93; = leftBoundary;
    T1&#91;numberOfPoints - 1&#93; = rightBoundary;

    auto startTime = std::chrono::high_resolution_clock::now();
    // loop over all timesteps
    #pragma omp parallel shared(T0, T1, heatDiffusionCoefficient, dt, dx, numberOfPoints, numberOfTimeSteps)
    {
        #pragma omp single
        {
            std::cout &lt;&lt; "Running with " &lt;&lt; omp_get_num_threads() &lt;&lt; " threads\n";
        }
        for (int t = 0; t &lt; numberOfTimeSteps; ++t) {
            #pragma omp for
            for (int i = 0; i &lt; numberOfPoints; ++i) {
                T0&#91;i&#93; = T1&#91;i&#93;;
            }

            // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space
            #pragma omp for
            for (int i = 1; i &lt; numberOfPoints - 1; ++i) {
                T1&#91;i&#93; = T0&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (T0&#91;i + 1&#93; - 2 * T0&#91;i&#93; + T0&#91;i - 1&#93;);
            }
        }
    }

    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds>(endTime - startTime);
    std::cout &lt;&lt; "Executation time: " &lt;&lt; static_cast&lt;double>(duration.count()) / 1000 &lt;&lt; " seconds" &lt;&lt; std::endl;
    
    // compute error
    double error = 0.0;
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        error += std::abs(T1&#91;i&#93; - x&#91;i&#93;);
    }
    error /= numberOfPoints;
    std::cout &lt;&lt; "Error: " &lt;&lt; error &lt;&lt; std::endl;

    // output results
    auto finalTimeString = std::to_string(finalTime);
    finalTimeString = finalTimeString.substr(0, finalTimeString.find("."));
    std::string fileName = "results_OpenMP_" + finalTimeString + ".csv";
    std::ofstream file(fileName);
    file &lt;&lt; "x,T" &lt;&lt; std::endl;
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        file &lt;&lt; x&#91;i&#93; &lt;&lt; ", " &lt;&lt; T1&#91;i&#93; &lt;&lt; std::endl;
    }
    file.close();

    return 0;
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;iostream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;vector&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;chrono&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;fstream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;string&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;omp.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">// Usage: ./heat1DOpenMP &lt;numberOfPoints&gt; &lt;finalTime&gt; &lt;numberOfThreads&gt;</span></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">main</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">argc</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">char*</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">[]) {</span></span>
<span class="line"><span style="color: #6A9955">    // input parameters</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfPoints = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #DCDCAA">atoi</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> leftBoundary = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> rightBoundary = </span><span style="color: #B5CEA8">1.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> CFL = </span><span style="color: #B5CEA8">0.25</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> heatDiffusionCoefficient = </span><span style="color: #B5CEA8">0.01</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> finalTime = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #DCDCAA">atof</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4">&#93;));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">omp_set_num_threads</span><span style="color: #D4D4D4">(</span><span style="color: #DCDCAA">atoi</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">3</span><span style="color: #D4D4D4">&#93;));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // computed input paramters</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> dx = </span><span style="color: #B5CEA8">1.0</span><span style="color: #D4D4D4"> / (numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> dt = CFL * dx * dx / heatDiffusionCoefficient;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfTimeSteps = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;(finalTime / dt);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // allocate memory for field arrays</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">T0</span><span style="color: #D4D4D4">(numberOfPoints);</span><span style="color: #6A9955"> // T at time n</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">T1</span><span style="color: #D4D4D4">(numberOfPoints);</span><span style="color: #6A9955"> // T at time n+1</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">x</span><span style="color: #D4D4D4">(numberOfPoints);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // create mesh</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93; = dx * i;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // initialise field arrays</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // set boundary conditions (important, set it for T1, not T0)</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93; = leftBoundary;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; = rightBoundary;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> startTime = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">high_resolution_clock</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">now</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #6A9955">    // loop over all timesteps</span></span>
<span class="line"><span style="color: #569CD6">    </span><span style="color: #C586C0">#pragma</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">omp</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">parallel</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">shared</span><span style="color: #569CD6">(</span><span style="color: #9CDCFE">T0</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">T1</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">heatDiffusionCoefficient</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">dt</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">dx</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">numberOfPoints</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">numberOfTimeSteps</span><span style="color: #569CD6">)</span></span>
<span class="line"><span style="color: #D4D4D4">    {</span></span>
<span class="line"><span style="color: #569CD6">        </span><span style="color: #C586C0">#pragma</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">omp</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">single</span></span>
<span class="line"><span style="color: #D4D4D4">        {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Running with &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #DCDCAA">omp_get_num_threads</span><span style="color: #D4D4D4">() &lt;&lt; </span><span style="color: #CE9178">&quot; threads</span><span style="color: #D7BA7D">\n</span><span style="color: #CE9178">&quot;</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> t = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; t &lt; numberOfTimeSteps; ++t) {</span></span>
<span class="line"><span style="color: #569CD6">            </span><span style="color: #C586C0">#pragma</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">omp</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">for</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">                </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93;;</span></span>
<span class="line"><span style="color: #D4D4D4">            }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">            // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space</span></span>
<span class="line"><span style="color: #569CD6">            </span><span style="color: #C586C0">#pragma</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">omp</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">for</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; i &lt; numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">                </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; - </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">            }</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> endTime = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">high_resolution_clock</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">now</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> duration = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">duration_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">milliseconds</span><span style="color: #D4D4D4">&gt;(endTime - startTime);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Executation time: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #9CDCFE">duration</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">count</span><span style="color: #D4D4D4">()) / </span><span style="color: #B5CEA8">1000</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #CE9178">&quot; seconds&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // compute error</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> error = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        error += </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">abs</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; - </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    error /= numberOfPoints;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Error: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; error &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // output results</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> finalTimeString = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">to_string</span><span style="color: #D4D4D4">(finalTime);</span></span>
<span class="line"><span style="color: #D4D4D4">    finalTimeString = </span><span style="color: #9CDCFE">finalTimeString</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">substr</span><span style="color: #D4D4D4">(</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #9CDCFE">finalTimeString</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(</span><span style="color: #CE9178">&quot;.&quot;</span><span style="color: #D4D4D4">));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::string fileName = </span><span style="color: #CE9178">&quot;results_OpenMP_&quot;</span><span style="color: #D4D4D4"> + finalTimeString + </span><span style="color: #CE9178">&quot;.csv&quot;</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::ofstream </span><span style="color: #DCDCAA">file</span><span style="color: #D4D4D4">(fileName);</span></span>
<span class="line"><span style="color: #D4D4D4">    file &lt;&lt; </span><span style="color: #CE9178">&quot;x,T&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        file &lt;&lt; </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93; &lt;&lt; </span><span style="color: #CE9178">&quot;, &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">file</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">close</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Here are some additional explanations for the OpenMP part of this code:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li><strong>Line 7</strong>: To ensure OpenMP can be used, we need to include the OpenMP header file, which is called <code>omp.h</code>.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 18</strong>: For the OpenMP code, we have a third command line argument, which is the number of threads (or cores) we want to use. We tell OpenMP here about our intention, and set the required number of threads (cores) using the <code>omp_set_num_threads()</code> function. We use again the <code>atoi()</code> function to convert the command line argument, which is interpreted as a set of characters (<code>char</code>), to an integer.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 47-65</strong>: We create a parallel code block using the <code>#pragma omp parallel</code> instruction. We specify the shared variables as well, although the only real shared variables that we need here are <code>T0</code> and <code>T1</code>, it would have no difference if we set the other variables to private. By default, any variable that is not set here will be private to each thread.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 49-52</strong>: We want to print something to the screen/console here, specifically, the number of threads/cores we are using. We use the <code>#pragma omp single</code> command here to ensure that only a single thread will do this. Whichever thread gets here first will execute this code, and all other threads have to wait at line 52. This is the default behaviour. We could add a <code>nowait</code>, i.e. <code>#pragma omp single nowait</code> and other threads would be allowed to continue, even if this block hasn't yet been fully completed. Adding <code>nowait</code> is good for performance, but depending on what we do inside this block of code, we may need to ensure that it is done before other threads can access some potentially updated array, i.e. we need to ensure we don't create a race condition here. In our case, we could have added the <code>nowait</code> here, but this block is executed only once, and the <code>nowait</code> would not have any measurable influence. If you have a <code>#pragma omp single</code> statement somewhere inside a loop, you probably want to check if you can add the <code>nowait</code> to enhance performance.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 54-57</strong>: We now update the temperature in parallel using the <code>#pragma omp for</code> statement we already saw previously. Since we have already created a parallel region using the <code>#pragma omp parallel</code> instruction on line 47, we don't have to specify anything else here since everything has already been set up on line 47.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 60-63</strong>: We now compute the updated temperature in parallel, using, again, the <code>#pragma omp for</code> construct.

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Everything else is done sequentially in this code, i.e. we set up our solver before the time loop sequentially, and we compute the error as well sequentially. If we found that the error computation takes really long, we could slap on another <code>#pragma omp parallel for</code> here to speed up the error computation. However, this will mean that we have to set the <code>error</code> variable as a <code>private</code> variable, and so we end up with different error computations that need to be added up from all processors.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To handle that, we would need to use a <em>reduction</em> operation. Reductions are operations that collect information from all processors (like an error value) and reduce them to a single value across all processors. Different reduction operators are available, such as add, subtract, multiply, divide, find the max value, and find the min value. In this example, we would like to compute the error on each processor first, and then reduce it by adding all errors together into a global error. The following code would achieve just that:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"// compute error\ndouble error = 0.0;\n#pragma omp parallel for shared(T1, x) reduction(+:error) \nfor (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n  error += std::abs(T1[i] - x[i]);\n}\nerror /= numberOfPoints;\nstd::cout \u0026lt;\u0026lt; \u0022Error: \u0022 \u0026lt;\u0026lt; error \u0026lt;\u0026lt; std::endl;","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e// compute error\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e error = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#pragma\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eomp\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eparallel\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eshared\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e) \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ereduction\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e(+:\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eerror\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e) \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  error += \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eabs\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003eerror /= numberOfPoints;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Error: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; error \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":8,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>// compute error
double error = 0.0;
#pragma omp parallel for shared(T1, x) reduction(+:error) 
for (int i = 0; i &lt; numberOfPoints; ++i) {
  error += std::abs(T1&#91;i&#93; - x&#91;i&#93;);
}
error /= numberOfPoints;
std::cout &lt;&lt; "Error: " &lt;&lt; error &lt;&lt; std::endl;</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #6A9955">// compute error</span></span>
<span class="line"><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> error = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #C586C0">#pragma</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">omp</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">parallel</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">for</span><span style="color: #569CD6"> </span><span style="color: #9CDCFE">shared</span><span style="color: #569CD6">(</span><span style="color: #9CDCFE">T1</span><span style="color: #569CD6">, </span><span style="color: #9CDCFE">x</span><span style="color: #569CD6">) </span><span style="color: #9CDCFE">reduction</span><span style="color: #569CD6">(+:</span><span style="color: #9CDCFE">error</span><span style="color: #569CD6">) </span></span>
<span class="line"><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">  error += </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">abs</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; - </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span>
<span class="line"><span style="color: #D4D4D4">error /= numberOfPoints;</span></span>
<span class="line"><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Error: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; error &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Here, we have used, again, the <code>#pragma omp parallel for</code> instruction to tell OpenMP that we would like to execute the for loop that follows in parallel. We also said that both <code>T1</code> and <code>x</code> can be treated as shared variables. However, we have also added the additional <code>reduction (+:error)</code> instruction, telling OpenMP that we want all computed <code>error</code> values to be reduced after the loop by adding (<code>+</code>) all error values together from each processor.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now that we have extended the code to handle OpenMP, we need to add an executable to our CMake file. The following code shows the addition I have made to the <code>CMakeLists.txt</code> file within the root directory of the project.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"# \u002d\u002d- OpenMP code \u002d\u002d-\nadd_executable(heat1DOpenMP \u0022src/heat1DOpenMP.cpp\u0022)\nfind_package(OpenMP REQUIRED)\ntarget_link_libraries(heat1DOpenMP PRIVATE OpenMP::OpenMP_CXX)","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# \u002d\u002d- OpenMP code \u002d\u002d-\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eadd_executable\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(heat1DOpenMP \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;src/heat1DOpenMP.cpp\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efind_package\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(OpenMP REQUIRED)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etarget_link_libraries\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(heat1DOpenMP PRIVATE OpenMP::OpenMP_CXX)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cmake","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":4,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly># --- OpenMP code ---
add_executable(heat1DOpenMP "src/heat1DOpenMP.cpp")
find_package(OpenMP REQUIRED)
target_link_libraries(heat1DOpenMP PRIVATE OpenMP::OpenMP_CXX)</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #6A9955"># --- OpenMP code ---</span></span>
<span class="line"><span style="color: #569CD6">add_executable</span><span style="color: #D4D4D4">(heat1DOpenMP </span><span style="color: #CE9178">&quot;src/heat1DOpenMP.cpp&quot;</span><span style="color: #D4D4D4">)</span></span>
<span class="line"><span style="color: #569CD6">find_package</span><span style="color: #D4D4D4">(OpenMP REQUIRED)</span></span>
<span class="line"><span style="color: #569CD6">target_link_libraries</span><span style="color: #D4D4D4">(heat1DOpenMP PRIVATE OpenMP::OpenMP_CXX)</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Here, I have defined the <code>heat1DOpenMP</code> executable, which is based on the <code>"src/heat1DOpenMP.cpp"</code> file. However, we are now using OpenMP, and so we also have to tell the compiler that we want to use it. This is where a bit of CMake magic can make our lives so much easier. We simply tell it to find all the information it needs with the <code>find_package()</code> command. We tell it to look for the <code>OpenMP</code> package, and we also tell it that we can't compile our code without it (this is what the <code>REQUIRED</code> keyword is enforcing).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Then, we simply add this dependency to our executable using the <code>target_link_library()</code> call. The first argument is the executable we have created 2 lines above, and we tell it that we want to link it against the target <code>OpenMP::OpenMPP_CXX</code>. This will resolve all header files and libraries that need to be linked against the executable.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The best part of OpenMP is that it is a compiler extension that automatically comes with your compiler. Any of the larger C++ compilers will ship with OpenMP. This means if you are using a major compiler like <code>g++</code>, <code>clang++</code>, <code>msvc</code>, etc., then you will already have OpenMP installed and you don't have to do anything other than turn OpenMP support on. It is as simple as that.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This means that it is very easy to start experimenting with OpenMP, and as you have seen, in the simplest case, you may just need to add a single line of code to your solver to enable parallelisation. You won't get outstanding performance, but just as a benchmark, when I was relatively new to the world of HPC and parallel computing, I learned OpenMP in about a week or so. I then parallelised one of my CFD solvers in about 30 minutes (that was my first real parallelisation attempt with OpenMP), and on 4 cores, I get an efficiency of about 80%.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Considering that the barrier of entry is very low, and that I didn't know really what I was doing, this was quite a good achievement and shows how OpenMP can be a good entry point into parallel computing. You may want to target thousands of cores later, but if you have never done anything with parallel computing, OpenMP may be the best framework you can learn.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>OpenMP is a standard that keeps evolving, and these days it even supports offloading work not just to CPUs but also to GPUs. So, with the same level of effort, you could be using your GPU as well with relative ease. As you will see in the next section, if you want to natively interact with your NVIDIA GPU and use CUDA, then you will need to do a little bit more work. You also have to understand GPU parallelisation in more detail before you can extract performance from it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In any case, OpenMP is a pretty good parallelisation framework that wants to hold the hand of the developer and help them get through the code. Wait until you see MPI, and you'll appreciate the simplicity of OpenMP. If you want to see what else you can do with OpenMP, my favourite resource for looking up examples and documentation about how to use it is <a href="https://rookiehpc.org/openmp/docs/index.html" target="_blank" rel="noopener" title="">RookieHPC</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you want to run the code now, you can compile it using the same CMake instructions as we have seen for the sequential code, i.e.:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"cmake -DCMAKE_BUILD_TYPE=Release ..","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecmake\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-DCMAKE_BUILD_TYPE=Release\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e..\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>cmake -DCMAKE_BUILD_TYPE=Release ..</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">cmake</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-DCMAKE_BUILD_TYPE=Release</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">..</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"cmake \u002d\u002dbuild . \u002d\u002dconfig Release","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecmake\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u002d\u002dbuild\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u002d\u002dconfig\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003eRelease\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>cmake --build . --config Release</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">cmake</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">--build</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">.</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">--config</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">Release</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>You can now, again, execute the solver using:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":".\\Release\\heat1DOpenMP.exe 101 100 4","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\\Release\\heat1DOpenMP.exe \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e101\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e4\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>.\Release\heat1DOpenMP.exe 101 100 4</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">.</span><span style="color: #D4D4D4">\Release\heat1DOpenMP.exe </span><span style="color: #B5CEA8">101</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">100</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">4</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>On UNIX, you may write something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"./Release/heat1DOpenMP 101 100 4","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003e./Release/heat1DOpenMP\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e101\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e4\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>./Release/heat1DOpenMP 101 100 4</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">./Release/heat1DOpenMP</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">101</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">100</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">4</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Notice the third command line argument, which is now required, specifying how many threads/cores we want to use. You can now start to compare computational times between the sequential and the OpenMP code, though I will wait with such a comparison until we have had a chance to look at each parallelisation framework, so that we can compare all of these approaches against each other.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-cuda">CUDA</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ok, OpenMP was a gentle introduction to parallel computing. Let's increase the complexity a bit. In case you are completely in the dark about GPU computing, I have written an entire article on why GPU computing is all of a sudden popping up everywhere. This article may help get up to speed with the hardware and its advantages and disadvantages. If you want to catch up first, here is the link: <a href="https://cfd.university/blog/why-is-everyone-switching-to-gpu-computing-in-cfd/" target="_blank" rel="noopener" title="">Why is everyone switching to GPU computing in CFD?</a>. It's OK, I'll wait.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Are you back? Good, then let's continue. CUDA stands for the <em>Compute Unified Device Architecture</em> and is (or must be?!) one of these acronyms where the acronym came first, presumably by someone in marketing who thought it sounds cool. It must have then been given to an engineer who thought that <em>Compute Unified Device Architecture</em> sounds like a good acronym.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Why not call it <em>Binary Execution Enhancement Framework</em> (BEEF) or <em>Matrix-oriented Instruction Set Toolkit</em> (MOIST)? Given that Nvidia is (or was, depending on when you read this) the most valuable company in the world, which can all be tracked back to them releasing CUDA to the public and giving them a toolkit to use their GPU for computing purposes, not just for graphical applications, they could have done better. Anyways ...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Yes, <s>BEEF</s>, <s>MOIST</s>, CUDA provides a means for us developers to talk to our GPU directly and perform operations on the GPU that we would otherwise only be able to do on our CPU. The GPU is its own entity, and if you have a GPU in your PC or laptop, you will know that these are not directly attached to your CPU, but rather, to the motherboard. The motherboard then establishes a communication link between the CPU, GPU, and memory.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This physical separation means that before we do anything on the GPU, we need to bring any data it should use for computations onto the GPU memory. We need to do that because the GPU can't directly read memory from RAM (where our code resides, in the form of a binary executable when we launch it). So, when we looked at OpenMP above, we were able to just allocate memory in the usual manner and then use that allocated memory during the parallel execution.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For CUDA, we have to now keep 2 copies of data, one on the CPU and one on the GPU. We do that because we usually want to read data from disk, such as configuration files, a mesh, or something similar that will help us to set up our simulations. All of this data typically resides on our hard drive, and our application can read from the hard drive directly, but again, the GPU can't. So, we set everything up on the CPU side and then decide what needs to be transferred over to the GPU.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Typically, we copy large arrays; in our example, we will need to copy the temperature array over to the GPU. We then perform our computations on the GPU, and after that is done, we transfer all of the data back to the CPU, where we can now use it to write out the solution to the hard drive, for example, as a <code>*.csv</code> file, as we have done for the sequential and OpenMP code as well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are different ways in which we can copy memory back and forth between the GPU. The simplest form to understand is that we have one array on the CPU side and one array on the GPU side, and we transfer data between the two explicitly. This is what we will use later, and generally speaking, it is the fastest approach. But CUDA offers various other approaches, and NVIDIA has a <a href="https://developer.nvidia.com/blog/unified-memory-cuda-beginners/" target="_blank" rel="noopener" title="">gentle introduction to the various forms</a>. There is also a benchmark between the different approaches, which you can find over at <a href="https://developer.ridgerun.com/wiki/index.php/RidgeRun_CUDA_Optimisation_Guide/Empirical_Experiments/Simple_bounding_test" target="_blank" rel="noopener" title="">RidgeRun</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In a nutshell, these different approaches can make our lives easier, where we give CUDA full authority over transferring data back and forth when needed, which comes at a small performance penalty. In our case, it doesn't really matter which approach we use, as we will only be copying data twice (once before the computation, and once after), and a few milliseconds more in memory transfer wouldn't make a huge difference here. These other memory paradigms are more important if we need to copy data at each iteration, or when talking to other GPUs.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another thing to note about CUDA is that it is written in C, not C++, so we will be seeing a bit of ugly syntax that C++ has largely done away with. Things like allocating memory for pointers directly, which, after two decades of C++ programming, feels very backwards. Or using mega functions with long names and several parameters. Good old C programming. But anyways, that's the price we have to pay when using CUDA (C is a better choice than C++ if you want other programming languages to also use CUDA, so I get why they did it ...).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Copying data back and forth is not the only difference we will see. There are a few more. For starters, a GPU has lots and lots of processors, whereas a CPU typically only has 4 - 128 cores. On the GPU, we have thousands of cores (you can find out how many cores your GPU has by looking for CUDA cores under its specifications). Each CUDA core has many more threads (just like we have multithreading on CPUs), but these work slightly differently, and so whenever we launch a function on a GPU, we have to tell it how many threads to use.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What this ultimately means for us is that we won't see any for loops anymore. Yep, for loops will be removed in CUDA. Instead, we assume that we have as many threads available as there are elements in our arrays. Thus, if we had code like this:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"for (int i = 1; i \u0026lt; numberOfPoints - 1; ++i) {\n  T1[i] = T0[i] + heatDiffusionCoefficient * dt / (dx * dx) * (T0[i + 1] - 2 * T0[i] + T0[i - 1]);\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + heatDiffusionCoefficient * dt / (dx * dx) * (\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":3,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>for (int i = 1; i &lt; numberOfPoints - 1; ++i) {
  T1&#91;i&#93; = T0&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (T0&#91;i + 1&#93; - 2 * T0&#91;i&#93; + T0&#91;i - 1&#93;);
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; i &lt; numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; - </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>This would be replaced in CUDA with something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"int i = blockIdx.x * blockDim.x + threadIdx.x;\n\nif (i \u003e 0 \u0026amp;\u0026amp; i \u0026lt; numberOfPoints - 1) {\n  T1[i] = T0[i] + heatDiffusionCoefficient * dt / (dx * dx) * (T0[i + 1] - 2 * T0[i] + T0[i - 1]);\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eblockIdx\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eblockDim\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ethreadIdx\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (i \u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;\u0026amp; i \u0026lt; numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + heatDiffusionCoefficient * dt / (dx * dx) * (\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":5,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>int i = blockIdx.x * blockDim.x + threadIdx.x;

if (i > 0 &amp;&amp; i &lt; numberOfPoints - 1) {
  T1&#91;i&#93; = T0&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (T0&#91;i + 1&#93; - 2 * T0&#91;i&#93; + T0&#91;i - 1&#93;);
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #9CDCFE">blockIdx</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">blockDim</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4"> + </span><span style="color: #9CDCFE">threadIdx</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (i &gt; </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4"> &amp;&amp; i &lt; numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; - </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>The main difference here is that we are spamming the function with lots and lots of threads, more than we actually need, and then we just check that the thread ID of the current thread running this function is within the range of the array size itself. If so, the thread will perform one computation and then return.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This may seem odd. Why don't we just use as many threads as there are elements in the array? In that case, we could avoid the if statement that checks that the thread ID is within range of the array, right? Yes, we can do that, but just like CPUs, where performance scales best when we use [katex]2^N[/katex] cores (1,2,4,8,16,32,64,128,...), GPUs scale best when we use multiples of 32 threads, and so we arrange our threads in multiples of 32, rather than adjusting them to the size of our array.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, how does a kernel (this is CUDA terminology for a function that is executed on the GPU) know how many threads to use in the first place? Well, we need to tell them. But the way we do it can be a bit counterintuitive if you have never seen this before. So let me start with an analogy, hopefully this will make things clearer.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Imagine you create a start-up company. You have a great idea, vision, and product, but you are also the only one working on it. You don't have funding, you can't employ anyone, so you take on many roles. You like to think of yourself as the CEO (how many people call themselves a CEO on LinkedIn for their 1-person company?), but in reality, you are also head of marketing, head of sales, head of engineering, head of facilities (you clean your own toilet), and, of course, responsible for all the gossip. A lot of responsibilities!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But, you catch a break, an investor comes through, you have a few million to splurge, and so you decide to hire 10 people, from senior to junior level. What do you do? Are you going to manage each person yourself? Well, you might think 10 people is alright, but then your company really takes off, and over the next 5 years, your company expands to 100 people. What do you do now? Still manage all of them directly? Certainly not!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>At some point, you have to appoint a head of marketing/sales/engineering, and those roles will have different teams underneath them. For example, let's say that the head of engineering is looking after the design and manufacturing team, both of which have their own team lead. Each team has a few engineers working in that position. In short, while you may have started as a sole entrepreneur, you have now built up a company structure and no longer have all people reporting to you directly.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When we deal with CPUs, we typically talk about no more than 128 cores per CPU/socket, which is manageable for a CPU. But with GPUs, we talk about billions of threads, executing at the same time. Imagine a Fortune 500 company with 1 CEO and just workers (no head of departments, no junior, senior, or principal engineers, all reporting to the CEO). How would anything ever get done? This just doesn't work, and the same is true for GPU computing.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we just threw all threads at the same time at a computing problem, each thread may be very fast individually, but it may spend most of its time waiting to be launched. Imagine you worked at that fictional Fortune 500 company and had to wait until the CEO got around to you to tell you what you should do next. You'd be waiting for quite some time until it is your turn.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, the GPU works slightly differently. In order to organise all of its computing power, it uses threads, blocks, and grids. You can think of a grid as being the overarching company in our analogy, a block would be a team, and a thread would be a worker (doing the actual work). Thus, we arrange threads in blocks, and several blocks make up a grid.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can tell CUDA how many threads we want to have per block (usually 1024 is the maximum), though, as already alluded to before, this works best if we use multiples of 32 threads. In CUDA, 32 threads are called a warp (and not wrap, as I would have loved ... and I am getting hungry, time for second breakfast?!). A rule of thumb is to use 256, which usually works great, but we can play around with it, and perhaps try 128, 64, or go up and try 512, 1024.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Threads within a block can communicate with each other. So, if I have 1 block with 256 threads, all of these threads essentially follow a shared memory approach. No communication is needed, and as long as we avoid race conditions in our code, they all can perform their work rather fast.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But we may have more than 256 elements in our array. For example, if we run our code that we have seen so far with 1000 points, then 256 threads won't be enough to update the entire temperature array. Remember, we got rid of the for loop, so we need to have as many threads as we have elements in our arrays that need to be updated. If we used 4 blocks, each with 256 threads, then we have a total of 1024 threads, and so we can update this array again.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This example also highlights why we were using an if statement in the code example above. In the previous paragraph, I said our array has 1000 elements, but we are launching our kernel now with 1024 threads. If we allowed thread 1017 to access the temperature array, we would get a segmentation fault and subsequent crash of the programme, so we need to restrict access based on the thread ID. A few threads that won't do anything aren't detrimental to our performance.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>GPUs have so-called Streaming Multiprocessors (SMs), and each SM has a number of so-called CUDA cores. These CUDA cores are in spirit akin to CPU cores, but they are much less powerful than a CPU. However, they make up for it in their sheer number. For example, your GPU may have 128 SMs, each with 128 CUDA cores. This means you have a total of [katex]128\cdot 128 = 16,384[/katex] CUDA cores available. Compare that to your 4 cores on your CPU. Sure, each core may be more powerful, but the GPU beats it by sheer volume.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Whenever you launch a block (containing your 256 threads, for example), it gets assigned to one SM. All of these 256 will now do some work, for example, updating the temperature array at the location of their thread ID. That is, if their thread ID is 73, 123, or 241, they will update the temperature array at <code>T1[73]</code>, <code>T1[123]</code>, and <code>T1[241]</code>. If our SM has 128 CUDA cores, and our block has 256 threads, then each CUDA core will have to do two updates.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once each thread has finished its computation, the block finishes as a whole and is removed from the SM. The SM is given back to the CUDA runtime, which can now assign a different block to the SM. In order to get good parallel performance, we need to saturate the SMs. This means we want to have more blocks than we have SMs on our GPU. The exact number of SMs on your GPU is hardware-dependent, as well as how many CUDA cores you have on your GPU.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's look at how we can tell CUDA how many threads per block, and how many blocks we want to use. When we launch a function on the GPU, we don't just call it with a syntax like <code>computeStuffOnGPU();</code>. We need to tell CUDA here how many threads and blocks we want to use. We do that with the triple bracket syntax, which is specific to CUDA and looks something like this: <code>computeStuffOnGPU<<<gridDimension, blockDimension>>>();</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Here, <code>blockDimension</code> tells the GPU how many threads per block to use, e.g. 256 in our example so far. <code>gridDimension</code>, on the other hand, tells the GPU how many blocks to use. We need to make sure that <code>gridDimension * blockDimension > totalNumberOfPoints</code>, otherwise we will only work partially on our arrays. So, if we wanted to make sure that we use 1024 threads to update our 1000-element array, we would call the function with <code>computeStuffOnGPU<<<4, 256>>>();</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This means that we would typically hardcode <code>blockDimension</code> through experimentation and compute <code>gridDimension</code> dynamically. For example, we can divide the total number of Points by the number of threads, round this number down and add 1. This will ensure that we have enough threads to work on our problem. So, in the example given above, 1000 (total number of points) / 256 (number of threads) is 3.90625. We round this down, which is 3, and then we add 1, which is 4. This is the <code>gridDimension</code> now.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We will use this dynamic calculation of the <code>gridDimension</code> later in the code. There is one more thing we have to discuss. I said that we change our function (kernel) call to include the triple bracket syntax, i.e. <code><<<gridDimension, blockDidmension>>></code>. But that is not all. We also have to tell the compiler where we want the code to execute. For that, CUDA gives us three specifiers:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li><code>__host__</code>: A function marked with <code>__host__</code> will be executed on the CPU.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code>__device__</code>: A function marked with <code>__device__</code> will be executed on the GPU. It can only be called from another function that is already running on the GPU.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><code>__global__</code>: A function marked with <code>__global__</code> will be executed on the GPU. It can be called from the CPU code, and this is typically how we go from CPU to GPU.

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Sticking with our previous function example, if we wanted to declare the function to be executed on the GPU but callable from the CPU code, then we would declare the function as:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"__global__ void computeStuffOnGPU() {\n  // do some computations here\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e__global__ \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecomputeStuffOnGPU\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // do some computations here\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":3,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>__global__ void computeStuffOnGPU() {
  // do some computations here
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #D4D4D4">__global__ </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">computeStuffOnGPU</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #6A9955">  // do some computations here</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Now, we can use our triple bracket syntax to launch this function on the GPU as we have seen before, e.g. <code>computeStuffOnGPU<<<4, 256>>>();</code>. Once we are in this function, let's say that we want to give it some structure, and so we break down different parts of this function into their own functions. Since <code>computeStuffOnGPU();</code> is marked with the <code>__global__</code> identifier, meaning that it is already running on the GPU, we mark functions we call from this function with the <code>__device__</code> identifier.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There is a difference, though, in how we call <code>__device__</code> functions. Since <code>__device__</code> functions are called from within a <code>__global__</code> function, which itself was launched with a specific number of blocks and threads per block (using the tripple angle syntax), the <code>__device__</code> function does not need the tripple angle syntax and will inherit the same number of blocks and threads per block. So, we would just call these as normal functions, as shown in the example code below:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"__device__ void helperFunction() {\n  // do some additional work\n}\n\n__global__ void computeStuffOnGPU() {\n  // runs on GPU, but does not need \u0026lt;\u0026lt;\u0026lt;4, 256\u003e\u003e\u003e\n  helperFunction();\n}\n\nint main() {\n  computeStuffOnGPU\u0026lt;\u0026lt;\u0026lt;4, 256\u003e\u003e\u003e();\n  return 0;\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e__device__ \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ehelperFunction\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // do some additional work\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e__global__ \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecomputeStuffOnGPU\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e  // runs on GPU, but does not need \u0026lt;\u0026lt;\u0026lt;4, 256\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ehelperFunction\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emain\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  computeStuffOnGPU\u0026lt;\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e4\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e256\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;\u0026gt;\u0026gt;();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":13,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>__device__ void helperFunction() {
  // do some additional work
}

__global__ void computeStuffOnGPU() {
  // runs on GPU, but does not need &lt;&lt;&lt;4, 256>>>
  helperFunction();
}

int main() {
  computeStuffOnGPU&lt;&lt;&lt;4, 256>>>();
  return 0;
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #D4D4D4">__device__ </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">helperFunction</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #6A9955">  // do some additional work</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">__global__ </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">computeStuffOnGPU</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #6A9955">  // runs on GPU, but does not need &lt;&lt;&lt;4, 256&gt;&gt;&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #DCDCAA">helperFunction</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">main</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #D4D4D4">  computeStuffOnGPU&lt;&lt;&lt;</span><span style="color: #B5CEA8">4</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">256</span><span style="color: #D4D4D4">&gt;&gt;&gt;();</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>What I have shown above demonstrates, in principle, how all of this fits together, but the above code will not compile. Why is that? Well, we are writing here C++ code, and all of a sudden, we are throwing around new syntax that is not C++ compliant. We use <code>__device__</code>, <code>__global__</code>, and we also change how functions are called. How should the C++ compiler know what we want to do? A C++ compiler does not need to understand CUDA (and, in fact, it would be against the C++ standard).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, we can't just invent our own syntax and then hope the compiler will know what to do, even if we include some additional header files, and perhaps even a compiled library. We can only define additional functions/classes/variables, etc., in header files, but not new C++ syntax. So, if we really want to extend the C++ syntax with our own, well, we have to invent our own compiler. And this is why we have <code>nvcc</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>nvcc</code> stands for Nvidia CUDA compiler, and we can probably all agree, this acronym wasn't created by marketing but rather by some unimaginative engineer at Nvidia, well done ...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>nvcc</code> is essentially just a wrapper around a valid C++ compiler. It doesn't implement the C++ standard itself, but uses an existing C++ compiler for standard C++ syntax. Think of <code>nvcc</code> as a preprocessor. It will look through your code and then check which needs to be compiled by your <em>host</em> C++ compiler (g++, clang++, msvc, whatever floats your boat), and what needs to be compiled for GPU execution (for which Nvidia has their own compiler which will look after that).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, <code>nvcc</code> splits work that needs to be done by a standard C++ compiler and its own GPU compiler. In this way, they can get away with extending the standard C++ syntax. This also means that we have to split our code into host (standard) C++ code and device (GPU) code.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We do that by splitting code into separate files, where all device (GPU) code is written in a file that ends, by convention, in <code>*.cu</code>, which, of course, is an abbreviation for cfd university, and we can all agree that the marketing department got one abbreviation finally right! Other conspiracy theories would have you believe that it may be a short form for CUDA, but, I mean, let's be serious, what is more plausible here?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Jokes aside, we are now ready to look at some GPU parallelisation, finally! I will give the code that runs on the host first, and then we look at the CUDA kernels afterwards (which are in their own <code>*.cu</code> file).</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#include \u0026lt;iostream\u003e\n#include \u0026lt;vector\u003e\n#include \u0026lt;chrono\u003e\n#include \u0026lt;fstream\u003e\n#include \u0026lt;string\u003e\n\n#include \u0026lt;cuda_runtime.h\u003e\n\n// forward declaration of CUDA kernel functions\nvoid computeTemperature(std::vector\u0026lt;double\u003e \u0026amp;T0, std::vector\u0026lt;double\u003e \u0026amp;T1, double heatDiffusionCoefficient, double dt,\n    double dx, int numberOfPoints, int numberOfTimeSteps);\n\nint main(int argc, char* argv[]) {\n    // make sure a CUDA capable device is available\n    int device_count = 0;\n    cudaError_t cudaStatus = cudaGetDeviceCount(\u0026amp;device_count);\n    if (cudaStatus != cudaSuccess) {\n        std::cerr \u0026lt;\u0026lt; \u0022cudaGetDeviceCount() error: \u0022 \u0026lt;\u0026lt; cudaGetErrorString(cudaStatus) \u0026lt;\u0026lt; std::endl;\n        return 1;\n    }\n    std::cout \u0026lt;\u0026lt; \u0022Number of CUDA capable devices found: \u0022 \u0026lt;\u0026lt; device_count \u0026lt;\u0026lt; std::endl;\n\n    // get the current device id\n    int device_id = 0;\n    cudaStatus = cudaGetDevice(\u0026amp;device_id);\n    if (cudaStatus != cudaSuccess) {\n        std::cerr \u0026lt;\u0026lt; \u0022cudaGetDevice() error: \u0022 \u0026lt;\u0026lt; cudaGetErrorString(cudaStatus) \u0026lt;\u0026lt; std::endl;\n        return 1;\n    }\n\n    // use device id to print some information about the GPU that is being used\n    cudaDeviceProp prop;\n    cudaGetDeviceProperties(\u0026amp;prop, device_id);\n\n    std::cout \u0026lt;\u0026lt; \u0022Running on GPU \u0022 \u0026lt;\u0026lt; device_id \u0026lt;\u0026lt; \u0022: \u0022 \u0026lt;\u0026lt; prop.name \u0026lt;\u0026lt; std::endl;\n    std::cout \u0026lt;\u0026lt; \u0022Compute capability: \u0022 \u0026lt;\u0026lt; prop.major \u0026lt;\u0026lt; \u0022.\u0022 \u0026lt;\u0026lt; prop.minor \u0026lt;\u0026lt; std::endl;\n\n    // input parameters\n    const int numberOfPoints = static_cast\u0026lt;int\u003e(atoi(argv[1]));\n    const double leftBoundary = 0.0;\n    const double rightBoundary = 1.0;\n    const double CFL = 0.25;\n    const double heatDiffusionCoefficient = 0.01;\n    const double finalTime = static_cast\u0026lt;double\u003e(atof(argv[2]));\n    \n    // computed input paramters\n    const double dx = 1.0 / (numberOfPoints - 1);\n    const double dt = CFL * dx * dx / heatDiffusionCoefficient;\n    const int numberOfTimeSteps = static_cast\u0026lt;int\u003e(finalTime / dt);\n\n    // allocate memory for field arrays\n    std::vector\u0026lt;double\u003e T0(numberOfPoints); // T at time n\n    std::vector\u0026lt;double\u003e T1(numberOfPoints); // T at time n+1\n    std::vector\u0026lt;double\u003e x(numberOfPoints);\n\n    // create mesh\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        x[i] = dx * i;\n    }\n\n    // initialise field arrays\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        T0[i] = 0.0;\n        T1[i] = 0.0;\n    }\n\n    // set boundary conditions (important, set it for T1, not T0)\n    T1[0] = leftBoundary;\n    T1[numberOfPoints - 1] = rightBoundary;\n\n    auto startTime = std::chrono::high_resolution_clock::now();\n    \n    // loop over all timesteps    \n    computeTemperature(T0, T1, heatDiffusionCoefficient, dt, dx, numberOfPoints, numberOfTimeSteps);\n    \n    auto endTime = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u003e(endTime - startTime);\n    std::cout \u0026lt;\u0026lt; \u0022Executation time: \u0022 \u0026lt;\u0026lt; static_cast\u0026lt;double\u003e(duration.count()) / 1000 \u0026lt;\u0026lt; \u0022 seconds\u0022 \u0026lt;\u0026lt; std::endl;\n    \n    // compute error\n    double error = 0.0;\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        error += std::abs(T1[i] - x[i]);\n    }\n    error /= numberOfPoints;\n    std::cout \u0026lt;\u0026lt; \u0022Error: \u0022 \u0026lt;\u0026lt; error \u0026lt;\u0026lt; std::endl;\n\n    // output results\n    auto finalTimeString = std::to_string(finalTime);\n    finalTimeString = finalTimeString.substr(0, finalTimeString.find(\u0022.\u0022));\n    std::string fileName = \u0022results_CUDA_\u0022 + finalTimeString + \u0022.csv\u0022;\n    std::ofstream file(fileName);\n    file \u0026lt;\u0026lt; \u0022x,T\u0022 \u0026lt;\u0026lt; std::endl;\n    for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n        file \u0026lt;\u0026lt; x[i] \u0026lt;\u0026lt; \u0022, \u0022 \u0026lt;\u0026lt; T1[i] \u0026lt;\u0026lt; std::endl;\n    }\n    file.close();\n\n    return 0;\n}\n","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;chrono\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;fstream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;cuda_runtime.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e// forward declaration of CUDA kernel functions\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecomputeTemperature\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eheatDiffusionCoefficient\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edt\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edx\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfPoints\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfTimeSteps\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emain\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargc\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar*\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[]) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // make sure a CUDA capable device is available\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e device_count = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ecudaError_t\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e cudaStatus = \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaGetDeviceCount\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;device_count);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (cudaStatus != cudaSuccess) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cerr \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;cudaGetDeviceCount() error: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaGetErrorString\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(cudaStatus) \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Number of CUDA capable devices found: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; device_count \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // get the current device id\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e device_id = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    cudaStatus = \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaGetDevice\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;device_id);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (cudaStatus != cudaSuccess) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cerr \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;cudaGetDevice() error: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaGetErrorString\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(cudaStatus) \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // use device id to print some information about the GPU that is being used\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    cudaDeviceProp prop;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaGetDeviceProperties\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;prop, device_id);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Running on GPU \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; device_id \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eprop\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Compute capability: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eprop\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003emajor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eprop\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eminor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // input parameters\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfPoints = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eatoi\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e leftBoundary = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e rightBoundary = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e CFL = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.25\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e heatDiffusionCoefficient = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.01\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e finalTime = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eatof\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // computed input paramters\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e dx = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e / (numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e dt = CFL * dx * dx / heatDiffusionCoefficient;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfTimeSteps = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(finalTime / dt);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // allocate memory for field arrays\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e // T at time n\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e // T at time n+1\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // create mesh\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = dx * i;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // initialise field arrays\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // set boundary conditions (important, set it for T1, not T0)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; = leftBoundary;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; = rightBoundary;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e startTime = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ehigh_resolution_clock\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003enow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // loop over all timesteps    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecomputeTemperature\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(T0, T1, heatDiffusionCoefficient, dt, dx, numberOfPoints, numberOfTimeSteps);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e endTime = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003ehigh_resolution_clock\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003enow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e duration = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eduration_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003echrono\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003emilliseconds\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(endTime - startTime);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Executation time: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eduration\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecount\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e()) / \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1000\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot; seconds\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // compute error\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e error = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        error += \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eabs\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    error /= numberOfPoints;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Error: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; error \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // output results\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e finalTimeString = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eto_string\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(finalTime);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    finalTimeString = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efinalTimeString\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esubstr\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efinalTimeString\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::string fileName = \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;results_CUDA_\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + finalTimeString + \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.csv\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::ofstream \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efile\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(fileName);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    file \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;x,T\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        file \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;, \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efile\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eclose\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":101,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(3 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>#include &lt;iostream>
#include &lt;vector>
#include &lt;chrono>
#include &lt;fstream>
#include &lt;string>

#include &lt;cuda_runtime.h>

// forward declaration of CUDA kernel functions
void computeTemperature(std::vector&lt;double> &amp;T0, std::vector&lt;double> &amp;T1, double heatDiffusionCoefficient, double dt,
    double dx, int numberOfPoints, int numberOfTimeSteps);

int main(int argc, char* argv[]) {
    // make sure a CUDA capable device is available
    int device_count = 0;
    cudaError_t cudaStatus = cudaGetDeviceCount(&amp;device_count);
    if (cudaStatus != cudaSuccess) {
        std::cerr &lt;&lt; "cudaGetDeviceCount() error: " &lt;&lt; cudaGetErrorString(cudaStatus) &lt;&lt; std::endl;
        return 1;
    }
    std::cout &lt;&lt; "Number of CUDA capable devices found: " &lt;&lt; device_count &lt;&lt; std::endl;

    // get the current device id
    int device_id = 0;
    cudaStatus = cudaGetDevice(&amp;device_id);
    if (cudaStatus != cudaSuccess) {
        std::cerr &lt;&lt; "cudaGetDevice() error: " &lt;&lt; cudaGetErrorString(cudaStatus) &lt;&lt; std::endl;
        return 1;
    }

    // use device id to print some information about the GPU that is being used
    cudaDeviceProp prop;
    cudaGetDeviceProperties(&amp;prop, device_id);

    std::cout &lt;&lt; "Running on GPU " &lt;&lt; device_id &lt;&lt; ": " &lt;&lt; prop.name &lt;&lt; std::endl;
    std::cout &lt;&lt; "Compute capability: " &lt;&lt; prop.major &lt;&lt; "." &lt;&lt; prop.minor &lt;&lt; std::endl;

    // input parameters
    const int numberOfPoints = static_cast&lt;int>(atoi(argv&#91;1&#93;));
    const double leftBoundary = 0.0;
    const double rightBoundary = 1.0;
    const double CFL = 0.25;
    const double heatDiffusionCoefficient = 0.01;
    const double finalTime = static_cast&lt;double>(atof(argv&#91;2&#93;));
    
    // computed input paramters
    const double dx = 1.0 / (numberOfPoints - 1);
    const double dt = CFL * dx * dx / heatDiffusionCoefficient;
    const int numberOfTimeSteps = static_cast&lt;int>(finalTime / dt);

    // allocate memory for field arrays
    std::vector&lt;double> T0(numberOfPoints); // T at time n
    std::vector&lt;double> T1(numberOfPoints); // T at time n+1
    std::vector&lt;double> x(numberOfPoints);

    // create mesh
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        x&#91;i&#93; = dx * i;
    }

    // initialise field arrays
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        T0&#91;i&#93; = 0.0;
        T1&#91;i&#93; = 0.0;
    }

    // set boundary conditions (important, set it for T1, not T0)
    T1&#91;0&#93; = leftBoundary;
    T1&#91;numberOfPoints - 1&#93; = rightBoundary;

    auto startTime = std::chrono::high_resolution_clock::now();
    
    // loop over all timesteps    
    computeTemperature(T0, T1, heatDiffusionCoefficient, dt, dx, numberOfPoints, numberOfTimeSteps);
    
    auto endTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds>(endTime - startTime);
    std::cout &lt;&lt; "Executation time: " &lt;&lt; static_cast&lt;double>(duration.count()) / 1000 &lt;&lt; " seconds" &lt;&lt; std::endl;
    
    // compute error
    double error = 0.0;
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        error += std::abs(T1&#91;i&#93; - x&#91;i&#93;);
    }
    error /= numberOfPoints;
    std::cout &lt;&lt; "Error: " &lt;&lt; error &lt;&lt; std::endl;

    // output results
    auto finalTimeString = std::to_string(finalTime);
    finalTimeString = finalTimeString.substr(0, finalTimeString.find("."));
    std::string fileName = "results_CUDA_" + finalTimeString + ".csv";
    std::ofstream file(fileName);
    file &lt;&lt; "x,T" &lt;&lt; std::endl;
    for (int i = 0; i &lt; numberOfPoints; ++i) {
        file &lt;&lt; x&#91;i&#93; &lt;&lt; ", " &lt;&lt; T1&#91;i&#93; &lt;&lt; std::endl;
    }
    file.close();

    return 0;
}
</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;iostream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;vector&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;chrono&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;fstream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;string&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;cuda_runtime.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">// forward declaration of CUDA kernel functions</span></span>
<span class="line"><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">computeTemperature</span><span style="color: #D4D4D4">(</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #569CD6">&amp;</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">, </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #569CD6">&amp;</span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">heatDiffusionCoefficient</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">dt</span><span style="color: #D4D4D4">,</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">dx</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">numberOfPoints</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">numberOfTimeSteps</span><span style="color: #D4D4D4">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">main</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">argc</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">char*</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">[]) {</span></span>
<span class="line"><span style="color: #6A9955">    // make sure a CUDA capable device is available</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> device_count = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">cudaError_t</span><span style="color: #D4D4D4"> cudaStatus = </span><span style="color: #DCDCAA">cudaGetDeviceCount</span><span style="color: #D4D4D4">(&amp;device_count);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (cudaStatus != cudaSuccess) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cerr &lt;&lt; </span><span style="color: #CE9178">&quot;cudaGetDeviceCount() error: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #DCDCAA">cudaGetErrorString</span><span style="color: #D4D4D4">(cudaStatus) &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Number of CUDA capable devices found: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; device_count &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // get the current device id</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> device_id = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    cudaStatus = </span><span style="color: #DCDCAA">cudaGetDevice</span><span style="color: #D4D4D4">(&amp;device_id);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (cudaStatus != cudaSuccess) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cerr &lt;&lt; </span><span style="color: #CE9178">&quot;cudaGetDevice() error: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #DCDCAA">cudaGetErrorString</span><span style="color: #D4D4D4">(cudaStatus) &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // use device id to print some information about the GPU that is being used</span></span>
<span class="line"><span style="color: #D4D4D4">    cudaDeviceProp prop;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">cudaGetDeviceProperties</span><span style="color: #D4D4D4">(&amp;prop, device_id);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Running on GPU &quot;</span><span style="color: #D4D4D4"> &lt;&lt; device_id &lt;&lt; </span><span style="color: #CE9178">&quot;: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #9CDCFE">prop</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Compute capability: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #9CDCFE">prop</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">major</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #CE9178">&quot;.&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #9CDCFE">prop</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">minor</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // input parameters</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfPoints = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #DCDCAA">atoi</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> leftBoundary = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> rightBoundary = </span><span style="color: #B5CEA8">1.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> CFL = </span><span style="color: #B5CEA8">0.25</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> heatDiffusionCoefficient = </span><span style="color: #B5CEA8">0.01</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> finalTime = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #DCDCAA">atof</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4">&#93;));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // computed input paramters</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> dx = </span><span style="color: #B5CEA8">1.0</span><span style="color: #D4D4D4"> / (numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> dt = CFL * dx * dx / heatDiffusionCoefficient;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfTimeSteps = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;(finalTime / dt);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // allocate memory for field arrays</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">T0</span><span style="color: #D4D4D4">(numberOfPoints);</span><span style="color: #6A9955"> // T at time n</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">T1</span><span style="color: #D4D4D4">(numberOfPoints);</span><span style="color: #6A9955"> // T at time n+1</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">x</span><span style="color: #D4D4D4">(numberOfPoints);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // create mesh</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93; = dx * i;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // initialise field arrays</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // set boundary conditions (important, set it for T1, not T0)</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93; = leftBoundary;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; = rightBoundary;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> startTime = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">high_resolution_clock</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">now</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // loop over all timesteps    </span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">computeTemperature</span><span style="color: #D4D4D4">(T0, T1, heatDiffusionCoefficient, dt, dx, numberOfPoints, numberOfTimeSteps);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> endTime = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">high_resolution_clock</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">now</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> duration = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">duration_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">chrono</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">milliseconds</span><span style="color: #D4D4D4">&gt;(endTime - startTime);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Executation time: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #9CDCFE">duration</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">count</span><span style="color: #D4D4D4">()) / </span><span style="color: #B5CEA8">1000</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #CE9178">&quot; seconds&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // compute error</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> error = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        error += </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">abs</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; - </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    error /= numberOfPoints;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Error: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; error &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // output results</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> finalTimeString = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">to_string</span><span style="color: #D4D4D4">(finalTime);</span></span>
<span class="line"><span style="color: #D4D4D4">    finalTimeString = </span><span style="color: #9CDCFE">finalTimeString</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">substr</span><span style="color: #D4D4D4">(</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #9CDCFE">finalTimeString</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(</span><span style="color: #CE9178">&quot;.&quot;</span><span style="color: #D4D4D4">));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::string fileName = </span><span style="color: #CE9178">&quot;results_CUDA_&quot;</span><span style="color: #D4D4D4"> + finalTimeString + </span><span style="color: #CE9178">&quot;.csv&quot;</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::ofstream </span><span style="color: #DCDCAA">file</span><span style="color: #D4D4D4">(fileName);</span></span>
<span class="line"><span style="color: #D4D4D4">    file &lt;&lt; </span><span style="color: #CE9178">&quot;x,T&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        file &lt;&lt; </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93; &lt;&lt; </span><span style="color: #CE9178">&quot;, &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #9CDCFE">file</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">close</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span>

<!-- wp:paragraph -->
<p><span class="line"></span></code></pre></div></p>
<!-- /wp:paragraph -->

<!-- /wp:kevinbatdorf/code-block-pro -->
<!-- wp:paragraph -->
<p>Here are additional explanations:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li><strong>Line 7</strong>: First, we need to tell the compiler that we want to use CUDA. We do that by including the CUDA runtime header file.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 10-11</strong>: We have to forward declare a function we are going to use later. We need to do this here because I mentioned that we have to put the GPU code into a separate file. Later in this file, we call this function, but if it hasn't been declared before, the compiler doesn't know how to call this function and terminates the compilation. Normally, we would put forward declaration into separate header files (after all, that is the only point of having header files in the first place), but in this simple example, I am just forward declaring this function before the start of the <code>main()</code> function so that the compiler is aware that this function exists somewhere. It doesn't need to know where it is. At compile time, this is only important during the linking stage of the compilation process, where function calls are matched with function declarations, which may be in separate files.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 16-21</strong>: We perform a check here to make sure that we run this code on a machine that has a CUDA-capable GPU in the first place. If you are trying to run this code on a PC without an Nvidia GPU, or no GPU at all, then this code will find that there is no CUDA-capable device on your machine and exit the execution. On line 16, we check how many GPUs we have available. On a consumer PC, you would typically have 1, but on a cluster, you may have more than 1. Getting other GPUs to communicate with each other isn't straightforward. We need to understand MPI first, which we will talk about in the next section.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 24-29</strong>: Now that we know that there is at least one CUDA-capable GPU, we check which GPU we have and assign it a device ID.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 32-36</strong>: Using this device ID, we can now query the properties of this GPU and print some of them to the screen, like the name of the GPU and its compute capabilities. Think of the compute capabilities as the CUDA standard. With each new standard (compute capability) comes additional functionality that our GPUs can do. Newer GPUs will have higher compute capabilities and can do more, and so we need to make sure that we use CUDA syntax that is supported by our GPU. Using newer features in our CUDA code may work on newer GPUs but fail on older models. For this reason, I am printing this version here, as this is a property we also have to tell the <code>nvcc</code> compiler later (I'll get to that).

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 74</strong>: The entire time loop has now gone and is replaced by a single function called <code>computeTemperature(...)</code>. This is the function for which we had to provide a forward declaration on lines 10-11.

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>You see, the CPU side hasn't really changed all that much. I have included some safeguarding by ensuring that a GPU is actually available, but apart from that, other than including the required header file, nothing has changed, really. So, let us look at the <code>*.cu</code> file now, which houses all of the CUDA code:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#include \u0026lt;iostream\u003e\n#include \u0026lt;vector\u003e\n#include \u0026lt;cuda_runtime.h\u003e\n\n__global__ void updateTemperature(double *d_T0, double *d_T1, int numberOfPoints) {\n    // give each visiting thread a unique ID\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n    \n    // update the temperature array as long as the thread ID is within the size of the array itself \n    if (i \u0026lt; numberOfPoints) {\n        d_T0[i] = d_T1[i];\n    }\n}\n\n__global__ void computeTemperatureAtNextTimeLevel(double *d_T0, double *d_T1, double CFL, int numberOfPoints) {\n    \n    // give each visiting thread a unique ID\n    int i = blockIdx.x * blockDim.x + threadIdx.x;\n      \n    // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\n    if (i \u003e 0 \u0026amp;\u0026amp; i \u0026lt; numberOfPoints - 1) {\n        d_T1[i] = d_T0[i] + CFL * (d_T0[i + 1] - 2 * d_T0[i] + d_T0[i - 1]);\n    }\n}\n\nvoid computeTemperature(std::vector\u0026lt;double\u003e \u0026amp;T0, std::vector\u0026lt;double\u003e \u0026amp;T1, double heatDiffusionCoefficient, double dt,\n    double dx, int numberOfPoints, int numberOfTimeSteps) {\n    \n    // calculate the number of threads and block required to launch a CUDA kernel\n    int threadsPerBlock = 256;\n    int numberOfBlocks = static_cast\u0026lt;int\u003e(numberOfPoints / threadsPerBlock) + 1;\n    \n    // compute the CFL number, to pass less data to the kernel\n    double CFL = heatDiffusionCoefficient * dt / (dx * dx);\n\n    // create pointers that will be allocated on the GPU and mirror the data on the CPU\n    double *d_T0 = nullptr;\n    double *d_T1 = nullptr;\n\n    // allocate memory on the GPU for the previously generated pointers\n    cudaMalloc(\u0026amp;d_T0, numberOfPoints * sizeof(double));\n    cudaMalloc(\u0026amp;d_T1, numberOfPoints * sizeof(double));\n\n    // copy data from the CPU to the GPU\n    cudaMemcpy(d_T0, T0.data(), numberOfPoints * sizeof(double), cudaMemcpyHostToDevice);\n    cudaMemcpy(d_T1, T1.data(), numberOfPoints * sizeof(double), cudaMemcpyHostToDevice);\n\n    // loop over time\n    for (int t = 0; t \u0026lt; numberOfTimeSteps; ++t) {\n        // update temperature array\n        updateTemperature\u0026lt;\u0026lt;\u0026lt;numberOfBlocks, threadsPerBlock\u003e\u003e\u003e(d_T0, d_T1, numberOfPoints);\n\n        // compute the solution at T^n+1\n        computeTemperatureAtNextTimeLevel\u0026lt;\u0026lt;\u0026lt;numberOfBlocks, threadsPerBlock\u003e\u003e\u003e\n            (d_T0, d_T1, CFL, numberOfPoints);\n    }\n\n    // copy temperature data back into temperature array on the host (CPU memory)\n    cudaMemcpy(T0.data(), d_T0, numberOfPoints * sizeof(double), cudaMemcpyDeviceToHost);\n    cudaMemcpy(T1.data(), d_T1, numberOfPoints * sizeof(double), cudaMemcpyDeviceToHost);\n\n    // be a good citizen and free up memory after you are done\n    cudaFree(d_T0);\n    cudaFree(d_T1);\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;cuda_runtime.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e__global__ \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eupdateTemperature\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e *d_T0, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e *d_T1, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfPoints) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // give each visiting thread a unique ID\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eblockIdx\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eblockDim\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ethreadIdx\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // update the temperature array as long as the thread ID is within the size of the array itself \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (i \u0026lt; numberOfPoints) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ed_T0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ed_T1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e__global__ \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecomputeTemperatureAtNextTimeLevel\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e *d_T0, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e *d_T1, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e CFL, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfPoints) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // give each visiting thread a unique ID\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eblockIdx\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eblockDim\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ethreadIdx\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (i \u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026amp;\u0026amp; i \u0026lt; numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ed_T1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ed_T0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + CFL * (\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ed_T0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ed_T0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ed_T0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003evoid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecomputeTemperature\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003evector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eheatDiffusionCoefficient\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edt\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e,\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edx\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfPoints\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003enumberOfTimeSteps\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // calculate the number of threads and block required to launch a CUDA kernel\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e threadsPerBlock = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e256\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfBlocks = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(numberOfPoints / threadsPerBlock) + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // compute the CFL number, to pass less data to the kernel\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e CFL = heatDiffusionCoefficient * dt / (dx * dx);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // create pointers that will be allocated on the GPU and mirror the data on the CPU\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e *d_T0 = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003enullptr\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e *d_T1 = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003enullptr\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // allocate memory on the GPU for the previously generated pointers\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaMalloc\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;d_T0, numberOfPoints * \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003esizeof\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaMalloc\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;d_T1, numberOfPoints * \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003esizeof\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // copy data from the CPU to the GPU\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaMemcpy\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(d_T0, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003edata\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), numberOfPoints * \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003esizeof\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e), cudaMemcpyHostToDevice);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaMemcpy\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(d_T1, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003edata\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), numberOfPoints * \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003esizeof\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e), cudaMemcpyHostToDevice);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // loop over time\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e t = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; t \u0026lt; numberOfTimeSteps; ++t) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // update temperature array\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        updateTemperature\u0026lt;\u0026lt;\u0026lt;numberOfBlocks, threadsPerBlock\u0026gt;\u0026gt;\u0026gt;(d_T0, d_T1, numberOfPoints);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // compute the solution at T^n+1\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        computeTemperatureAtNextTimeLevel\u0026lt;\u0026lt;\u0026lt;numberOfBlocks, threadsPerBlock\u0026gt;\u0026gt;\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            (d_T0, d_T1, CFL, numberOfPoints);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // copy temperature data back into temperature array on the host (CPU memory)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaMemcpy\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003edata\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), d_T0, numberOfPoints * \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003esizeof\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e), cudaMemcpyDeviceToHost);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaMemcpy\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003edata\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), d_T1, numberOfPoints * \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003esizeof\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e), cudaMemcpyDeviceToHost);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // be a good citizen and free up memory after you are done\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaFree\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(d_T0);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecudaFree\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(d_T1);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":65,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>#include &lt;iostream>
#include &lt;vector>
#include &lt;cuda_runtime.h>

__global__ void updateTemperature(double *d_T0, double *d_T1, int numberOfPoints) {
    // give each visiting thread a unique ID
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    
    // update the temperature array as long as the thread ID is within the size of the array itself 
    if (i &lt; numberOfPoints) {
        d_T0&#91;i&#93; = d_T1&#91;i&#93;;
    }
}

__global__ void computeTemperatureAtNextTimeLevel(double *d_T0, double *d_T1, double CFL, int numberOfPoints) {
    
    // give each visiting thread a unique ID
    int i = blockIdx.x * blockDim.x + threadIdx.x;
      
    // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space
    if (i > 0 &amp;&amp; i &lt; numberOfPoints - 1) {
        d_T1&#91;i&#93; = d_T0&#91;i&#93; + CFL * (d_T0&#91;i + 1&#93; - 2 * d_T0&#91;i&#93; + d_T0&#91;i - 1&#93;);
    }
}

void computeTemperature(std::vector&lt;double> &amp;T0, std::vector&lt;double> &amp;T1, double heatDiffusionCoefficient, double dt,
    double dx, int numberOfPoints, int numberOfTimeSteps) {
    
    // calculate the number of threads and block required to launch a CUDA kernel
    int threadsPerBlock = 256;
    int numberOfBlocks = static_cast&lt;int>(numberOfPoints / threadsPerBlock) + 1;
    
    // compute the CFL number, to pass less data to the kernel
    double CFL = heatDiffusionCoefficient * dt / (dx * dx);

    // create pointers that will be allocated on the GPU and mirror the data on the CPU
    double *d_T0 = nullptr;
    double *d_T1 = nullptr;

    // allocate memory on the GPU for the previously generated pointers
    cudaMalloc(&amp;d_T0, numberOfPoints * sizeof(double));
    cudaMalloc(&amp;d_T1, numberOfPoints * sizeof(double));

    // copy data from the CPU to the GPU
    cudaMemcpy(d_T0, T0.data(), numberOfPoints * sizeof(double), cudaMemcpyHostToDevice);
    cudaMemcpy(d_T1, T1.data(), numberOfPoints * sizeof(double), cudaMemcpyHostToDevice);

    // loop over time
    for (int t = 0; t &lt; numberOfTimeSteps; ++t) {
        // update temperature array
        updateTemperature&lt;&lt;&lt;numberOfBlocks, threadsPerBlock>>>(d_T0, d_T1, numberOfPoints);

        // compute the solution at T^n+1
        computeTemperatureAtNextTimeLevel&lt;&lt;&lt;numberOfBlocks, threadsPerBlock>>>
            (d_T0, d_T1, CFL, numberOfPoints);
    }

    // copy temperature data back into temperature array on the host (CPU memory)
    cudaMemcpy(T0.data(), d_T0, numberOfPoints * sizeof(double), cudaMemcpyDeviceToHost);
    cudaMemcpy(T1.data(), d_T1, numberOfPoints * sizeof(double), cudaMemcpyDeviceToHost);

    // be a good citizen and free up memory after you are done
    cudaFree(d_T0);
    cudaFree(d_T1);
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;iostream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;vector&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;cuda_runtime.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">__global__ </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">updateTemperature</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> *d_T0, </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> *d_T1, </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfPoints) {</span></span>
<span class="line"><span style="color: #6A9955">    // give each visiting thread a unique ID</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #9CDCFE">blockIdx</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">blockDim</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4"> + </span><span style="color: #9CDCFE">threadIdx</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // update the temperature array as long as the thread ID is within the size of the array itself </span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (i &lt; numberOfPoints) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">d_T0</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">d_T1</span><span style="color: #D4D4D4">&#91;i&#93;;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">__global__ </span><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">computeTemperatureAtNextTimeLevel</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> *d_T0, </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> *d_T1, </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> CFL, </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfPoints) {</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // give each visiting thread a unique ID</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #9CDCFE">blockIdx</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">blockDim</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4"> + </span><span style="color: #9CDCFE">threadIdx</span><span style="color: #D4D4D4">.</span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span></span>
<span class="line"><span style="color: #6A9955">    // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (i &gt; </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4"> &amp;&amp; i &lt; numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">d_T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">d_T0</span><span style="color: #D4D4D4">&#91;i&#93; + CFL * (</span><span style="color: #9CDCFE">d_T0</span><span style="color: #D4D4D4">&#91;i + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; - </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">d_T0</span><span style="color: #D4D4D4">&#91;i&#93; + </span><span style="color: #9CDCFE">d_T0</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">void</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">computeTemperature</span><span style="color: #D4D4D4">(</span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #569CD6">&amp;</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">, </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #4EC9B0">vector</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #569CD6">&amp;</span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">heatDiffusionCoefficient</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">dt</span><span style="color: #D4D4D4">,</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">dx</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">numberOfPoints</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">numberOfTimeSteps</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // calculate the number of threads and block required to launch a CUDA kernel</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> threadsPerBlock = </span><span style="color: #B5CEA8">256</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfBlocks = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;(numberOfPoints / threadsPerBlock) + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // compute the CFL number, to pass less data to the kernel</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> CFL = heatDiffusionCoefficient * dt / (dx * dx);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // create pointers that will be allocated on the GPU and mirror the data on the CPU</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> *d_T0 = </span><span style="color: #569CD6">nullptr</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> *d_T1 = </span><span style="color: #569CD6">nullptr</span><span style="color: #D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // allocate memory on the GPU for the previously generated pointers</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">cudaMalloc</span><span style="color: #D4D4D4">(&amp;d_T0, numberOfPoints * </span><span style="color: #569CD6">sizeof</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">cudaMalloc</span><span style="color: #D4D4D4">(&amp;d_T1, numberOfPoints * </span><span style="color: #569CD6">sizeof</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">));</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // copy data from the CPU to the GPU</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">cudaMemcpy</span><span style="color: #D4D4D4">(d_T0, </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">data</span><span style="color: #D4D4D4">(), numberOfPoints * </span><span style="color: #569CD6">sizeof</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">), cudaMemcpyHostToDevice);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">cudaMemcpy</span><span style="color: #D4D4D4">(d_T1, </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">data</span><span style="color: #D4D4D4">(), numberOfPoints * </span><span style="color: #569CD6">sizeof</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">), cudaMemcpyHostToDevice);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // loop over time</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> t = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; t &lt; numberOfTimeSteps; ++t) {</span></span>
<span class="line"><span style="color: #6A9955">        // update temperature array</span></span>
<span class="line"><span style="color: #D4D4D4">        updateTemperature&lt;&lt;&lt;numberOfBlocks, threadsPerBlock&gt;&gt;&gt;(d_T0, d_T1, numberOfPoints);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">        // compute the solution at T^n+1</span></span>
<span class="line"><span style="color: #D4D4D4">        computeTemperatureAtNextTimeLevel&lt;&lt;&lt;numberOfBlocks, threadsPerBlock&gt;&gt;&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">            (d_T0, d_T1, CFL, numberOfPoints);</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // copy temperature data back into temperature array on the host (CPU memory)</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">cudaMemcpy</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">data</span><span style="color: #D4D4D4">(), d_T0, numberOfPoints * </span><span style="color: #569CD6">sizeof</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">), cudaMemcpyDeviceToHost);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">cudaMemcpy</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">data</span><span style="color: #D4D4D4">(), d_T1, numberOfPoints * </span><span style="color: #569CD6">sizeof</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">), cudaMemcpyDeviceToHost);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // be a good citizen and free up memory after you are done</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">cudaFree</span><span style="color: #D4D4D4">(d_T0);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">cudaFree</span><span style="color: #D4D4D4">(d_T1);</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Here is what is happening:</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol class="wp-block-list">

<!-- wp:list-item -->
<li><strong>Lines 26-65</strong>: This is the <code>computeTemperature(...)</code> function we have seen before. We can see that this is marked with a <code>void</code> statement, but we could have also been verbose here and marked it as <code>__host__ void</code>. In other words, this function runs on the CPU. Let's look through it in more detail:

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 30-31</strong>: We compute here the number of blocks dynamically and fix the number of threads for each block.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 37-38</strong>: We define a raw pointer here, which we initialise to a <code>nullptr</code>. These pointers will later represent the temperature arrays on the device (GPU). A common convention is to mark all fields that are copied over to the device (GPU) with a leading <code>d_</code> and I have followed that convention here.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 41-42</strong>: We now allocate memory on the GPU. Notice how we use <code>cudaMalloc()</code> here. In C++, we would use the <code>new</code> keyword if we wanted to allocate memory for raw pointers (but, thankfully, since the 2014 C++ syntax we have no longer a need to use raw pointers and can use smart pointers without and <code>new</code> memory allocation), but in C, we would use <code>malloc()</code> (Memory allocation). The syntax in <code>malloc()</code> and <code>cudaMalloc()</code> is the same, i.e. we state which pointer we want to allocate memory for, and then we say how much space we need. The space is expressed in units of bytes (this is what the <code>sizeof()</code> function returns), and that will depend on the number of elements we want to store, as well as the size per element in bytes.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 45-46</strong>: Now that we have allocated some memory on the CPU and the GPU, and we have initialised the data on the CPU, it is time to copy it onto the GPU. This is what we do with <code>cudaMemcpy()</code>, where the first argument is where we want to receive the data, the second argument is where we want the data to come from, the number of points to copy, and then the direction as the fourth argument. In this case, we copy from the CPU (host) to the GPU (device). <code>T0</code> and <code>T1</code> where defined as <code>std::vector<double></code>, but CUDA doesn't understand C++ syntax. It needs to have a raw pointer. C++ provides this for us by calling the <code>data()</code> member function of the <code>std::vector</code> class, and so we can use standard containers in C++ with CUDA, giving us at least some level of sanity.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 49-56</strong>: We execute the main time loop now and call two kernels here for each time step, with the precomputed number of blocks. First, we update the temperature on line 51 and then compute an updated solution on lines 54-55. We will look at both of these functions after finishing discussing this function.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 59-60</strong>: Once the computation is done, we copy data back to the CPU (host) using the same <code>cudaMemcpy()</code> function we saw before, but now we switch the first and second argument, and the fourth argument is telling us now that we go from device (GPU) to the host (CPU). Technically, we don't need <code>T0</code> anymore, so we could just copy <code>T1</code> as we only process that further on the CPU side (computing the error and then outputting the solution).

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 63-64</strong>: Don't forget, we use C-style syntax, so we do need to clean up after ourselves. This means any memory allocation needs to have a corresponding memory deallocation call. This is what <code>cudaFree()</code> does for us.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 5-13</strong>: This is the function that updates the temperature, which was called from the <code>computeTemperature(...)</code> function on line 51. This function is discussed below:

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 7</strong>: We need to get the current thread ID. We do that by checking the size of each block (each block has 256 threads, and that is what is stored in <code>blockDim.x</code>), and the <code>blockIdx.x</code> variable tells us which block is currently executing. <code>threadIdx.x</code> gives us a thread ID within each block, which, in our example, is between 0 and 255. If we launched our code with 1000 elements in <code>T1</code>, then <code>blockDim.x</code> would have been calculated as 4. <code>blockIdx.x</code> will be between 0-3 (4 blocks, starting with index 0), and in this way, we can have thread IDs from 0 all the way to 1023. But why the <code>.x</code> after all of these variables? This is where CUDA becomes more complicated. So far, we have only dealt with 1D grids and blocks, but they can be 3D as well. Yes, we can launch blocks arranged in a 3D grid, and then have threads arranged in a 3D block. Why do we have this? Well, this maps to different data types more naturally. If we have a matrix and want to operate on it in parallel, we can find separate thread IDs in x and y. If we work with a 3D mesh and we have [katex]i[/katex], [katex]j[/katex], [katex]k[/katex] indices, then we can find a thread ID in x, y, and z that maps into each variable [katex]i[/katex], [katex]j[/katex], [katex]k[/katex]. We use a 1D code here, so we can keep complexity low and just use a 1D indexing.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 10-12</strong>: As long as the thread ID is within the bounds of the temperature array, we simply copy the data from <code>d_T1</code> into <code>d_T0</code>. This is probably the simplest example of a parallel code execution.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 15-24</strong>: This function performs the actual temperature update, which was called on lines 54-55. Additional explanations are given below:

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 18</strong>: We have to find the thread ID first, and the same considerations given above hold here.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 21-23</strong>: We compute an updated temperature field here, and each thread is updating one part of the temperature array.

</li>
<!-- /wp:list-item -->
</ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Now, there are a few things to note here. First of all, notice how both the <code>updateTemperature()</code> and <code>computeTemperatureAtNextTimeLevel()</code> temperature are defined as <code>__global__</code> functions. On lines 49-56, we can call these functions inside a loop, potentially many, many times. Every time we do that, we have to spawn the kernel on the GPU, which will incur a small overhead.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It is similar to the discussion we had before when talking about the <code>#pragma omp parallel for</code> problem, i.e. we don't want to spawn a new parallel region for each time step. Here, we do just that, in fact, twice. On lines 51 and 54-55, we call two separate CUDA functions, and since we launch them from the CPU, there is a small overhead we have to pay.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, we could have also made the <code>updateTemperature()</code> function a device function, i.e. marked it with the <code>__device__</code> identifier, and then called it from the <code>computeTemperatureAtNextTimeLevel()</code> function. This would have halved the number of times we would need to spawn a new CUDA kernel, and that may as well come with computational gains. This is an easy optimisation we could do.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Also, note how we pass regular (host) variables to functions that run on the GPU. For example, on line 5, we pass in the <code>numberOfPoints</code> variable, which was declared on the CPU. For single quantities like this, we can just pass them to the function (kernel), and CUDA will copy them for us. Pointers, however, have to be explicitly allocated beforehand (like <code>d_T1</code>).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>OK, hopefully this all makes sense. Now, let's look at how we can compile this. The following code snippet shows which additional lines of code have to be added to the existing <code>CMakeLists.txt</code> file:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"# \u002d\u002d- CUDA code \u002d\u002d-\nenable_language(CUDA)\n# the CUDA_ARCHITECTURE sets the compute capability of your GPU\n# To figure out your compute capability, use the following steps:\n#   1. Run nvidia-smi in your terminal/power-shell\n#   2. Note down your GPU (e.g. NVIDIA RTX A2000)\n#   3. Check your compute capability for your GPU here: https://developer.nvidia.com/cuda-gpus\n#   4. Enter your compute capability here, removing the dot.\n#      For example, a compute capability of 8.6 becomes 86, 10.3 becomes 103, etc.\nset(CMAKE_CUDA_ARCHITECTURES 86)\nadd_executable(heat1DCUDA \u0022src/heat1DCUDA.cpp\u0022 \u0022src/heat1DCUDA.cu\u0022)\nfind_package(CUDAToolkit REQUIRED)\ntarget_link_libraries(heat1DCUDA PRIVATE CUDA::cudart)","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# \u002d\u002d- CUDA code \u002d\u002d-\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eenable_language\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(CUDA)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# the CUDA_ARCHITECTURE sets the compute capability of your GPU\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# To figure out your compute capability, use the following steps:\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e#   1. Run nvidia-smi in your terminal/power-shell\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e#   2. Note down your GPU (e.g. NVIDIA RTX A2000)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e#   3. Check your compute capability for your GPU here: https://developer.nvidia.com/cuda-gpus\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e#   4. Enter your compute capability here, removing the dot.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e#      For example, a compute capability of 8.6 becomes 86, 10.3 becomes 103, etc.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eset\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(CMAKE_CUDA_ARCHITECTURES 86)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eadd_executable\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(heat1DCUDA \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;src/heat1DCUDA.cpp\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;src/heat1DCUDA.cu\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efind_package\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(CUDAToolkit REQUIRED)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etarget_link_libraries\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(heat1DCUDA PRIVATE CUDA::cudart)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cmake","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":13,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly># --- CUDA code ---
enable_language(CUDA)
# the CUDA_ARCHITECTURE sets the compute capability of your GPU
# To figure out your compute capability, use the following steps:
#   1. Run nvidia-smi in your terminal/power-shell
#   2. Note down your GPU (e.g. NVIDIA RTX A2000)
#   3. Check your compute capability for your GPU here: https://developer.nvidia.com/cuda-gpus
#   4. Enter your compute capability here, removing the dot.
#      For example, a compute capability of 8.6 becomes 86, 10.3 becomes 103, etc.
set(CMAKE_CUDA_ARCHITECTURES 86)
add_executable(heat1DCUDA "src/heat1DCUDA.cpp" "src/heat1DCUDA.cu")
find_package(CUDAToolkit REQUIRED)
target_link_libraries(heat1DCUDA PRIVATE CUDA::cudart)</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #6A9955"># --- CUDA code ---</span></span>
<span class="line"><span style="color: #569CD6">enable_language</span><span style="color: #D4D4D4">(CUDA)</span></span>
<span class="line"><span style="color: #6A9955"># the CUDA_ARCHITECTURE sets the compute capability of your GPU</span></span>
<span class="line"><span style="color: #6A9955"># To figure out your compute capability, use the following steps:</span></span>
<span class="line"><span style="color: #6A9955">#   1. Run nvidia-smi in your terminal/power-shell</span></span>
<span class="line"><span style="color: #6A9955">#   2. Note down your GPU (e.g. NVIDIA RTX A2000)</span></span>
<span class="line"><span style="color: #6A9955">#   3. Check your compute capability for your GPU here: https://developer.nvidia.com/cuda-gpus</span></span>
<span class="line"><span style="color: #6A9955">#   4. Enter your compute capability here, removing the dot.</span></span>
<span class="line"><span style="color: #6A9955">#      For example, a compute capability of 8.6 becomes 86, 10.3 becomes 103, etc.</span></span>
<span class="line"><span style="color: #569CD6">set</span><span style="color: #D4D4D4">(CMAKE_CUDA_ARCHITECTURES 86)</span></span>
<span class="line"><span style="color: #569CD6">add_executable</span><span style="color: #D4D4D4">(heat1DCUDA </span><span style="color: #CE9178">&quot;src/heat1DCUDA.cpp&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">&quot;src/heat1DCUDA.cu&quot;</span><span style="color: #D4D4D4">)</span></span>
<span class="line"><span style="color: #569CD6">find_package</span><span style="color: #D4D4D4">(CUDAToolkit REQUIRED)</span></span>
<span class="line"><span style="color: #569CD6">target_link_libraries</span><span style="color: #D4D4D4">(heat1DCUDA PRIVATE CUDA::cudart)</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>First, we tell CMake that we want to use CUDA by using the <code>enable_language(CUDA)</code>. CMake treats CUDA as its own separate language, not an extension to C or C++. We already specified in the CMake file that we are using a C++ project here (this is defined under the <code>project</code> properties), now we are telling CMake that we want to also use CUDA as a second language. We are now bilingual.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Next, we have to tell the CUDA compiler what compute capability our GPU has. This is done by setting the <code>CMAKE_CUDA_ARCHITECTURES</code> variable. I have left instructions in the CMake code for how to obtain this before you launch your kernel. The compute capability is expressed as an integer, rather than a floating point number, so we simply remove the dot. In my case, my GPU supports compute capability 8.6, so I set 86.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now we can proceed as per usual, we create an executable which now depends on both the <code><em>.cpp</code> and <code></em>.cu</code> file, which we both pass to the executable. We then tell CMake that we need to have the CUDA Toolkit available, and then we link our executable against CUDA on the final line.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Unlike OpenMP, CUDA does not come with our compiler or system, and we have to manually install it. Thankfully, the installation is rather straightforward, and you can find the <a href="https://developer.nvidia.com/cuda-toolkit" target="_blank" rel="noopener" title="">download and instructions here</a>. You should also update your GPU drivers to the latest version to make sure your GPU supports the latest version of CUDA. If you don't, you'll likely see that CUDA won't find your GPU due to an outdated driver.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>After it is installed, your CMake project should be able to find CUDA, as well as your CUDA header files. If not, it is not in your <code>PATH</code> and you will need to add the installation location to your <code>PATH</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We compile and execute the code just like before, i.e. using:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"cmake -DCMAKE_BUILD_TYPE=Release ..","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecmake\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-DCMAKE_BUILD_TYPE=Release\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e..\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>cmake -DCMAKE_BUILD_TYPE=Release ..</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">cmake</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-DCMAKE_BUILD_TYPE=Release</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">..</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"cmake \u002d\u002dbuild . \u002d\u002dconfig Release","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecmake\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u002d\u002dbuild\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u002d\u002dconfig\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003eRelease\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>cmake --build . --config Release</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">cmake</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">--build</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">.</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">--config</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">Release</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>You can now, again, execute the solver using:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":".\\Release\\heat1DCUDA.exe 101 100","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\\Release\\heat1DCUDA.exe \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e101\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>.\Release\heat1DCUDA.exe 101 100</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">.</span><span style="color: #D4D4D4">\Release\heat1DCUDA.exe </span><span style="color: #B5CEA8">101</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">100</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>On UNIX, you may write something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"./Release/heat1DCUDA 101 100","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003e./Release/heat1DCUDA\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e101\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>./Release/heat1DCUDA 101 100</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">./Release/heat1DCUDA</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">101</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">100</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Notice that we don't have to say how many threads we want to use. We could make this a command-line argument, but as I said before, we can typically leave this to a fixed value and then, perhaps during an optimisation and benchmark test, determine the best value for our application and then leave it at that. If we give a user the chance to make a choice here that would cripple our performance, they would blame us and our inefficient code for the poor performance and not their incorrect usage, so it is better if we keep control over it.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-messenger-passing-interfacempi">Messenger Passing Interface (MPI)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Finally, we have made it to the Message Passing Interface (MPI). We saw that shared memory approaches, such as OpenMP, provide a pretty easy way to parallelise our code. We tell OpenMP that we want to parallelise some section of our code with the <code>#pragma omp parallel { ... }</code> directive, and then anything that is enclosed in the curly braces will be executed in parallel (the curly braces need to be on a new line).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The reason why shared memory approaches are rather straightforward is that we don't have to worry about transferring memory between different processors. All processors (or threads in OpenMP terminology) can access the same memory location; we just have to make sure they access it in an orderly fashion so as to avoid a race condition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With distributed memory approaches, such as MPI, we first perform a domain decomposition so that each processor will work on its own private memory, which includes a private sub-domain that each processor receives from the domain decomposition. Take the following schematic, as an example:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"500px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/inter_processor_communication_MPI.png" alt="A grid that is split in half into two sub-domains. At their interface, we see two cells which are exchanging information. On the left processor, we have cell C1 exchange information with cell C4 on the right processor, and cell C3 is exchanging data with cell C6 on the right processor. " class="wp-image-5550" style="width:500px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>If this is the situation we have with MPI, i.e. we use two processors, and we have a domain split into two halves, where each processor is working on their own subdomain, we will need to exchange data at the interface, usually to compute our gradients, as we have seen previously as well. So now, we use MPI (the hint is in the name, i.e. Message Passing Interface) to pass data (messages) across the inter-processor boundaries (interface).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are different ways in which we can achieve this, and we need to differentiate between two different types of message passing (memory transfer) approaches:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Blocking vs. non-blocking communications

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Collective vs. point-to-point (non-collective) communications.

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Let's start with blocking communications. I recently came back home after spending 5 months abroad. Our neighbour was looking after our house, so it was still in good condition. However, as soon as I turned the electricity on, the internet was not working. Try as I might, I was not able to get it back online.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, I called my internet provider, and they did some checks on their end but couldn't figure out what was wrong. The lights on my router were not supposed to light up in the way they were, hinting at some deeper issue we would not be able to solve right then, and so the person booked an engineer to come round and have a look. During this call, the person on the other end was doing some checks, and whenever she was doing that, she would say those famous words we all love to hear: <em>Please hold</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>During those brief 4-bar music-infused intermissions, when we are instructed to hold the line, what do you do? Leave the phone, go out and do the grocery shopping, or are you waiting with your phone glued to you, waiting for the other person to release you from 4 bar music hell? Probably the latter. You may do some small tasks like putting on the kettle, but you wouldn't start to do anything more substantial.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>(Oh, and if you wondered: Someone performed maintenance on the fibre optic cables in our estate and cut the cable to our house (by accident?!). The engineer who had to come out confirmed this, put a new cable in, and I was back online. I love the fact that someone cut the cables and then thought "Ah, fuck it, not my problem" ...)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is an example of a blocking communication. The other person has told us to wait for them, and we do. We wait for them to finish their task, and then we can, together, move on to the next task. In MPI, we do have blocking communications as well, where we tell two processors to collectively perform a communication and only continue with the computation once the communication has been completed.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Instead of blocking communications, we, as a society, have collectively embraced non-blocking communications. Emails, instant text messaging, chats, and Microsoft Teams (Microsoft is <em>always</em> in a category of its own!) are all examples of non-blocking communications. After you have made the effort of locating my email address at the bottom of this page and telling me how wrong I am about Imperial College, you go on about your day and don't wait until I respond.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>After some time, I may or may not respond, and once I do, you can choose to read the response immediately, or you can take your time as well. In MPI, non-blocking communications mean we initiate the data transfer but then immediately go on to perform some computation. We are essentially trying to overlap computations with communications and hope that the communication has finished (all data has been transferred) after we are done computing the solution on our private sub-domain.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can mix and match blocking and non-blocking communications. A typical pattern within a solution update is as follows:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Perform a non-blocking send operation at the beginning of the time step, where data for adjacent processors is sent, which they will need at some point.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Perform computation on private sub-domain, excluding points directly attached to the inter-processor boundary, i.e. those that require information from adjacent processors.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Perform a blocking receive operation, where we ensure that all data has been sent and received after we finish the receive operation.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Update the cells near the inter-processor boundary, using the data we just passed around.

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>We will see this pattern in our 1D heat code in just a second. Before we do that, I also want to talk about collective and point-to-point communication. Imagine that you are working in a group of 5 people. You may have weekly meetings, where you come together as a group. These group meetings would be classified as a collective communication effort, i.e. all of you have to be present before you can start.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This means that if you are expecting everyone to attend, but only 4 of you are present at the specified start time, while the fifth person is sending apologetic text messages that they will run 15 minutes late, but they will definitely attend, you are left waiting 15 minutes. In that time, you may distract yourself with 15 minutes of doomscrolling, but you are not able to do anything productive (again, you wouldn't leave to do your grocery shopping at that point).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In collective communications, we have to wait until everyone is available and has finished their task before we can continue. In our group example, you can only start with your group meeting once the fifth person has joined. In the context of MPI, a collective communication is one where each processor has to participate. If only one processor is not showing up, or coming late to the party because they were busy doing some computation, all other processors have to wait.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is very costly, and it will quickly create a communication bottleneck for us. There are a few collective communications we need to perform, so we really want to make sure that we have good load balancing. If we don't, then we will have processors waiting a lot of the time, which will destroy our parallel performance.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, when we compute the residual, we do that on each processor. But we need the information on all residuals on each sub-domain to compute the global residual for the user. In this case, we need to perform a collective communication at each time step. One optimisation that we can do here is to perform the residual exchange only every N iterations, where N may be 5 or 10. This can help to reduce the communication overhead of the parallel computation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The best way to improve the performance of collective operations, though, is to make sure that each processor has an equal load, and the communications are otherwise minimised. If every processor comes to the collective communication point at the same time, then these communications aren't that problematic.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The opposite of collective communications is point-to-point communications, which happens between two processors only. In the example we saw above with the two processors, we saw that we have a point-to-point communication between processor 0 and 1, which was both non-blocking (sending data) and blocking (receiving data).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With that out of the way, we are not ready to look at the MPI code. There will be quite a bit more code now due to MPI, and that is just the nature of it. There is quite a bit of boilerplate code we have to write because we are in charge of exchanging data. While this means that we have to write more code, it also provides us with the possibility to fine-tune and optimise our code. We get more control than, say, in OpenMP, which is great for getting the last bit of performance out of the code.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As we have done in the previous examples as well, I'll give you the code first, and then we can look at some detailed explanations below the code. Try to read it first, though, and see what is happening before looking at the explanations.</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#include \u0026lt;iostream\u003e\n#include \u0026lt;vector\u003e\n#include \u0026lt;chrono\u003e\n#include \u0026lt;fstream\u003e\n#include \u0026lt;string\u003e\n\n#include \u0026lt;mpi.h\u003e\n\nint main(int argc, char* argv[]) {\n    // Initialise the MPI environment\n    MPI_Init(\u0026amp;argc, \u0026amp;argv);\n    \n    // Get the number of processes\n    int worldSize;\n    MPI_Comm_size(MPI_COMM_WORLD, \u0026amp;worldSize);\n    \n    // Get the current processor ID (rank) of the process\n    int rank;\n    MPI_Comm_rank(MPI_COMM_WORLD, \u0026amp;rank);\n\n    // input parameters\n    const int numberOfPoints = static_cast\u0026lt;int\u003e(atoi(argv[1]));\n    const double leftBoundary = 0.0;\n    const double rightBoundary = 1.0;\n    const double CFL = 0.25;\n    const double heatDiffusionCoefficient = 0.01;\n    const double finalTime = static_cast\u0026lt;double\u003e(atof(argv[2]));\n    \n    // computed input paramters\n    const double dx = 1.0 / (numberOfPoints - 1);\n    const double dt = CFL * dx * dx / heatDiffusionCoefficient;\n    const int numberOfTimeSteps = static_cast\u0026lt;int\u003e(finalTime / dt);\n\n    // Domain decomposition\n    int pointsPerProcess = numberOfPoints / worldSize;\n\n    if (rank == 0) {\n        std::cout \u0026lt;\u0026lt; \u0022Number of processes: \u0022 \u0026lt;\u0026lt; worldSize \u0026lt;\u0026lt; std::endl;\n        std::cout \u0026lt;\u0026lt; \u0022Number of points per process: \u0022 \u0026lt;\u0026lt; pointsPerProcess \u0026lt;\u0026lt; std::endl;\n    }\n    MPI_Barrier(MPI_COMM_WORLD);\n\n    // check that we have a valid decomposition. If we don't, then add additional points to the last processor\n    int pointsNotUsed = 0;\n    if (rank == worldSize - 1) {\n        const int totalPoints = worldSize * pointsPerProcess;\n        pointsNotUsed = numberOfPoints - totalPoints;\n        pointsPerProcess += pointsNotUsed;\n        if (pointsNotUsed \u003e 0) {\n            std::cout \u0026lt;\u0026lt; \u0022Adding \u0022 \u0026lt;\u0026lt; pointsNotUsed \u0026lt;\u0026lt; \u0022 point(s) to last processor\u0022 \u0026lt;\u0026lt; std::endl;\n        }\n    }\n\n    // allocate memory for field arrays\n    std::vector\u0026lt;double\u003e T0(pointsPerProcess); // T at time n\n    std::vector\u0026lt;double\u003e T1(pointsPerProcess); // T at time n+1\n    std::vector\u0026lt;double\u003e x(pointsPerProcess);\n\n    // create mesh\n    for (int i = 0; i \u0026lt; pointsPerProcess; ++i) {\n        x[i] = dx * (i + rank * (pointsPerProcess - pointsNotUsed));\n    }\n\n    // initialise field arrays\n    for (int i = 0; i \u0026lt; pointsPerProcess; ++i) {\n        T0[i] = 0.0;\n        T1[i] = 0.0;\n    }\n\n    // set boundary conditions (important, set it for T1, not T0)\n    // only set it for left-most processor (rank == 0) and right-most processor (rank == worldSize - 1)\n    if (rank == 0) {\n        T1[0] = leftBoundary;\n    }\n    if (rank == worldSize - 1) {\n        T1[pointsPerProcess - 1] = rightBoundary;\n    }\n\n    // helper variables for MPI\n    std::vector\u0026lt;MPI_Request\u003e requests;\n    double leftBoundaryValue = 0.0;\n    double rightBoundaryValue = 0.0;\n    \n    double startTime = MPI_Wtime();\n    // loop over all timesteps\n    for (int t = 0; t \u0026lt; numberOfTimeSteps; ++t) {\n        T0 = T1;\n\n        // send data to the right processor (except for the last processor, as there is no processor to the right)\n        if (rank \u0026lt; worldSize - 1) {\n            requests.push_back(MPI_Request{});\n            MPI_Isend(\u0026amp;T0[pointsPerProcess - 1], 1, MPI_DOUBLE, rank + 1, 100 + rank, MPI_COMM_WORLD, \u0026amp;requests.back());\n        }\n        \n        // send data to the left processor (except for the first processor, as there is no processor to the left)\n        if (rank \u003e 0) {\n            requests.push_back(MPI_Request{});\n            MPI_Isend(\u0026amp;T0[0], 1, MPI_DOUBLE, rank - 1, 200 + rank, MPI_COMM_WORLD, \u0026amp;requests.back());\n        }\n        \n        // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\n        for (int i = 1; i \u0026lt; pointsPerProcess - 1; ++i) {\n            T1[i] = T0[i] + heatDiffusionCoefficient * dt / (dx * dx) * (T0[i + 1] - 2 * T0[i] + T0[i - 1]);\n        }\n        \n        // before we try to receive data, we should make sure that the send requests have completed\n        MPI_Waitall(static_cast\u0026lt;int\u003e(requests.size()), requests.data(), MPI_STATUSES_IGNORE);\n        \n        // receive data from the left processor (except for the first processor, as there is no processor to the left)\n        if (rank \u003e 0) {\n            MPI_Recv(\u0026amp;leftBoundaryValue, 1, MPI_DOUBLE, rank - 1, 100 + rank - 1, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        \n        // receive data from the right processor (except for the last processor, as there is no processor to the right)\n        if (rank \u0026lt; worldSize - 1) {\n            MPI_Recv(\u0026amp;rightBoundaryValue, 1, MPI_DOUBLE, rank + 1, 200 + rank + 1, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n        }\n        \n        // now use the received values to compute the values at the inter-processor boundaries\n        if (rank \u003e 0) {\n            int i = 0;\n            T1[i] = T0[i] + heatDiffusionCoefficient * dt / (dx * dx) * (T0[i + 1] - 2 * T0[i] + leftBoundaryValue);\n        }\n        \n        if (rank \u0026lt; worldSize - 1) {\n            int i = pointsPerProcess - 1;\n            T1[i] = T0[i] + heatDiffusionCoefficient * dt / (dx * dx) * (rightBoundaryValue - 2 * T0[i] + T0[i - 1]);\n        }\n    }\n    double endTime = MPI_Wtime();\n    double duration = endTime - startTime;\n    if (rank == 0) {\n        std::cout \u0026lt;\u0026lt; \u0022Executation time: \u0022 \u0026lt;\u0026lt; duration \u0026lt;\u0026lt; \u0022 seconds\u0022 \u0026lt;\u0026lt; std::endl;\n    }\n\n    // compute error\n    double error = 0.0;\n    for (int i = 0; i \u0026lt; pointsPerProcess; ++i) {\n        error += std::abs(T1[i] - x[i]);\n    }\n    error /= numberOfPoints;\n\n    // reduce error over all processes into processor 0 (the root processor)\n    int root = 0;\n    double globalError = 0.0;\n    MPI_Reduce(\u0026amp;error, \u0026amp;globalError, 1, MPI_DOUBLE, MPI_SUM, root, MPI_COMM_WORLD);\n\n    // print error on processor 0 (the only processor that knows the global error)\n    if (rank == root) {\n        std::cout \u0026lt;\u0026lt; \u0022Error: \u0022 \u0026lt;\u0026lt; globalError \u0026lt;\u0026lt; std::endl;\n    }\n\n    // reconstruct the global temperature and coordinate array so that it can be written to disk by just one processor\n    std::vector\u0026lt;double\u003e globalTemperature;\n    std::vector\u0026lt;double\u003e globalX;\n    if (rank == root) {\n        globalTemperature.resize(numberOfPoints);\n        globalX.resize(numberOfPoints);\n    } \n    \n    // store the number of points that are send by each processor in an array\n    std::vector\u0026lt;int\u003e pointsPerProcessArray(worldSize);\n    MPI_Gather(\u0026amp;pointsPerProcess, 1, MPI_INT, \u0026amp;pointsPerProcessArray[rank], 1, MPI_INT, root, MPI_COMM_WORLD);\n\n    // store the offset/displacement, which states the starting point into the global array for each processor\n    // for example, with 3 processors, where processor 0 send 3 elements, processor 1 sends 5 elements, and processor 2\n    // sends 1 element, the offset/displacement array is [0, 3, 8]. Processor 0 will write at location 0 in the global\n    // array, processor 1 will write at location 3 in the global array, and processor 2 will write at location 8 in the\n    // global array\n    std::vector\u0026lt;int\u003e offsets(worldSize);\n    if (rank == root) {\n        offsets[0] = 0;\n        for (int i = 1; i \u0026lt; worldSize; ++i) {\n            offsets[i] = offsets[i - 1] + pointsPerProcessArray[i - 1];\n        }\n    }\n\n    // start gathering all data into the root processor\n    MPI_Gatherv(\u0026amp;T1[0], pointsPerProcess, MPI_DOUBLE, \u0026amp;globalTemperature[0], \u0026amp;pointsPerProcessArray[0], \u0026amp;offsets[0], MPI_DOUBLE, root, MPI_COMM_WORLD);\n    MPI_Gatherv(\u0026amp;x[0], pointsPerProcess, MPI_DOUBLE, \u0026amp;globalX[0], \u0026amp;pointsPerProcessArray[0], \u0026amp;offsets[0], MPI_DOUBLE, root, MPI_COMM_WORLD);\n\n    // output results on the master processor\n    if (rank == root) {\n        auto finalTimeString = std::to_string(finalTime);\n        finalTimeString = finalTimeString.substr(0, finalTimeString.find(\u0022.\u0022));\n        std::string fileName = \u0022results_MPI_\u0022 + finalTimeString + \u0022.csv\u0022;\n        std::ofstream file(fileName);\n        file \u0026lt;\u0026lt; \u0022x,T\u0022 \u0026lt;\u0026lt; std::endl;\n        for (int i = 0; i \u0026lt; numberOfPoints; ++i) {\n            file \u0026lt;\u0026lt; globalX[i] \u0026lt;\u0026lt; \u0022, \u0022 \u0026lt;\u0026lt; globalTemperature[i] \u0026lt;\u0026lt; std::endl;\n        }\n        file.close();\n    }\n\n    // Finalise the MPI environment.\n    MPI_Finalize();\n\n    return 0;\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;vector\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;chrono\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;fstream\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;mpi.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emain\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargc\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003echar*\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e[]) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // Initialise the MPI environment\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Init\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;argc, \u0026amp;argv);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // Get the number of processes\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e worldSize;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Comm_size\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(MPI_COMM_WORLD, \u0026amp;worldSize);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // Get the current processor ID (rank) of the process\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e rank;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Comm_rank\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(MPI_COMM_WORLD, \u0026amp;rank);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // input parameters\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfPoints = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eatoi\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e leftBoundary = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e rightBoundary = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e CFL = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.25\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e heatDiffusionCoefficient = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.01\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e finalTime = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eatof\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eargv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // computed input paramters\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e dx = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e / (numberOfPoints - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e dt = CFL * dx * dx / heatDiffusionCoefficient;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e numberOfTimeSteps = \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(finalTime / dt);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // Domain decomposition\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e pointsPerProcess = numberOfPoints / worldSize;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank == \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Number of processes: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; worldSize \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Number of points per process: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; pointsPerProcess \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Barrier\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(MPI_COMM_WORLD);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // check that we have a valid decomposition. If we don\u0026#39;t, then add additional points to the last processor\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e pointsNotUsed = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank == worldSize - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003econst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e totalPoints = worldSize * pointsPerProcess;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        pointsNotUsed = numberOfPoints - totalPoints;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        pointsPerProcess += pointsNotUsed;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (pointsNotUsed \u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Adding \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; pointsNotUsed \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot; point(s) to last processor\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // allocate memory for field arrays\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(pointsPerProcess);\u003c/span\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e // T at time n\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(pointsPerProcess);\u003c/span\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e // T at time n+1\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(pointsPerProcess);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // create mesh\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; pointsPerProcess; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = dx * (i + rank * (pointsPerProcess - pointsNotUsed));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // initialise field arrays\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; pointsPerProcess; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // set boundary conditions (important, set it for T1, not T0)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // only set it for left-most processor (rank == 0) and right-most processor (rank == worldSize - 1)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank == \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; = leftBoundary;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank == worldSize - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;pointsPerProcess - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; = rightBoundary;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // helper variables for MPI\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;MPI_Request\u0026gt; requests;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e leftBoundaryValue = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e rightBoundaryValue = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e startTime = \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Wtime\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // loop over all timesteps\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e t = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; t \u0026lt; numberOfTimeSteps; ++t) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        T0 = T1;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // send data to the right processor (except for the last processor, as there is no processor to the right)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank \u0026lt; worldSize - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003erequests\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epush_back\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(MPI_Request{});\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Isend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;pointsPerProcess - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, MPI_DOUBLE, rank + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + rank, MPI_COMM_WORLD, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003erequests\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eback\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e());\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // send data to the left processor (except for the first processor, as there is no processor to the left)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank \u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003erequests\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epush_back\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(MPI_Request{});\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Isend\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, MPI_DOUBLE, rank - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e200\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + rank, MPI_COMM_WORLD, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003erequests\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eback\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e());\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; pointsPerProcess - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + heatDiffusionCoefficient * dt / (dx * dx) * (\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // before we try to receive data, we should make sure that the send requests have completed\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Waitall\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003estatic_cast\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt;(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003erequests\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e()), \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003erequests\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003edata\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(), MPI_STATUSES_IGNORE);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // receive data from the left processor (except for the first processor, as there is no processor to the left)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank \u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Recv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;leftBoundaryValue, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, MPI_DOUBLE, rank - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + rank - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // receive data from the right processor (except for the last processor, as there is no processor to the right)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank \u0026lt; worldSize - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Recv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;rightBoundaryValue, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, MPI_DOUBLE, rank + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e200\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + rank + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e        // now use the received values to compute the values at the inter-processor boundaries\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank \u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + heatDiffusionCoefficient * dt / (dx * dx) * (\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i + \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + leftBoundaryValue);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank \u0026lt; worldSize - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = pointsPerProcess - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + heatDiffusionCoefficient * dt / (dx * dx) * (rightBoundaryValue - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e2\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e * \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e endTime = \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Wtime\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e duration = endTime - startTime;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank == \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Executation time: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; duration \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot; seconds\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // compute error\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e error = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; pointsPerProcess; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        error += \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eabs\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; - \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93;);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    error /= numberOfPoints;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // reduce error over all processes into processor 0 (the root processor)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e root = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e globalError = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0.0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Reduce\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;error, \u0026amp;globalError, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, MPI_DOUBLE, MPI_SUM, root, MPI_COMM_WORLD);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // print error on processor 0 (the only processor that knows the global error)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank == root) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::cout \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Error: \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; globalError \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // reconstruct the global temperature and coordinate array so that it can be written to disk by just one processor\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; globalTemperature;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edouble\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; globalX;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank == root) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eglobalTemperature\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eglobalX\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eresize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(numberOfPoints);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    } \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // store the number of points that are send by each processor in an array\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003epointsPerProcessArray\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(worldSize);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Gather\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;pointsPerProcess, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, MPI_INT, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003epointsPerProcessArray\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;rank\u0026#93;, \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, MPI_INT, root, MPI_COMM_WORLD);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // store the offset/displacement, which states the starting point into the global array for each processor\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // for example, with 3 processors, where processor 0 send 3 elements, processor 1 sends 5 elements, and processor 2\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // sends 1 element, the offset/displacement array is \u0026#91;0, 3, 8\u0026#93;. Processor 0 will write at location 0 in the global\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // array, processor 1 will write at location 3 in the global array, and processor 2 will write at location 8 in the\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // global array\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::vector\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026gt; \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eoffsets\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(worldSize);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank == root) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eoffsets\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; worldSize; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eoffsets\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eoffsets\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93; + \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003epointsPerProcessArray\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i - \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // start gathering all data into the root processor\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Gatherv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eT1\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;, pointsPerProcess, MPI_DOUBLE, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eglobalTemperature\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003epointsPerProcessArray\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eoffsets\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;, MPI_DOUBLE, root, MPI_COMM_WORLD);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Gatherv\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ex\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;, pointsPerProcess, MPI_DOUBLE, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eglobalX\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003epointsPerProcessArray\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;, \u0026amp;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eoffsets\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#93;, MPI_DOUBLE, root, MPI_COMM_WORLD);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // output results on the master processor\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003eif\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (rank == root) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e finalTimeString = \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eto_string\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(finalTime);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        finalTimeString = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efinalTimeString\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esubstr\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e, \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efinalTimeString\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efind\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e));\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::string fileName = \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;results_MPI_\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e + finalTimeString + \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;.csv\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::ofstream \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efile\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(fileName);\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        file \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;x,T\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003efor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e (\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e i = \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e; i \u0026lt; numberOfPoints; ++i) {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e            file \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eglobalX\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;, \u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eglobalTemperature\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e\u0026#91;i\u0026#93; \u0026lt;\u0026lt; \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003estd\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::endl;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e        \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efile\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eclose\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    }\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e    // Finalise the MPI environment.\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eMPI_Finalize\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":199,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(3 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>#include &lt;iostream>
#include &lt;vector>
#include &lt;chrono>
#include &lt;fstream>
#include &lt;string>

#include &lt;mpi.h>

int main(int argc, char* argv[]) {
    // Initialise the MPI environment
    MPI_Init(&amp;argc, &amp;argv);
    
    // Get the number of processes
    int worldSize;
    MPI_Comm_size(MPI_COMM_WORLD, &amp;worldSize);
    
    // Get the current processor ID (rank) of the process
    int rank;
    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);

    // input parameters
    const int numberOfPoints = static_cast&lt;int>(atoi(argv&#91;1&#93;));
    const double leftBoundary = 0.0;
    const double rightBoundary = 1.0;
    const double CFL = 0.25;
    const double heatDiffusionCoefficient = 0.01;
    const double finalTime = static_cast&lt;double>(atof(argv&#91;2&#93;));
    
    // computed input paramters
    const double dx = 1.0 / (numberOfPoints - 1);
    const double dt = CFL * dx * dx / heatDiffusionCoefficient;
    const int numberOfTimeSteps = static_cast&lt;int>(finalTime / dt);

    // Domain decomposition
    int pointsPerProcess = numberOfPoints / worldSize;

    if (rank == 0) {
        std::cout &lt;&lt; "Number of processes: " &lt;&lt; worldSize &lt;&lt; std::endl;
        std::cout &lt;&lt; "Number of points per process: " &lt;&lt; pointsPerProcess &lt;&lt; std::endl;
    }
    MPI_Barrier(MPI_COMM_WORLD);

    // check that we have a valid decomposition. If we don't, then add additional points to the last processor
    int pointsNotUsed = 0;
    if (rank == worldSize - 1) {
        const int totalPoints = worldSize * pointsPerProcess;
        pointsNotUsed = numberOfPoints - totalPoints;
        pointsPerProcess += pointsNotUsed;
        if (pointsNotUsed > 0) {
            std::cout &lt;&lt; "Adding " &lt;&lt; pointsNotUsed &lt;&lt; " point(s) to last processor" &lt;&lt; std::endl;
        }
    }

    // allocate memory for field arrays
    std::vector&lt;double> T0(pointsPerProcess); // T at time n
    std::vector&lt;double> T1(pointsPerProcess); // T at time n+1
    std::vector&lt;double> x(pointsPerProcess);

    // create mesh
    for (int i = 0; i &lt; pointsPerProcess; ++i) {
        x&#91;i&#93; = dx * (i + rank * (pointsPerProcess - pointsNotUsed));
    }

    // initialise field arrays
    for (int i = 0; i &lt; pointsPerProcess; ++i) {
        T0&#91;i&#93; = 0.0;
        T1&#91;i&#93; = 0.0;
    }

    // set boundary conditions (important, set it for T1, not T0)
    // only set it for left-most processor (rank == 0) and right-most processor (rank == worldSize - 1)
    if (rank == 0) {
        T1&#91;0&#93; = leftBoundary;
    }
    if (rank == worldSize - 1) {
        T1&#91;pointsPerProcess - 1&#93; = rightBoundary;
    }

    // helper variables for MPI
    std::vector&lt;MPI_Request> requests;
    double leftBoundaryValue = 0.0;
    double rightBoundaryValue = 0.0;
    
    double startTime = MPI_Wtime();
    // loop over all timesteps
    for (int t = 0; t &lt; numberOfTimeSteps; ++t) {
        T0 = T1;

        // send data to the right processor (except for the last processor, as there is no processor to the right)
        if (rank &lt; worldSize - 1) {
            requests.push_back(MPI_Request{});
            MPI_Isend(&amp;T0&#91;pointsPerProcess - 1&#93;, 1, MPI_DOUBLE, rank + 1, 100 + rank, MPI_COMM_WORLD, &amp;requests.back());
        }
        
        // send data to the left processor (except for the first processor, as there is no processor to the left)
        if (rank > 0) {
            requests.push_back(MPI_Request{});
            MPI_Isend(&amp;T0&#91;0&#93;, 1, MPI_DOUBLE, rank - 1, 200 + rank, MPI_COMM_WORLD, &amp;requests.back());
        }
        
        // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space
        for (int i = 1; i &lt; pointsPerProcess - 1; ++i) {
            T1&#91;i&#93; = T0&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (T0&#91;i + 1&#93; - 2 * T0&#91;i&#93; + T0&#91;i - 1&#93;);
        }
        
        // before we try to receive data, we should make sure that the send requests have completed
        MPI_Waitall(static_cast&lt;int>(requests.size()), requests.data(), MPI_STATUSES_IGNORE);
        
        // receive data from the left processor (except for the first processor, as there is no processor to the left)
        if (rank > 0) {
            MPI_Recv(&amp;leftBoundaryValue, 1, MPI_DOUBLE, rank - 1, 100 + rank - 1, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
        }
        
        // receive data from the right processor (except for the last processor, as there is no processor to the right)
        if (rank &lt; worldSize - 1) {
            MPI_Recv(&amp;rightBoundaryValue, 1, MPI_DOUBLE, rank + 1, 200 + rank + 1, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
        }
        
        // now use the received values to compute the values at the inter-processor boundaries
        if (rank > 0) {
            int i = 0;
            T1&#91;i&#93; = T0&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (T0&#91;i + 1&#93; - 2 * T0&#91;i&#93; + leftBoundaryValue);
        }
        
        if (rank &lt; worldSize - 1) {
            int i = pointsPerProcess - 1;
            T1&#91;i&#93; = T0&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (rightBoundaryValue - 2 * T0&#91;i&#93; + T0&#91;i - 1&#93;);
        }
    }
    double endTime = MPI_Wtime();
    double duration = endTime - startTime;
    if (rank == 0) {
        std::cout &lt;&lt; "Executation time: " &lt;&lt; duration &lt;&lt; " seconds" &lt;&lt; std::endl;
    }

    // compute error
    double error = 0.0;
    for (int i = 0; i &lt; pointsPerProcess; ++i) {
        error += std::abs(T1&#91;i&#93; - x&#91;i&#93;);
    }
    error /= numberOfPoints;

    // reduce error over all processes into processor 0 (the root processor)
    int root = 0;
    double globalError = 0.0;
    MPI_Reduce(&amp;error, &amp;globalError, 1, MPI_DOUBLE, MPI_SUM, root, MPI_COMM_WORLD);

    // print error on processor 0 (the only processor that knows the global error)
    if (rank == root) {
        std::cout &lt;&lt; "Error: " &lt;&lt; globalError &lt;&lt; std::endl;
    }

    // reconstruct the global temperature and coordinate array so that it can be written to disk by just one processor
    std::vector&lt;double> globalTemperature;
    std::vector&lt;double> globalX;
    if (rank == root) {
        globalTemperature.resize(numberOfPoints);
        globalX.resize(numberOfPoints);
    } 
    
    // store the number of points that are send by each processor in an array
    std::vector&lt;int> pointsPerProcessArray(worldSize);
    MPI_Gather(&amp;pointsPerProcess, 1, MPI_INT, &amp;pointsPerProcessArray&#91;rank&#93;, 1, MPI_INT, root, MPI_COMM_WORLD);

    // store the offset/displacement, which states the starting point into the global array for each processor
    // for example, with 3 processors, where processor 0 send 3 elements, processor 1 sends 5 elements, and processor 2
    // sends 1 element, the offset/displacement array is &#91;0, 3, 8&#93;. Processor 0 will write at location 0 in the global
    // array, processor 1 will write at location 3 in the global array, and processor 2 will write at location 8 in the
    // global array
    std::vector&lt;int> offsets(worldSize);
    if (rank == root) {
        offsets&#91;0&#93; = 0;
        for (int i = 1; i &lt; worldSize; ++i) {
            offsets&#91;i&#93; = offsets&#91;i - 1&#93; + pointsPerProcessArray&#91;i - 1&#93;;
        }
    }

    // start gathering all data into the root processor
    MPI_Gatherv(&amp;T1&#91;0&#93;, pointsPerProcess, MPI_DOUBLE, &amp;globalTemperature&#91;0&#93;, &amp;pointsPerProcessArray&#91;0&#93;, &amp;offsets&#91;0&#93;, MPI_DOUBLE, root, MPI_COMM_WORLD);
    MPI_Gatherv(&amp;x&#91;0&#93;, pointsPerProcess, MPI_DOUBLE, &amp;globalX&#91;0&#93;, &amp;pointsPerProcessArray&#91;0&#93;, &amp;offsets&#91;0&#93;, MPI_DOUBLE, root, MPI_COMM_WORLD);

    // output results on the master processor
    if (rank == root) {
        auto finalTimeString = std::to_string(finalTime);
        finalTimeString = finalTimeString.substr(0, finalTimeString.find("."));
        std::string fileName = "results_MPI_" + finalTimeString + ".csv";
        std::ofstream file(fileName);
        file &lt;&lt; "x,T" &lt;&lt; std::endl;
        for (int i = 0; i &lt; numberOfPoints; ++i) {
            file &lt;&lt; globalX&#91;i&#93; &lt;&lt; ", " &lt;&lt; globalTemperature&#91;i&#93; &lt;&lt; std::endl;
        }
        file.close();
    }

    // Finalise the MPI environment.
    MPI_Finalize();

    return 0;
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;iostream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;vector&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;chrono&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;fstream&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;string&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;mpi.h&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">main</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">argc</span><span style="color: #D4D4D4">, </span><span style="color: #569CD6">char*</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">[]) {</span></span>
<span class="line"><span style="color: #6A9955">    // Initialise the MPI environment</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">MPI_Init</span><span style="color: #D4D4D4">(&amp;argc, &amp;argv);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // Get the number of processes</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> worldSize;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">MPI_Comm_size</span><span style="color: #D4D4D4">(MPI_COMM_WORLD, &amp;worldSize);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // Get the current processor ID (rank) of the process</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> rank;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">MPI_Comm_rank</span><span style="color: #D4D4D4">(MPI_COMM_WORLD, &amp;rank);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // input parameters</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfPoints = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #DCDCAA">atoi</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> leftBoundary = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> rightBoundary = </span><span style="color: #B5CEA8">1.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> CFL = </span><span style="color: #B5CEA8">0.25</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> heatDiffusionCoefficient = </span><span style="color: #B5CEA8">0.01</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> finalTime = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #DCDCAA">atof</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">argv</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4">&#93;));</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // computed input paramters</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> dx = </span><span style="color: #B5CEA8">1.0</span><span style="color: #D4D4D4"> / (numberOfPoints - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> dt = CFL * dx * dx / heatDiffusionCoefficient;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> numberOfTimeSteps = </span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;(finalTime / dt);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // Domain decomposition</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> pointsPerProcess = numberOfPoints / worldSize;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank == </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Number of processes: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; worldSize &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Number of points per process: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; pointsPerProcess &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">MPI_Barrier</span><span style="color: #D4D4D4">(MPI_COMM_WORLD);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // check that we have a valid decomposition. If we don&#39;t, then add additional points to the last processor</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> pointsNotUsed = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank == worldSize - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #569CD6">const</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> totalPoints = worldSize * pointsPerProcess;</span></span>
<span class="line"><span style="color: #D4D4D4">        pointsNotUsed = numberOfPoints - totalPoints;</span></span>
<span class="line"><span style="color: #D4D4D4">        pointsPerProcess += pointsNotUsed;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (pointsNotUsed &gt; </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Adding &quot;</span><span style="color: #D4D4D4"> &lt;&lt; pointsNotUsed &lt;&lt; </span><span style="color: #CE9178">&quot; point(s) to last processor&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // allocate memory for field arrays</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">T0</span><span style="color: #D4D4D4">(pointsPerProcess);</span><span style="color: #6A9955"> // T at time n</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">T1</span><span style="color: #D4D4D4">(pointsPerProcess);</span><span style="color: #6A9955"> // T at time n+1</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">x</span><span style="color: #D4D4D4">(pointsPerProcess);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // create mesh</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; pointsPerProcess; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93; = dx * (i + rank * (pointsPerProcess - pointsNotUsed));</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // initialise field arrays</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; pointsPerProcess; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // set boundary conditions (important, set it for T1, not T0)</span></span>
<span class="line"><span style="color: #6A9955">    // only set it for left-most processor (rank == 0) and right-most processor (rank == worldSize - 1)</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank == </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93; = leftBoundary;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank == worldSize - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;pointsPerProcess - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; = rightBoundary;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // helper variables for MPI</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;MPI_Request&gt; requests;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> leftBoundaryValue = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> rightBoundaryValue = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> startTime = </span><span style="color: #DCDCAA">MPI_Wtime</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #6A9955">    // loop over all timesteps</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> t = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; t &lt; numberOfTimeSteps; ++t) {</span></span>
<span class="line"><span style="color: #D4D4D4">        T0 = T1;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">        // send data to the right processor (except for the last processor, as there is no processor to the right)</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank &lt; worldSize - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #9CDCFE">requests</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">push_back</span><span style="color: #D4D4D4">(MPI_Request{});</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #DCDCAA">MPI_Isend</span><span style="color: #D4D4D4">(&amp;</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;pointsPerProcess - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, MPI_DOUBLE, rank + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">100</span><span style="color: #D4D4D4"> + rank, MPI_COMM_WORLD, &amp;</span><span style="color: #9CDCFE">requests</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">back</span><span style="color: #D4D4D4">());</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">        </span></span>
<span class="line"><span style="color: #6A9955">        // send data to the left processor (except for the first processor, as there is no processor to the left)</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank &gt; </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #9CDCFE">requests</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">push_back</span><span style="color: #D4D4D4">(MPI_Request{});</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #DCDCAA">MPI_Isend</span><span style="color: #D4D4D4">(&amp;</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93;, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, MPI_DOUBLE, rank - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">200</span><span style="color: #D4D4D4"> + rank, MPI_COMM_WORLD, &amp;</span><span style="color: #9CDCFE">requests</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">back</span><span style="color: #D4D4D4">());</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">        </span></span>
<span class="line"><span style="color: #6A9955">        // compute solution at next time level T^n+1 using an explicit update in time and e central difference in space</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; i &lt; pointsPerProcess - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; - </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">        </span></span>
<span class="line"><span style="color: #6A9955">        // before we try to receive data, we should make sure that the send requests have completed</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #DCDCAA">MPI_Waitall</span><span style="color: #D4D4D4">(</span><span style="color: #569CD6">static_cast</span><span style="color: #D4D4D4">&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt;(</span><span style="color: #9CDCFE">requests</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">size</span><span style="color: #D4D4D4">()), </span><span style="color: #9CDCFE">requests</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">data</span><span style="color: #D4D4D4">(), MPI_STATUSES_IGNORE);</span></span>
<span class="line"><span style="color: #D4D4D4">        </span></span>
<span class="line"><span style="color: #6A9955">        // receive data from the left processor (except for the first processor, as there is no processor to the left)</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank &gt; </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #DCDCAA">MPI_Recv</span><span style="color: #D4D4D4">(&amp;leftBoundaryValue, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, MPI_DOUBLE, rank - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">100</span><span style="color: #D4D4D4"> + rank - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">        </span></span>
<span class="line"><span style="color: #6A9955">        // receive data from the right processor (except for the last processor, as there is no processor to the right)</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank &lt; worldSize - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #DCDCAA">MPI_Recv</span><span style="color: #D4D4D4">(&amp;rightBoundaryValue, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, MPI_DOUBLE, rank + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, </span><span style="color: #B5CEA8">200</span><span style="color: #D4D4D4"> + rank + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">        </span></span>
<span class="line"><span style="color: #6A9955">        // now use the received values to compute the values at the inter-processor boundaries</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank &gt; </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (</span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i + </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; - </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + leftBoundaryValue);</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">        </span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank &lt; worldSize - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = pointsPerProcess - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + heatDiffusionCoefficient * dt / (dx * dx) * (rightBoundaryValue - </span><span style="color: #B5CEA8">2</span><span style="color: #D4D4D4"> * </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i&#93; + </span><span style="color: #9CDCFE">T0</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> endTime = </span><span style="color: #DCDCAA">MPI_Wtime</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> duration = endTime - startTime;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank == </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Executation time: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; duration &lt;&lt; </span><span style="color: #CE9178">&quot; seconds&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // compute error</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> error = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; pointsPerProcess; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">        error += </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">abs</span><span style="color: #D4D4D4">(</span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;i&#93; - </span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;i&#93;);</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"><span style="color: #D4D4D4">    error /= numberOfPoints;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // reduce error over all processes into processor 0 (the root processor)</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> root = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #569CD6">double</span><span style="color: #D4D4D4"> globalError = </span><span style="color: #B5CEA8">0.0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">MPI_Reduce</span><span style="color: #D4D4D4">(&amp;error, &amp;globalError, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, MPI_DOUBLE, MPI_SUM, root, MPI_COMM_WORLD);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // print error on processor 0 (the only processor that knows the global error)</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank == root) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::cout &lt;&lt; </span><span style="color: #CE9178">&quot;Error: &quot;</span><span style="color: #D4D4D4"> &lt;&lt; globalError &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // reconstruct the global temperature and coordinate array so that it can be written to disk by just one processor</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; globalTemperature;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">double</span><span style="color: #D4D4D4">&gt; globalX;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank == root) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">globalTemperature</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(numberOfPoints);</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">globalX</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">resize</span><span style="color: #D4D4D4">(numberOfPoints);</span></span>
<span class="line"><span style="color: #D4D4D4">    } </span></span>
<span class="line"><span style="color: #D4D4D4">    </span></span>
<span class="line"><span style="color: #6A9955">    // store the number of points that are send by each processor in an array</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">pointsPerProcessArray</span><span style="color: #D4D4D4">(worldSize);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">MPI_Gather</span><span style="color: #D4D4D4">(&amp;pointsPerProcess, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, MPI_INT, &amp;</span><span style="color: #9CDCFE">pointsPerProcessArray</span><span style="color: #D4D4D4">&#91;rank&#93;, </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">, MPI_INT, root, MPI_COMM_WORLD);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // store the offset/displacement, which states the starting point into the global array for each processor</span></span>
<span class="line"><span style="color: #6A9955">    // for example, with 3 processors, where processor 0 send 3 elements, processor 1 sends 5 elements, and processor 2</span></span>
<span class="line"><span style="color: #6A9955">    // sends 1 element, the offset/displacement array is &#91;0, 3, 8&#93;. Processor 0 will write at location 0 in the global</span></span>
<span class="line"><span style="color: #6A9955">    // array, processor 1 will write at location 3 in the global array, and processor 2 will write at location 8 in the</span></span>
<span class="line"><span style="color: #6A9955">    // global array</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::vector&lt;</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4">&gt; </span><span style="color: #DCDCAA">offsets</span><span style="color: #D4D4D4">(worldSize);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank == root) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">offsets</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93; = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">; i &lt; worldSize; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">            </span><span style="color: #9CDCFE">offsets</span><span style="color: #D4D4D4">&#91;i&#93; = </span><span style="color: #9CDCFE">offsets</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93; + </span><span style="color: #9CDCFE">pointsPerProcessArray</span><span style="color: #D4D4D4">&#91;i - </span><span style="color: #B5CEA8">1</span><span style="color: #D4D4D4">&#93;;</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // start gathering all data into the root processor</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">MPI_Gatherv</span><span style="color: #D4D4D4">(&amp;</span><span style="color: #9CDCFE">T1</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93;, pointsPerProcess, MPI_DOUBLE, &amp;</span><span style="color: #9CDCFE">globalTemperature</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93;, &amp;</span><span style="color: #9CDCFE">pointsPerProcessArray</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93;, &amp;</span><span style="color: #9CDCFE">offsets</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93;, MPI_DOUBLE, root, MPI_COMM_WORLD);</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">MPI_Gatherv</span><span style="color: #D4D4D4">(&amp;</span><span style="color: #9CDCFE">x</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93;, pointsPerProcess, MPI_DOUBLE, &amp;</span><span style="color: #9CDCFE">globalX</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93;, &amp;</span><span style="color: #9CDCFE">pointsPerProcessArray</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93;, &amp;</span><span style="color: #9CDCFE">offsets</span><span style="color: #D4D4D4">&#91;</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">&#93;, MPI_DOUBLE, root, MPI_COMM_WORLD);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // output results on the master processor</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">if</span><span style="color: #D4D4D4"> (rank == root) {</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> finalTimeString = </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::</span><span style="color: #DCDCAA">to_string</span><span style="color: #D4D4D4">(finalTime);</span></span>
<span class="line"><span style="color: #D4D4D4">        finalTimeString = </span><span style="color: #9CDCFE">finalTimeString</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">substr</span><span style="color: #D4D4D4">(</span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">, </span><span style="color: #9CDCFE">finalTimeString</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">find</span><span style="color: #D4D4D4">(</span><span style="color: #CE9178">&quot;.&quot;</span><span style="color: #D4D4D4">));</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::string fileName = </span><span style="color: #CE9178">&quot;results_MPI_&quot;</span><span style="color: #D4D4D4"> + finalTimeString + </span><span style="color: #CE9178">&quot;.csv&quot;</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::ofstream </span><span style="color: #DCDCAA">file</span><span style="color: #D4D4D4">(fileName);</span></span>
<span class="line"><span style="color: #D4D4D4">        file &lt;&lt; </span><span style="color: #CE9178">&quot;x,T&quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #C586C0">for</span><span style="color: #D4D4D4"> (</span><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> i = </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">; i &lt; numberOfPoints; ++i) {</span></span>
<span class="line"><span style="color: #D4D4D4">            file &lt;&lt; </span><span style="color: #9CDCFE">globalX</span><span style="color: #D4D4D4">&#91;i&#93; &lt;&lt; </span><span style="color: #CE9178">&quot;, &quot;</span><span style="color: #D4D4D4"> &lt;&lt; </span><span style="color: #9CDCFE">globalTemperature</span><span style="color: #D4D4D4">&#91;i&#93; &lt;&lt; </span><span style="color: #4EC9B0">std</span><span style="color: #D4D4D4">::endl;</span></span>
<span class="line"><span style="color: #D4D4D4">        }</span></span>
<span class="line"><span style="color: #D4D4D4">        </span><span style="color: #9CDCFE">file</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">close</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #6A9955">    // Finalise the MPI environment.</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #DCDCAA">MPI_Finalize</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->
 
<!-- wp:paragraph -->
<p>Jepp, MPI is a little bit more involved, so let's go through it step by step:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li><strong>Line 7</strong>: Starting off easy, first, we include the MPI header file to ensure that we can use it.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 11</strong>: We have to tell our program that we want to use MPI. To do so, we call the <code>MPI_Init()</code> function, and we forward the command line arguments here so that each processor is aware of any potential arguments. If we don't have any command line arguments to pass, then we can also write <code>MPI_Init(NULL, NULL)</code>.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 14-15</strong>: One of the first things we want to know is the number of cores that are available. We do that by calling the <code>MPI_Comm_size()</code>. This function is expecting two arguments. The first is the communication group, and we always get <code>MPI_COMM_WORLD</code> by default (which we will use throughout this program).<br/><br/>

When we launch our MPI program, we tell it how many cores to use. MPI will then allocate the requested number of cores to your program and store them in the <code>MPI_COMM_WORLD</code> group. For example, if you have a 12-core PC but only use 4 cores, you need to know which 4 cores out of the 12 work on the MPI program. We need to know that so that we can later send messages between these (and that we don't send messages to a processor that doesn't participate in the program).<br/><br/>

<code>MPIC_COMM_WORLD</code> knows which cores participate and will ensure we send data to the correct processor. We can create our own communicators (for example, we can split the 4 cores that we have and create two groups of 2 processors each, where one group computes some CFD results while the other group looks after structural simulations for Fluid-Structure interaction (FSI) simulations, for example). <br/><br/>

The second argument, <code>wordlSize</code> is the variable in which we store the results. Since we store the results directly in this variable, we have to pass it in by reference (using the address-of operator<code>&</code>), which will ensure any modifications made to that variable within the <code>MPI_Comm_world</code> call will persist after the function has finished executing.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 18-19</strong>: We do something similar here to the previous call, except that we now look for the processor ID within the <code>MPI_COMM_WORLD</code> communicator. If we run our program on 4 cores, then each core will independently run our code from line 11 (when we call <code>MPI_Init()</code>). Once we reach line 19, we will identify which processor ID has been assigned to us, which we can then later use to assign data to a specific processor, as well as to establish communications between two specific processors. In OpenMP, a processor is called a thread; in MPI, we refer to them as ranks. I'll use the same naming convention here.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 35</strong>: We have a 1D problem, so our domain decomposition is as simple as taking all the points that we have in our simulation and dividing them by the number of processors that we have, i.e. the variable we determined on line 15 when calling <code>MPI_Comm_world()</code>. In case the number of points is not divisible by the number of processors, we have to do some additional work, which we will do on lines 44-52.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 37-40</strong>: By convention, processor ID 0 (or rank 0) is the so-called master processor. Whenever there is work to be done by just a single processor, it is the master who is performing all of this work. MPI has used for quite some time the unfortunate terminology that rank 0 is the master, and all other participating processors are slaves, but there seems to be (finally) a shift towards avoiding the word slave, and the term worker is more commonly used nowadays.<br/><br/>

In any case, we assign rank 0 as the master so that, in theory, we could also run our MPI program with just a single core. Here, I am just printing the number of processors and points per processor.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 41</strong>: I am now making a collective call to <code>MPI_Barrier()</code>. This call will ensure that all processors have arrived at this point before continuing. To be honest, there is absolutely no point in having this call here, but I wanted to show you the syntax in at least one place so you have seen it once. However, if we look at the 4 preceding lines, we can imagine a situation in which rank 0 may do some checks, which may fail, resulting in rank 0 terminating execution prematurely. Now we have all other processors waiting at the barrier, and they will never be able to proceed, because rank 0 won't arrive. This would be a classical deadlock situation.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 44-52</strong>: We did our domain decomposition on line 35, but as alluded to before, we may have a situation where we can't cleanly divide the number of points by the number of participating processors. There are several ways of dealing with it. What I am doing here is to check how many points have not been accounted for, and then add those points to the last processor. So, if we have 24 points and 7 processors, each processor receives 3 points. [katex]7\cdot 3 = 21[/katex], so there are [katex]24 - 21 = 3[/katex] points not accoutned for. These are now added to the last processor with ID <code>worldSize - 1</code>. The minus 1 is there because our processor IDs start at 0, not 1.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 55-57</strong>: We allocate now arrays based on the number of points per processor, no longer for the entire domain. Remember that MPI is a distributed memory approach, and so we allocate only memory for our specific processor. Also, the variable <code>pointsPerProcessor</code> may not be the same for each processor. We saw on line 44-52 that the last processor may have a different value for <code>pointsPerProcessor</code>. This can be confusing, especially when you get started with MPI.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 60-62</strong>: Now we create the mesh. The mesh needs to go from 0 to 1. However, each sub-domain has its own mesh section. For example, if we have 4 processors, the mesh for rank 0 will go from 0 to 0.25. The mesh for rank 1 will go from 0.25 to 0.5, and so on.<br/><br/>

If I only multiplied the loop variable <code>i</code> by the global spacing <code>dx</code>, all of my sub-domains would go from 0 to 0.25 (using the same example values as before). Therefore, I need to offset the loop variable <code>i</code> by the number of <code>pointsPerProcessor</code>, which will ensure that each subsequent processor will start at 0.25, 0.5, and 0.75, instead of starting again at 0.<br/><br/>

The <code>pointsNotUsed</code> needs to be subtracted. Only the last processor sets this value, so for all other processors <code>pointsNotUsed</code> is zero. If we did not do this subtraction, the last processor would think that all other processors had the same number of points as itself, and so it would compute the offset at which point to start incorrectly.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 72-77</strong>: Now we are setting the boundary conditions. We only want to set it for the left-most processor (rank 0) and the right-most processor (worldSize - 1). If we didn't, then each processor would set a boundary condition at their inter-processor boundary, i.e. somewhere in the middle of the domain, which we don't want.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 80-82</strong>: We are setting up some helper variables that we will use for our MPI communications. The left and right boundary values will be used to store received data from each processor. That is, we will receive data from our right neighbour processor into our <code>rightBoundaryValue</code> variable, and data from our left neighbour processor into our <code>leftBoundaryValue</code> variable.<br/><br/>

We also have a <code>std::vector</code> of type <code>MPI_Request</code>, which we will need to use later. When we do our non-blocking communications, we don't know at what point they have completed. When they do complete, this request vector will reflect that, and so we can check this request vector later to ensure that all communications have been completed before we start to do anything with the received data.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 84</strong>: We create a timestamp of our starting time using MPI's <code>MPI_Wtime()</code>, or wallclock time. This is similar to the <code>std::chrono</code> call we had before, but MPI provides its own timing functionality. We can use <code>std::chrono</code> instead, but then we would have to fence it off again with a <code>if (rank == 0) { ... }</code> call. It is common to just use the MPI internal timing here instead.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 87</strong>: In OpenMP and CUDA, we saw that the temperature array update (storing [katex]T<sup>{n+1}[/katex] computed at the previous time step in [katex]T</sup>n[/katex]) was done in parallel. In MPI, we have a distributed memory approach, and so each processor will have their own private copy of <code>T1</code> and <code>T0</code>, and so we can simply copy the entire content of <code>T1</code> in <code>T0</code>, just as we did in the sequential program.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 90-93</strong>: This is our first communication. We first ensure that we are not on the right-most processor (<code>rank < worldSize - 1</code>), as we want to send data to our right neighbour processor. The right-most processor won't have a neighbour to its right.<br/><br/>

We are using the non-blocking <code>MPI_Isend()</code> call here, where the <code>I</code> stands for immediate (although I have seen a few different definitions for it as well, immediate makes most sense in my books). In general, whenever we see a capital <code>I</code> in an MPI function call, i.e. <code>MPI_I...</code>, it means that this is a non-blocking call. The corresponding blocking call would be without the <code>I</code>. For example, a blocking send call would be <code>MPI_Send()</code>.<br/><br/>

Let's look at the 7 different parameters that go into an MPI send call. The first argument is the data we want to send. If we want to send more than just a single value, like an array, we specify the start location of that array. In this example, we want to send the last element in our <code>T0</code> array, which should be sent to our neighbour to the right. The next argument specifies how much data I want to send. I only want to send a single element, so I can put a <code>1</code> as the second argument. The third argument specifies the type I am sending, which are typically preceded by an <code>MPI_</code>. In this case, I am sending a <code>double</code>, so <code>MPI_DOUBLE</code> is the type.<br/><br/>

The fourth argument tells MPI which processor should receive this data. In our case, we want to send data to the right processor, which has a rank of <code>rank + 1</code>. So, for example, if I am on processor 1 with <code>rank = 1</code>, then the processor to my right is <code>rank = 2</code>. So, by saying I want to send data to <code>rank + 1</code>, I am selecting the processor to my right automatically.<br/><br/>

The fifth argument is a tag. In this example, we are just sending a single element to my processor on the right, but imagine I am solving the Navier-Stokes equation and I want to send velocity, pressure, temperature, and density to the processor on the right. I need to be able to distinguish each send operation, so the received data can later be correctly identified. This is what the tag is doing, and we typically give some identifying number + some combination with the <code>rank</code> itself.<br/><br/>

Here, I am using <code>100</code> as my identifying number, and, if I also send velocity, pressure, and density information, I may bump these up to <code>200</code>, <code>300</code>, and <code>400</code>, respectively. In this way, I can later identify what data was sent. Since I am also using the <code>rank</code> here to compute a tag, I need to be careful. If I use more than 100 processors, I may have something like <code>100 + rank</code>, which can now become larger than <code>200</code>, then may send data into the wrong array.<br/><br/>

For that reason, it makes sense to bundle all data you want to send into its own container and then send that container instead. This makes the tag computation less error-prone, but also means that you have to tell MPI about your custom data classes, which is not necessarily straightforward (but support exists for that in MPI).<br/><br/>

After the tag, we tell which communicator we want to use, and usually we always use the default communicator, i.e. <code>MPI_COMM_WORLD</code>. Finally, we have to pass a reference to the last element in our <code>request</code> vector, holding our <code>MPI_Request</code> data. We just created an empty instance of that on line 91, and now we tell MPI that it should put all information about the communication into this array. We can then later check if this specific communication has finished.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 96-99</strong>: This is exactly the same as lines 90-93, except that we now make sure that the first processor is not included in this call (<code>rank > 0</code>), as we want to send now data to our left-most processor (and the first processor won't have a neighbour to its left). We are now sending the first element of our <code>T0</code> array. We still only send 1 element of type <code>MPI_DOUBLE</code>, but now we are sending it to the left processor, so we are sending it to <code>rank - 1</code>. The tag is now using an identifying number of <code>200</code> and we add the <code>rank</code> to it. The communicator group is still <code>MPI_COMM_WORLD</code> and we use the same <code>request</code> vector here to add one additional <code>MPI_Request</code> object.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 102-104</strong>: We have prepared the non-blocking communication, and that process has started in the background. We can now update the rest of the temperature array at the next time level [katex]T^{n+1}[/katex]. Notice that our loop starts at <code>i = 1</code> and it goes to <code>pointsPerProcessor - 1</code>, i.e. we are not yet updating the values on the inter-processor boundaries, which are located at <code>i = 0</code> (as long as we are not on the left-most processor) and <code>i = pointsPerProcess - 1</code> (as long as we are not on the right-most processor).

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 107</strong>: We have initiated the communication with two non-blocking send communication calls, and we have updated all the internal variables. Now we want to compute the final values on the inter-processor boundaries. In order to do that, we need to ensure that all data was received from the send call. Thus, on line 107, we call the <code>MPI_Waitall</code> function, which first asks us how many requests we should check. I am using the size of the request object here, because we don't know how many requests we should check. If I have one processor to my right and one to my left, then I will have made 2 non-blocking sends to the left and right, and so my request object will have a size of 2. But if I am on the left or right domain boundary, then I will have to send data to one processor, and my request vector will have a size of 1. For that reason, we can't just use a value of 2 here and instead need to find it dynamically.<br/><br/>

The second argument into <code>MPI_Waitall()</code> is <code>request.data()</code>, which is the raw pointer of each element of a <code>std::vector</code>. MPI is written in C, not C++, and so it doesn't understand containers like <code>std::vector</code>s. We need to give it raw pointers which a C program can understand, and that is what the call to <code>data()</code> achieves.<br/><br/>

We could also check the status with the third argument, which we may want to do if we have a more complex code and we check at a few points if the data has been received, instead of only doing that at the end. Since we don't really care and want to wait until all data has been received, we ignore the status report with <code>MPI_STATUSES_IGNORE</code>.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 110-112</strong>: We now do the reverse of a send call and instead receive data with the <code>MPI_Recv()</code> function call. This is a blocking communication. There is also an equivalent non-blocking communication, called <code>MPI_Irecv()</code>, though there is no advantage of pairing two non-blocking communications over one blocking and one non-blocking communication. If we used a non-blocking communication here, we would have to generate an additional <code>std::vector<MPI_Request></code> vector and call <code>MPI_Waitall()</code> again before proceeding, so we may as well just use a blocking call here.<br/><br/>

Remember, we used a non-blocking call for the send so that we could do some additional stuff in the meantime, like updating <code>T1</code> on line 103. But since there is nothing else for us to do at this point, using a blocking or non-blocking call here will have no measurable difference.<br/><br/>

We use the same <code>rank > 0</code> check here to ensure that we are not on the left-most processor. If that is the case, we know that there must be a processor to our left (<code>rank - 1</code>) which has sent some data for us. We want to now receive this data, which we will store into the variable that is given as the first argument to the <code>MPI_Recv</code> call, here <code>leftBoundaryValue</code>. We pass the address of the variable again, so that MPI can update the value found at that address so that <code>leftBoundaryValue</code> will contain the received value after MPI has finished its communication.<br/><br/>

The second and third arguments are the same as in the corresponding send call, i.e. we are sending one element of type <code>MPI_DOUBLE</code>. The fourth argument tells us where the data should be coming from. In this case, it is coming from our left neighbouring processor, so it is coming from <code>rank - 1</code>.<br/><br/>

We have to compute the correct tag as the fifth argument. On line 92, we saw that we send data to our right processor (which is the value we are now receiving on line 111 from our left processor). The tag on line 92 was <code>100 + rank</code>. If processor 2 sends data to processor 3, then the tag was <code>102</code>. When processor 3 receives the data, the tag must be <code>100 + rank - 1</code>, i.e. in our example <code>100 + 3 - 1 = 102</code>. We simply ensure that we are setting the correct tag value here so that we receive the right data.<br/><br/>

We use the default communication group again, i.e. <code>MPI_COMM_WORLD</code>, and we can ignore the status with <code>MPI_STATUS_IGNORE</code> as this is a blocking receive operation.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 115-117</strong>: This is the same call to the previous lines, only now we are receiving data from the right processor, and so, we need to make sure that we are not on the right-most processor, which we do with the check <code>rank < worldSize - 1</code>.<br/><br/>

The only difference here is that we receive data now into the <code>rightBoundaryValue</code>, we are receiving data from our right neighbouring processor, i.e. <code>rank + 1</code>, and we are computing the tag as <code>200 + rank + 1</code>, as the corresponding tag on line 98 was computed as <code>200 + rank</code>.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 122</strong>: We explicitly update the value at <code>T1[i]</code> with <code>i = 0</code> using the received <code>leftBoundaryValue</code>. Originally, we had <code>T0[i - 1]</code> here, but if <code>i = 0</code>, then <code>i - 1</code> would result in an out-of-bounds memory request, crashing the program. But, with <code>leftboundaryValue</code> now available, we can replace this value and manually update the value of <code>T1</code> at the inter-processor boundary.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 116</strong>: We do the same as on line 122 here, only that we are updating <code>T1[i]</code> with <code>i = pointsPerProcessor - 1 </code>, i.e. the value on the right inter-processor boundary. The value of <code>T0[i + 1]</code> is now replaced by the value we received into the <code>rightBoundaryValue</code>. Once this is done, the current time step has finished, and we go back to the beginning of this loop.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 130-134</strong>: Once the time loop has completed, we take another time stamp and compute the total time it took to run the time loop. We print this result to the screen as well on line 133 and use the same trick as before, where only rank 0 is printing this value.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 137-141</strong>: We compute the local error norm, just as we did in all of the other cases, but now we compute the error for each sub-domain separately. Thus, each processor computes an individual error.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 144-146</strong>: We need to collect all individual errors from each processor and compute the final error as a sum of all individual errors. This type of operation is quite common, where all processors compute individual parts, and then all processors send them to one processor, who then decides what to do with them. This type of operation is a so-called <em>reduction</em> operation.<br/><br/>

We call the <code>MPI_Reduce()</code> function that is doing that for us. The first argument is the value we want to send from all processors. The third argument is the number of elements we are sending, and the fourth argument is the type again, here <code>MPI_DOUBLE</code>. The fifth argument tells MPI what we want to do with the value. In this case, we want to sum up all elements. The result of this will be stored in the second argument, which here is <code>globalError</code>.<br/><br/>

There are other types of operations available, for example, <code>MPI_PROD</code> for multiplying all individual contributions, or <code>MPI_MAX</code>/<code>MPI_MIN</code>, which select the maximum/minimum value computed on each processor. When we compute a stable time step on each processor, for example, we may want to find the maximum allowable time step and use that, for which we would use <code>MPI_MAX</code>.<br/><br/>

The sixth argument tells MPI which processor should process all of that data. Here, I have defined a new helper variable called <code>root</code>, which I have set on line 144 to rank 0. The seventh and final argument, again, tells MPI which communication group to use.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 149-151</strong>: If we are rank 0, then we print the global error on line 150, the one that we just reduced from all other processors.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 154-159</strong>: We now start to prepare the data output. For that, we define the first two arrays that are going to hold the temperature and coordinate arrays for the entire domain. If we are on the root processor, i.e. when <code>rank = 0</code>, only then do we allocate memory for it. This array will now have as many entries as all processors combined. This is something we can do when we are dealing with simple 1D arrays to create a test program, where we now send all data to the root, or master processor, i.e. the one with <code>rank = 0</code>, but for more complex programs, we would likely make use of MPI's parallel I/O (input/output) capabilities and let each processor write its content to disk separately.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 162-163</strong>: We define the <code>pointsPerProcessorArray</code>, which will contain the number of points that each processor has in its sub-domain. We use the <code>MPI_Gather</code> function, which is a collective communication. It is similar to the <code>MPI_Reduce()</code> call, in that all processors send one specific piece of information to one processor, typically the root/master. The only difference is that we are not adding up all individual elements; instead, we store them in an array, where each processor sends its contribution into the array, at the index that is equal to their rank. So, processor 0 will store their contribution at index 0 in the array, processor 1 at index 1, and so on.<br/><br/>

We see that the first argument to <code>MPI_Gather()</code> is the value we want to send (we send one element of type <code>MPI_INT</code>, i.e. see the second and third argument), and we store it in the <code>pointsPerProcessorArray</code> at the index that is equal to the processor's ID (i.e. at index <code>rank</code>). All of this information will be sent to the root again, which will be the only processor which will know about this information.<br/><br/>

The reason we have to collect this data is that the last processor may contain more cells than other processors. We could have also done a send and receive call between the first and last processor, but I wanted to show you some additional MPI calls, like <code>MPI_Gather()</code>, which are quite commonly used.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 170-176</strong>: Based on the number of points per processor, we can now compute a so-called offset, or displacement vector. This will show at which index, in the global temperature and coordinate vector, each processor will start writing their data to. So, for example, if we had 3 processors, and the number of elements per processor would be <code>[3,4,2]</code>, then the offset, or displacement vector, would become <code>[0,3,7]</code>. That is, the first processor will write its data at index 0. The second processor has to skip the first 3 elements, because that is where processor 0 is writing, and so it will start putting its 4 elements from index 3. The final processor will have to jump over processors 0 and 1, which collectively write 7 elements, and so the final processor will have to start writing its data from index 7 (3 + 4).

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Lines 179-180</strong>: Now that we have created the points per processor array, as well as the displacement vector, we can use the <code>MPI_Gatherv()</code> function to collect all individual data from the processors and write it into the global temperature and coordinate array at their specific index. We use the <code>Gatherv</code>, not <code>Gather</code> variant here, where the <code>v</code> at the end indicates that we have variable sizes that we are collecting.<br/><br/>

When we used <code>MPI_Gather()</code>, we collected the same amount of information from each processor, but with <code>MPI_Gatherv()</code> we collect an arbitrary amount of information from each processor.<br/><br/>

The first argument is again the variable, or here the array, into which we want to receive data. We then state how many elements we want to send. Each processor may now have a different value for <code>pointsPerProcessor</code>. The type is <code>MPI_DOUBLE</code>, as the temperature and coordinate arrays are of type <code>std::vector<double></code>.<br/><br/>

The fourth argument tells MPI that we want to send the data to the global temperature and coordinate array, and the next two arguments are the <code>pointsPerProcessorArray</code> and <code>offset</code> vector, which will tell MPI how many elements to write into the global arrays, and at which location we should start writing these for each processor. This is what we have just created in the previous lines of code. Only processor 0 will have this information available, as we have enclosed all previous calculations with <code>if (rank == 0) { ... }</code>. Thus, we have to make sure that the <code>MPI_Gatherv()</code> function gathers all of this information into processor zero, which we can see is the case.<br/><br/>

The final three arguments are that we gather variables of type <code>MPI_DOUBLE</code>, that it is indeed the root which receives all of the information, and that all processors participate in the blocking, collective communication.

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li><strong>Line 196</strong>: After we have written the content of the collected information out to disk as a <code>*.csv</code> file, we are done with MPI, and we can call the <code>MPI_Finalize()</code> command. Each program needs to call that, which signals the end of the MPI program. Afterwards, we can gracefully exit the program with a standard <code>return 0</code> call.

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>That was quite a bit to go through, and you may be wondering, is all of this code really required? Well, yes and no. What I have shown here is not necessarily the most efficient implementation. It is almost a universal rule that I can either show you how to use a framework, which will make it rather inefficient, or I can write really efficient code, but then it will be difficult to understand what I am doing.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, writing code for education and performance purposes is very different. I wanted to be a bit more verbose with some of the function calls, but there are better ways of dealing with MPI here. For example, for a simple case like what we have seen here, where we use a structured grid with processors to my left and right, we can use a Cartesian parallelisation topology.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we use this approach, we create a new communicator, instead of using the default <code>MPI_COMM_WORLD</code>, which will then know how to send data to the left and right. We no longer have to manually compute the left and right processor ID, and it will also know that for my right-most processor, there won't be a processor to its right, and it won't send data. We don't have to perform this check either. The same is true for the left-most processor.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you want to explore this concept in greater depth, you can find a similar implementation of the heat diffusion equation, now in 3D, <a href="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/heat3D.cpp" target="_blank" rel="noopener" title="">here</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So far, we have talked only about 2-sided communications, that is, we send data from one processor (side) to another processor (side). However, we can also use one-sided communications, which are gaining popularity. In this approach, each processor allocates a dedicated memory area into which other processors are allowed to write. They can come, leave their data here, and go, without the other processor that is receiving this data needing to participate in this exchange.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This is akin to your Amazon delivery driver leaving your delivery outside your door when you are not home; it is a one-sided delivery in which you did not take part (open the door and take possession of the package). Because it is one-sided, there is potential to speed up communication times significantly, and hence we see this paradigm being used more and more.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, if we want to get this beauty to run, we need to prepare our machine first. We need to get some form of MPI distribution onto our PC before we can compile and execute the code. On Windows, well, we have to install <a href="https://www.microsoft.com/en-us/download/details.aspx?id=105289" target="_blank" rel="noopener" title="">Microsoft MPI</a>, it's not like we have a lot of choice here (although we can also use/try for free third-party implementations like <a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/mpi-library.html" target="_blank" rel="noopener" title="">Intel MPI</a> or <a href="https://www.ibm.com/products/spectrum-mpi" target="_blank" rel="noopener" title="">IBM MPI</a>)</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On UNIX, we have a bit more support that natively integrates with our operating system. The two most popular distributions are <a href="https://www.mpich.org/" target="_blank" rel="noopener" title="">MPICH</a> and <a href="https://www.open-mpi.org/" target="_blank" rel="noopener" title="">OpenMPI</a> (not to be confused with OpenMP, which I thought for a very long time was one and the same, just with a typo ...). We can install them with our favourite package manager, i.e. <code>apt</code>, <code>homebrew</code>, <code>yay</code>, etc.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once we have done that, we can add the following lines to our CMake project:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"# \u002d\u002d- MPI \u002d\u002d-\nadd_executable(heat1DMPI \u0022src/heat1DMPI.cpp\u0022)\nfind_package(MPI REQUIRED)\ntarget_link_libraries(heat1DMPI PRIVATE MPI::MPI_CXX)","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #6A9955\u0022\u003e# \u002d\u002d- MPI \u002d\u002d-\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eadd_executable\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(heat1DMPI \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;src/heat1DMPI.cpp\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003efind_package\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(MPI REQUIRED)\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etarget_link_libraries\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(heat1DMPI PRIVATE MPI::MPI_CXX)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cmake","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":4,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly># --- MPI ---
add_executable(heat1DMPI "src/heat1DMPI.cpp")
find_package(MPI REQUIRED)
target_link_libraries(heat1DMPI PRIVATE MPI::MPI_CXX)</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #6A9955"># --- MPI ---</span></span>
<span class="line"><span style="color: #569CD6">add_executable</span><span style="color: #D4D4D4">(heat1DMPI </span><span style="color: #CE9178">&quot;src/heat1DMPI.cpp&quot;</span><span style="color: #D4D4D4">)</span></span>
<span class="line"><span style="color: #569CD6">find_package</span><span style="color: #D4D4D4">(MPI REQUIRED)</span></span>
<span class="line"><span style="color: #569CD6">target_link_libraries</span><span style="color: #D4D4D4">(heat1DMPI PRIVATE MPI::MPI_CXX)</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>We define the executable and which source file it depends on, which we need to find the MPI installation; otherwise, we can't continue, and then we link our executable against the MPI library. And that's it, short and painless, well, at least this part of the compilation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can compile our project as before using CMake:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"cmake -DCMAKE_BUILD_TYPE=Release ..","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecmake\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-DCMAKE_BUILD_TYPE=Release\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e..\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>cmake -DCMAKE_BUILD_TYPE=Release ..</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">cmake</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-DCMAKE_BUILD_TYPE=Release</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">..</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"cmake \u002d\u002dbuild . \u002d\u002dconfig Release","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ecmake\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u002d\u002dbuild\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e\u002d\u002dconfig\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003eRelease\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>cmake --build . --config Release</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">cmake</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">--build</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">.</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">--config</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">Release</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Executing the solver is slightly different from before. On Windows, using Microsoft MPI, we have to use the following:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"mpiexec.exe -n 4 .\\heat1DMPI.exe 101 100","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003empiexec.exe\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-n\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e4\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #D7BA7D\u0022\u003e\\h\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003eeat1DMPI.exe\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e101\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>mpiexec.exe -n 4 .\heat1DMPI.exe 101 100</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">mpiexec.exe</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-n</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">4</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">.</span><span style="color: #D7BA7D">\h</span><span style="color: #CE9178">eat1DMPI.exe</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">101</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">100</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>We use the <code>mpiexec.exe</code> function here, which will launch our program. We provide it here with the command line argument <code>-n 4</code>, which means that we want to run our code with 4 processors in total.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Afterwards, we can specify the executable with its command line arguments just as we have done before.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On UNIX, you may write something like this:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"mpiexec -n 4 heat1DMPI 101 100","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003empiexec\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-n\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e4\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003eheat1DMPI\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e101\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>mpiexec -n 4 heat1DMPI 101 100</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">mpiexec</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-n</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">4</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">heat1DMPI</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">101</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">100</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Here, we have simply removed the <code>*.exe</code> extension from both the executable and the <code>mpiexec</code> command.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are, in-fact, two executables we can use to launch our MPI program, the second one is <code>mpirun</code>, which does not seem to be available in Microsoft MPI. However, on UNIX, depending on your installed MPI framework, you should also be able to use <code>mpirun</code> as:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"mpirun -np 4 heat1DMPI 101 100","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003empirun\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e-np\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e4\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003eheat1DMPI\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e101\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e100\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"bash","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":1,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(1 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>mpirun -np 4 heat1DMPI 101 100</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #DCDCAA">mpirun</span><span style="color: #D4D4D4"> </span><span style="color: #569CD6">-np</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">4</span><span style="color: #D4D4D4"> </span><span style="color: #CE9178">heat1DMPI</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">101</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">100</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>Using <code>mpirun</code> usually requires using <code>-np 4</code> instead of <code>-n 4</code>. These are the only differences, and it seems to be down to preference which one you use.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>You will find both in the wild, so I thought I would mention it here for completeness. Congratulations, you survived your crash course into code parallelisation. We have come a long way; let us now find out how good our parallelisations are when we benchmark them against one another. We'll do that in the next section.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-case-study-comparing-speed-up-for-different-parallelisation-strategies">Case study: Comparing speed-up for different parallelisation strategies</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In this section, I want to compare the different parallelisation strategies and see how they compare against one another. The first thing we should be doing is to make sure that all of the codes produce exactly the same results, and that the results they do produce are physically correct.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The following image shows all parallelisation strategies, including the sequential code, using different markers. I have plotted the results at three separate times, and each time uses a separate colour.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/temperature_from_heat1D_code.png" alt="A graph showing the temperature distribution within a domain going from 0 to 1 at different times. We see graphs for the temperature, which was calculated with the sequential code, as well as the parallelised versions using OpenMP, MPI, and CUDA. All curves match each other, indicating that the parallelisation produces the same results as the sequential code. " class="wp-image-5550" style="width:600px"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>From this figure, we can infer that all parallelisation approaches provide the same result as the sequential code, and, as the time goes to a very large value, we reach the correct physical behaviour. We could use an analytic solution now to compare our results against; however, we can also use physical intuition to validate our results.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If the boundary conditions are such that the temperature is 0 on the left boundary and 1 on the right boundary, then we would expect to have a linear distribution of the temperature within the domain. After 100 seconds, this is exactly the phenomenon we see. In between, the solution gradually approaches this state, and we see how the temperature profile develops to this linear distribution.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, in terms of correctness, we can state that all approaches seem to produce the correct physical behaviour. I have also computed the error norms (as we have seen in the codes before), and while I do not show them here, they are also all identical to within rounding errors.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Ok, so let's try our parallelised programs and see how they compare. I will use 1001 grid points in the domain, and I will let the solution run until a time of 100 seconds has been reached. At that point, the solution will have converged to a steady-state solution, as we have seen in the previous plot.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The table below shows the computational time for each approach. We have the time for the sequential code as well, which we are trying to beat. For OpenMP and MPI, we see the number of cores and how these affect the computational time. On the GPU side, I am using a single GPU to compute the solution.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If I wanted to use more than that, I would have to use MPI and CUDA together, where we have as many MPI processors as CUDA-capable GPUs, and all that these MPI cores would do is to communicate data between GPUs. This is slightly more involved and beside the point here in our introductory example, but if you want to use more than a single GPU, you will need to combine MPI and CUDA.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Without further ado, let us look at the computational results:</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table class="has-fixed-layout"><tbody><tr><td class="has-text-align-center" data-align="center"><strong>CPU cores</strong></td><td class="has-text-align-center" data-align="center"><strong>GPUs</strong></td><td class="has-text-align-center" data-align="center"><strong>Sequential</strong></td><td class="has-text-align-center" data-align="center"><strong>OpenMP</strong></td><td class="has-text-align-center" data-align="center"><strong>MPI</strong></td><td class="has-text-align-center" data-align="center"><strong>CUDA</strong></td></tr><tr><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">0.126</td><td class="has-text-align-center" data-align="center">0.207</td><td class="has-text-align-center" data-align="center">0.228</td><td class="has-text-align-center" data-align="center">-</td></tr><tr><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">0.305</td><td class="has-text-align-center" data-align="center">34.8</td><td class="has-text-align-center" data-align="center">-</td></tr><tr><td class="has-text-align-center" data-align="center">4</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">0.406</td><td class="has-text-align-center" data-align="center">78.0</td><td class="has-text-align-center" data-align="center">-</td></tr><tr><td class="has-text-align-center" data-align="center">8</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">0.563</td><td class="has-text-align-center" data-align="center">132.2</td><td class="has-text-align-center" data-align="center">-</td></tr><tr><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">4.18</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>Brilliant, so the sequential code takes 0.126 seconds, while MPI and OpenMP cannot reach a better performance than 0.2 seconds and above. Even worse, on 8 cores, MPI takes 132.2 seconds. CUDA takes over 4 seconds.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What this table shows is that everything we have just discussed is a lie, parallelisation slows down your code, and I have wasted 10 years of my life learning about different parallelisation approaches. Or is it?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's look at the numbers closer. We see that using more cores, either with MPI or OpenMP, will increase the computational cost. While MPI certainly shows a drastic explosion in computational cost, OpenMP is more moderate, yet it is still noticeable.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We are using 1001 points here in our domain, meaning that if we use 8 cores in total, each domain will get about 125 elements to work on. Having 8 cores means that we have to exchange information between 8 processors. So, as the number of processors reduces, we have less work to do per processor, but we also have more communications to do because there are more processors. Both of these effects will dramatically increase the time spent on communications, and thus, we see a significant increase in total computational time using MPI.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Why does OpenMP not suffer from the same issue as badly? Well, it is a shared memory approach, and so we don't have to send individual data between processors; they can all see the same memory and read and write to it. The reason OpenMP's computational time increases is just from the overhead of having to manage a parallel region.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>After each <code>#pragma omp for</code>, we have an implicit barrier, meaning that all processors have to reach it together before they can continue. If you meet with your best friend at 6 pm, how likely is it that both of you arrive on time? What about if you meet with 10 friends? Do you think it is equally likely that everyone will arrive on time? Probably not, and the same is true for parallelisations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Threads, or processors, will arrive at implicit barriers at different times, and the more you have, the more chances there are that just a single processor will hold you up, and so the computational time increases slightly.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Remember what we said earlier about good efficiency in CFD solvers. I said that commercial CFD codes can scale well down to 50,000 cells per processor, and for each cell, we may perform a few computations, not just a single temperature update (we may compute pressure, temperature, density, and momentum, and potentially several times per time step using an implicit system of equations).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We are now trying to parallelise a code which, in our example, has as few as 125 cells per core. We can't expect good scalability in this case; communication will just be too expensive. Even worse, in this example, most of the cost is spent updating the solution in time. We go all the way to 100 seconds, and so our loop over space contains relatively few elements (1001), while we have to perform many iterations in time to get to 100 seconds.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If we truly want to test our parallelisation, we really need to increase the computations per processor, which means we need to increase the number of points per processor significantly. How about 100 million points in total? That should do. However, since we are using an explicit time integration, we will be limited by our CFL number, and so our time step will become very small. Instead of going back to 100 seconds, let's do a very small time increment, so that we really spend most of the time computing, not communicating.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>An end time of <code>1e-12</code> seems to work fine after some experimentation. This will mean that the solution itself will have barely updated, and so any attempt to compare it against the solution once the temperature has developed is pointless, and thus, the error we compute will be high. However, we are doing this now to test the parallelisation itself; we already know that the code works correctly.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The results for this end time using 100 million points (in total) are shown below:</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table class="has-fixed-layout"><tbody><tr><td class="has-text-align-center" data-align="center"><strong>CPU cores</strong></td><td class="has-text-align-center" data-align="center"><strong>GPUs</strong></td><td class="has-text-align-center" data-align="center"><strong>Sequential</strong></td><td class="has-text-align-center" data-align="center"><strong>OpenMP</strong></td><td class="has-text-align-center" data-align="center"><strong>MPI</strong></td><td class="has-text-align-center" data-align="center"><strong>CUDA</strong></td></tr><tr><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">50.6</td><td class="has-text-align-center" data-align="center">61.2</td><td class="has-text-align-center" data-align="center">55.7</td><td class="has-text-align-center" data-align="center">-</td></tr><tr><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">42.8</td><td class="has-text-align-center" data-align="center">43.3</td><td class="has-text-align-center" data-align="center">-</td></tr><tr><td class="has-text-align-center" data-align="center">4</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">30.4</td><td class="has-text-align-center" data-align="center">34.3</td><td class="has-text-align-center" data-align="center">-</td></tr><tr><td class="has-text-align-center" data-align="center">8</td><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">26.1</td><td class="has-text-align-center" data-align="center">27.8</td><td class="has-text-align-center" data-align="center">-</td></tr><tr><td class="has-text-align-center" data-align="center">0</td><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">-</td><td class="has-text-align-center" data-align="center">5.48</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>We see that the sequential code took 50.6 seconds now to compute. While both OpenMP and MPI show that they still require more time on a single processor, mainly due to all of the additional overhead of setting up the communications, they do start to reduce the computational cost as we increase the number of cores.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The following table shows the computed speed-up and efficiency of both OpenMP and MPI compared to the sequential code:</p>
<!-- /wp:paragraph -->

<!-- wp:table -->
<figure class="wp-block-table"><table class="has-fixed-layout"><thead><tr><th class="has-text-align-center" data-align="center">Number of Cores</th><th class="has-text-align-center" data-align="center" colspan="2">OpenMP</th><th class="has-text-align-center" data-align="center" colspan="2">MPI</th></tr></thead><tbody><tr><td class="has-text-align-center" data-align="center"></td><td class="has-text-align-center" data-align="center"><strong>Speed-up</strong></td><td class="has-text-align-center" data-align="center"><strong>Efficiency</strong></td><td class="has-text-align-center" data-align="center"><strong>Speed-up</strong></td><td class="has-text-align-center" data-align="center"><strong>Efficiency</strong></td></tr><tr><td class="has-text-align-center" data-align="center">1</td><td class="has-text-align-center" data-align="center">0.83</td><td class="has-text-align-center" data-align="center">0.83</td><td class="has-text-align-center" data-align="center">0.91</td><td class="has-text-align-center" data-align="center">0.91</td></tr><tr><td class="has-text-align-center" data-align="center">2</td><td class="has-text-align-center" data-align="center">1.18</td><td class="has-text-align-center" data-align="center">0.59</td><td class="has-text-align-center" data-align="center">1.17</td><td class="has-text-align-center" data-align="center">0.58</td></tr><tr><td class="has-text-align-center" data-align="center">4</td><td class="has-text-align-center" data-align="center">1.66</td><td class="has-text-align-center" data-align="center">0.42</td><td class="has-text-align-center" data-align="center">1.48</td><td class="has-text-align-center" data-align="center">0.37</td></tr><tr><td class="has-text-align-center" data-align="center">8</td><td class="has-text-align-center" data-align="center">1.94</td><td class="has-text-align-center" data-align="center">0.24</td><td class="has-text-align-center" data-align="center">1.82</td><td class="has-text-align-center" data-align="center">0.23</td></tr></tbody></table></figure>
<!-- /wp:table -->

<!-- wp:paragraph -->
<p>What we really care about here is the efficiency. It tells us how well we utilise our hardware to speed up our code. From the two previous tables, we see that we get barely about a speed-up of 2 using 8 cores, which is a pretty poor parallelisation.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This shows that explicit 1D code examples are difficult examples for parallelisation, as we are not spending enough time computing a solution, but rather communicating data between processors. However, if you go back to the discussion of Amdahl's law earlier in this article, we saw that getting good scalability is really difficult, and so for to demonstrate that, 1D code examples are actually quite useful to make this pain very visible.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What about CUDA? Those results are almost the same compared to the 1001 number of points and an end time of <code>1e-12</code>. This shows that CUDA, once the setup time has been accounted for, can scale really well across problem sizes. Once we saturate our GPU with enough work, it can work on it really efficiently, and this is one of the reasons we like to use it in parallel computing.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In CFD applications, we typically require a lot of memory (RAM) to fit large problems into it. While this used to be a problem in the past, when we started experimenting with consumer hardware GPUs (opposed to dedicated computing GPUs, which don't even come with HDMI outputs for monitors, as they are supposed to be used for computing only), the generative AI bubble has seen companies making massive investments into computing GPUs with an abundance of memory.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While it appears that the current AI bubble will burst (again ...), which ushered in a lot of investment into GPU hardware and computing facilities, it means that there is an opportunity for GPUs to be used for CFD applications on the cheap in the future, once new avenues are explored of how these can be used elsewhere.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Therefore, learning GPU parallelisation is a worthy route, not just in case the AI bubble bursts, but also due to a lot of companies making a transition to GPUs, some more serious than others. But one thing is clear: GPUs are here to stay and will become even more important in the future for CFD applications!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Hopefully, you have gotten a taste now for how parallelisations work, and you are familiar with performance bottlenecks like Amdahl's law and the need to really have a lot of computations to be performed in the first place before utilising parallelisations.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" id="aioseo-challenges-in-code-parallelisation-for-cfd-applications">Challenges in code parallelisation for CFD applications</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Before we finish this article, I want to discuss a few challenges we face when parallelising our code. In this section, I highlight some of the issues I think are worthy of consideration.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-parallelisations-of-multigrid-solvers">Parallelisations of multigrid solvers</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Ah, multigrids! They hold a special place in my heart. I have had many, many long discussions with my PhD supervisor during my PhD time about their usefulness, either at university or the local indian restaurant near our university that served an excellent (and yet non-traditional) Chicken Tikka Masala. They have now closed, and we have not just lost an excellent restaurant, but also <em>the</em> perfect debating ground for niche CFD topics! In any case ...</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While I believed (and still do) that multigrids are quite useful and should be used for CFD applications, my supervisor had some good arguments against them, which are all valid. But to me, the advantages still outweight the disadvantages (and the support for multigrids in solvers like Fluent, OpenFOAM, SU2 do back me up here), although it has to be said that multigrids do work best for pure <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-elliptic-flows" target="_blank" rel="noopener" title="">elliptic</a> partial differential equations, not a mix of elliptic and <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/what-are-hyperbolic-parabolic-and-elliptic-equations-in-cfd/#aioseo-hyperbolic-flows" target="_blank" rel="noopener" title="">hyperbolic</a>, as is the case for the Navier-Stokes equations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The following figure demonstrates what a multigrid does:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"800px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/multigrid_basics.png" alt="A basic representation of a multigrid with 4 different grid levels." class="wp-image-5550" style="width:800px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://www.researchgate.net/figure/The-examples-of-multigrid-schemes-The-V-cycle-is-the-basic-component-of-multigrid_fig2_4104513" target="_blank" rel="noopener" title="">Balewski <em>et al.</em> 2004</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>On the left, we see a couple of different grids (hence the name multigrid). On the top, we have the finest grid, and this is typically the grid that we have created with our mesh generator and read into our solver. The multigrid algorithm will now create a series of grids that have fewer cells on each level.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, if we had a 2D structured grid, as is shown in the example above, then we could combine 4 quad cells on the fine grid into a single quad cell on the next coarser grid. We then repeat the process by coarsening the grid until we only have a few cells left on the coarsest level, perhaps a few hundred or so.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once we have all of these different grids created, we start computing our solution on them. First, we start on the finest grid level and compute the solution for a few iterations. Even though the solution may not have converged on the finest grid level, we take this intermediate result and interpolate onto the next coarser grid. This is known as the restriction step.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We repeat the same procedure on the next coarser grid, i.e. we compute the solution (now based on the solution from the finer grid) for a few iterations, and then restrict (interpolate) the result onto the next coarser grid, and so on. Once we have reached the coarsest grid and we have finished updating the solution on it, we start going up the grid hierarchy again.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We take the results from the coarsest grid and interpolate it onto the next finer grid. We compute the solution here for a few iterations and then go to the next finer grid. We repeat this until we have reached the final (finest) grid, which is the original grid we started with. Going from a coarse to a finer grid is known as the prolongation step.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>SO why do we do this? There is a bit of theory behind multigrid, in which you can nicely show, mathematically, how a multigrid damps oscillations in your local error, but let's try to approach this from a more intuitive point of view. Imagine we are computing the pressure field (for which multigrids are typically used, as the pressure Poisson equation for incompressible flows has a pure elliptic character).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For an incompressible flow, changes in pressure are felt instantaneously everywhere in the domain (we could say that pressure changes propagate at an infinite speed, and this is a reasonable assumption as the propagation speed of pressure, i.e. the speed of sound, is typically much larger than the local flow velocities).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, we have a pressure disturbance in one part of the domain, and we want to make sure its effect is felt everywhere in the domain. If we iterate now over our finest grid level only, then the speed at which the pressure would propagate is determined by the CFL number. The CFL number is just a non-dimensional measure of how much information propagates from one cell to another.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For example, if the CFL number is 1, then a particle travelling with the local flow velocity would move exactly one cell width or height per iteration. If the CFL number is 10, then it moves 10 cell widths or heights. I have discussed this in much more depth in my article on <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/explicit-vs-implicit-time-integration-and-the-cfl-condition/#aioseo-a-graphical-representation-of-explicit-and-implicit-methods" target="_blank" rel="noopener" title="">time stepping and the CFL number</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For the sake of argument, let's assume we use an explicit time-stepping algorithm. In this case, we are limited to using a max CFL number of 1. On the finest grid, it will take quite some time (iterations) before pressure changes are propagated everywhere in the domain. For example, if I am solving my flow on a square domain with 100 cells in the x and y directions, it would take 100 iterations with a CFL number of 1 to propagate pressure changes from the left to the right boundary. If my CFL number is less, this value will increase.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>But now, let's bring our multigrid into play. Let's say we create 5 grid levels, where our original mesh had 100 cells in both the x and y direction. The next coarse grid may only have 50 cells in each direction. The next coarser grid will have 25 cells in each direction, the next coarser grid after that 12 cells, and the final grid only 6 cells in each direction.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If I now want to propagate the same pressure information from the left to the right boundary on the coarsest grid level, with a CFL number of 1, it will take me only 6 iterations, compared to the 100 iterations required on the finest level. Even better, the calculation on my now 6 by 6 grid will be much faster than my computations on my 100 by 100 grid.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, we can now summarise the core idea behind a multigrid solver. We restrict our solution to coarser and coarser grids, so that we reduce the computational cost and allow the solution to propagate faster through the domain. This creates a solution on the coarsest grid that has taken care of all necessary propagations, but the solution will be inaccurate, due to the coarse nature of the grid. We then prolong our solution back onto the finest grid to get back accuracy, without having to worry about solution propagation speed.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Just as a sidenote: The way in which we chain restriction and prolongation steps together can be changed arbitrarily, but there are a few common patterns used in multigrids, commonly known as the V-cycle, W-cycle, or F-cycle, which are shown in the following (and yes, if you want to be excentric, you may invent your own cycle and assign it an arbitrary letter, this is, after all, how PhD titles are earned!):</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/multigrid_cycles.png" alt="A schematic overview of different multigrid cycles, including the V, F, and W cycle." class="wp-image-5550" style="width:600px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://www.sciencedirect.com/science/article/abs/pii/S0010465518303916" target="_blank" rel="noopener" title="">Hawkes <em>et al.</em> 2019</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>So, now that we have an understanding of multigrids, let's bring that into the context of parallel computing. We perform the domain decomposition on the finest grid. That is the grid we were reading into our solver, or generating as part of the simulation. That is the grid on which we want to have the final solution.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This presents a unique problem: Once we start to coarsen our grid, we start to reduce the number of cells per sub-domain. This then results in communication times to be much greater than the computational times on the coarser grid levels, as there is simply less to compute with fewer cells. Thus, the parallel efficiency for each subsequent coarser grid level becomes worse, and we may even end up in a situation where the multigrid, which is supposed to speed up the solution, may in fact slow down our total simulation time.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For large-scale problems, which require efficient utilisation of parallel resources, there are two common approaches:</p>
<!-- /wp:paragraph -->

<!-- wp:list  -->
<ul class="wp-block-list">

<!-- wp:list-item -->
<li>Become a parallel multigrid wizard, ideally the authority in the world for all questions related to multigrids, or, if that is <em>difficult</em>

</li>
<!-- /wp:list-item -->
<!-- wp:list-item -->
<li>Avoid multigrids

</li>
<!-- /wp:list-item -->
</ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>The second option is, out of sheer practicality, the solution often employed. Common alternatives to the multigrid are Krylov subspace methods, which sound fancy, but you may know them better under the name of gradient-descent methods, such as the <a href="https://cfd.university/learn/how-to-compile-write-and-use-cfd-libraries-in-c/how-to-write-a-cfd-library-the-conjugate-gradient-class/#aioseo-the-conjugate-gradient-algorithm" target="_blank" rel="noopener" title="">Conjugate Gradient</a> method (which is by far the most popular method in this space).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That is not to say that people are not using multigrids. ANSYS Fluent makes use of multigrids even for the largest cases it can run. Their multigrid must have received a lot of attention. OpenFOAM allows you to use multigrids, but thus far, I haven't been able to see conclusive results demonstrating that it is just as efficient as Fluent when it comes to parallel efficiency.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Krylov subspace methods make your life a lot easier, so it is a good place to start. And, if you are writing your own code and you don't care about parallelisation (yet, you will eventually, I can promise you that!), there are plenty of easy-to-use libraries that ship with everything you'll need to use one of these methods. In C++, there are even a few <a href="https://cfd.university/learn/how-to-compile-write-and-use-cfd-libraries-in-c/understanding-static-dynamic-and-header-only-c-libraries/#aioseo-header-only-libraries" target="_blank" rel="noopener" title="">header-only</a> libraries, which make their usage particularly easy. My favourite: <a href="https://libeigen.gitlab.io/eigen/docs-nightly/group__TopicSparseSystems.html" target="_blank" rel="noopener" title="">Eigen</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We don't speak of <a href="https://petsc.org/release/" target="_blank" rel="noopener" title="">PETSc</a> around here. The library, while capable for linear algebra applications, including a good range of Krylov subspace methods, follows a broken software development philosophy, meaning you are locked in and have to use software development tools that were developed a few decades ago, and have definitely stopped in development. If there were such a thing as a <em>use by</em> date, we would be long past that. <em>It is only coincidental that I first had to use this software when I was at Imperial College ...</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, multigrids are really powerful, but they come with strings attached. If you want to get good parallel performance out of them, then you are the person who is having to pay the price for it, either with your own development time or paying whoever currently is the authority on multigrids in the world to do it for you (shoot them if they use PETSc).</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-parallel-input-and-outputio">Parallel input and output (I/O)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In our code examples, we saw that a few operations had to be performed by only a single processor. For relatively modest problem sizes, this is OK, but the goal of parallel computing is to simulate large-scale problems that really need parallel resources.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I remember one day at work when we were testing an Airbus geometry. Since they were our main customer, we would test our code for their cases every now and then. My line manager booted up the latest version of our code, launched it, and then said: <em>"Who wants to go for lunch?"</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It took a good hour to read in the mesh that we were given, which, as you may have guessed, was not done in parallel (In fairness, I should say that we were testing a new implementation which required us to do it sequentially as the parallel version wasn't yet brought up to speed; it was an early prototype of our solver).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>When we are reading files, like the mesh, from disk, and only one processor is performing this task, then we have created a bottleneck. We may potentially wait for a long time before that operation is finished, but that is not the worst part. That single processor needs to have enough RAM (memory) available to read in the entire mesh before distributing it across processors. For very large cases, this quickly becomes unfeasible.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For these types of situations, it would be much more beneficial to be able to read data in parallel, and support for this is growing day by day. MPI has its own parallel input/output (I/O) capabilities, essentially reading raw data in parallel from disk, automatically assigning regions within the raw data which should be read by specific processors.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><a href="https://cfd.university/learn/the-complete-guide-to-structured-and-unstructured-mesh-reading-using-cgns/what-is-the-cgns-format-and-how-to-get-started/" target="_blank" rel="noopener" title="">CGNS</a> is another example that supports parallel input and output operations, which is really good, as you can store both your mesh and your solution with this file format. CGNS is using <a href="https://www.hdfgroup.org/solutions/hdf5/" target="_blank" rel="noopener" title="">HDF5</a> as its file compression algorithm, which itself provides excellent parallel input and output algorithms. Chances are that you have come across files ending in <code>*.h5</code>, which indicates that HDF5 was used.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>If you have to write your own solver and want to implement parallel input and output, I'd recommend using HDF5. It is fairly straightforward to use and gives you an easy and quick way to control your parallel efficiency. Even if you don't care about parallel input and output yet (again, you will eventually), HDF5 will future-proof you in that regard. The only downside is that you won't be able to read HDF5 files directly into post-processors like <a href="https://www.paraview.org/" target="_blank" rel="noopener" title="">Paraview</a> or <a href="https://tecplot.com/" target="_blank" rel="noopener" title="">Tecplot</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Hmm, HDF5 would make for a good topic to write about in my blog, don't you think? <em>Let me know in the comments below</em> (which I have disabled).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What we have said about mesh reading applies to solution writing as well. That is, once our simulation is done, we don't want to send all data to just one processor (which needs to have sufficient RAM!) and then have to wait for this one processor to finish all processing. We would like to do everything in parallel, and, again, the CGNS file format is probably your best friend here, unless you have developed your own parallel-capable file format (ideally based on HDF5).</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-coupling-of-multiphysics-solver">Coupling of multiphysics solver</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's go back all the way to the beginning (of this article), where we discussed Flynn's taxonomy. We looked at the 4 possible data/algorithmic parallelisation approaches, one of which was the multiple instructions, multiple data (MIMD) paradigm. The example I gave for MIMD was multiphysics, i.e. we may have a CFD solver that we want to couple with a structural solver.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this case, each solver may be run in parallel, but each solver may have wildly different requirements in terms of the computational resources that it requires. Take a simple elastic beam in a channel that deflects based on the pressure that builds up as a result of fluid being pushed through the channel. This is the classical <em>Hello World</em> example of Fluid-Structure Interactions (FSI), and serves as a good example here.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's say we have a somewhat larger channel and we have, say, 10 million elements in our mesh. Perhaps we want to solve this now with 64 cores on the fluid side. However, on the structural side, we may only have 10,000 elements within the beam itself.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The typical workflow is that we solve the fluid-side first, using all of our 64 cores, and then, we extract the pressure, impose it as a boundary condtion on our structural solver, and then run the structural solver, at which point the fluid solver isn't doing anything (as it will need to get the deflections from the structural solver first, from which it then can update the mesh and compute a new pressure field).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, we have now requested 64 cores, but our structural problem has only 100,000 cells in the structural mesh. Throwing 64 cores at the problem means that we have fewer than 2000 cells per processor, which will result in horrible scaling. In fact, with the knowledge that we now have on strong scaling, we may reasonably assume that using fewer processors may actually result in faster computations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>For the sake of argument, let's say we get good scaling using 4 cores on the structural side. This means that out of the 64 cores we have available, only 4 cores (or 6.25%) will be utilised. Thus, we have just created a bottleneck. No matter how good our parallel performance is on the fluid side (we may have just paid the internationally recognised expert on multgrids handsomely for getting an efficient multigrid to work in our code), it doesn't matter, as the structural solver now causes poor parallel performance.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, what are the possibilities out of that dilemma? Well, the dilemma as such isn't actually that much of a problem, at least in this case. The structural solver will take a lot less computational time than our CFD solver, so even if we only use 4 cores as in this example, we probably still get good scaling, but this is not guaranteed (for example, if we include composites, non-linear structural effects, which will make the structural side more complex and thus more computationally intensive).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>One solution we once tried (and, I think it is fair to say, failed at) is to use Smoothed Particle Hydrodynamics (SPH), where instead of using a computational grid, we use particles that are allowed to flow freely throughout the domain. The trajectory of these SPH particles is computed from the Navier-Stokes equations, but we can also assign them a different partial differential equation, and the particles may then behave like a solid.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, within the same domain, we can perform the fluid and structure update at the same time, within the same time step. There is a question about the boundary conditions that should be used, i.e. which pressure should the structural particles assume if the fluid hasn't finished computing it, and, vice versa, what is the particle deflection of the solid particles in a fixed structure? As we do so commonly in CFD, <em>lagging</em> is the answer (that is, we take the value from the previous time step or iteration).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I say we fail at it, but at the same time, I can conveniently point my finger at ISPH, the solver we were using, and claim it wasn't able to do what we wanted. We certainly saw differences between different solver versions (things improved with a newer version we tried), but ultimately, the software wasn't mature enough for our use case. Either that, or we were incapable of using the software properly. The truth is probably somewhere in the middle.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>My point stands, though. Once we start to couple together solvers that exchange information potentially at each time step, interfacing them becomes a difficult task, if we want to have good parallel efficiency (and we always want to have good parallel efficiency). Thankfully, this has been a problem for long enough for mature solutions to be developed. There are two that come to mind: <a href="https://precice.org/" target="_blank" rel="noopener" title="">preCISE</a> and <a href="https://taskflow.github.io/" target="_blank" rel="noopener" title="">Taskflow</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>preCISE essentially provides a mechanism to couple different solvers together that otherwise do not expose a common interface. In the world of programming, this is called an <em>adapter</em>, and the following image demonstrates what preCISE does, in a nutshell:</p>
<!-- /wp:paragraph -->

<!-- wp:image {"width":"600px","sizeSlug":"large","align":"center"} -->
<figure class="wp-block-image aligncenter size-large is-resized"><img src="https://raw.githubusercontent.com/cfd-university/articles/refs/heads/main/07_10-key-concepts-everyone-must-understand-in-cfd/assets/13_cfd-on-steroids-high-performance-computing-and-code-parallelisation/precise.png" alt="A schematic overview of Flynn's taxonomy into single and multiple data and instructions." class="wp-image-5550" style="width:600px"/><figcaption class="wp-element-caption">Figure reproduced from <a href="https://precice.org/" target="_blank" rel="noopener" title="">preCISE</a>.</figcaption></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>The adapter is defined in a <code>*.xml</code> file. Take the following example:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"\u0026lt;?xml version=\u00221.0\u0022 encoding=\u0022UTF-8\u0022 ?\u003e\n\u0026lt;precice-configuration\u003e\n  \u0026lt;log\u003e\n    \u0026lt;sink\n      filter=\u0022%Severity% \u003e debug and %Rank% = 0\u0022\n      format=\u0022\u002d\u002d-[precice] %ColorizedSeverity% %Message%\u0022\n      enabled=\u0022true\u0022 /\u003e\n  \u0026lt;/log\u003e\n\n  \u0026lt;data:vector name=\u0022Force\u0022 /\u003e\n  \u0026lt;data:vector name=\u0022Displacement\u0022 /\u003e\n\n  \u0026lt;mesh name=\u0022Fluid-Mesh\u0022 dimensions=\u00222\u0022\u003e\n    \u0026lt;use-data name=\u0022Force\u0022 /\u003e\n    \u0026lt;use-data name=\u0022Displacement\u0022 /\u003e\n  \u0026lt;/mesh\u003e\n\n  \u0026lt;mesh name=\u0022Solid-Mesh\u0022 dimensions=\u00222\u0022\u003e\n    \u0026lt;use-data name=\u0022Displacement\u0022 /\u003e\n    \u0026lt;use-data name=\u0022Force\u0022 /\u003e\n  \u0026lt;/mesh\u003e\n\n  \u0026lt;participant name=\u0022Fluid\u0022\u003e\n    \u0026lt;provide-mesh name=\u0022Fluid-Mesh\u0022 /\u003e\n    \u0026lt;receive-mesh name=\u0022Solid-Mesh\u0022 from=\u0022Solid\u0022 /\u003e\n    \u0026lt;read-data name=\u0022Displacement\u0022 mesh=\u0022Fluid-Mesh\u0022 /\u003e\n    \u0026lt;write-data name=\u0022Force\u0022 mesh=\u0022Fluid-Mesh\u0022 /\u003e\n    \u0026lt;mapping:rbf direction=\u0022read\u0022 from=\u0022Solid-Mesh\u0022 to=\u0022Fluid-Mesh\u0022 constraint=\u0022consistent\u0022\u003e\n      \u0026lt;basis-function:thin-plate-splines /\u003e\n    \u0026lt;/mapping:rbf\u003e\n    \u0026lt;mapping:rbf direction=\u0022write\u0022 from=\u0022Fluid-Mesh\u0022 to=\u0022Solid-Mesh\u0022 constraint=\u0022conservative\u0022\u003e\n      \u0026lt;basis-function:thin-plate-splines /\u003e\n    \u0026lt;/mapping:rbf\u003e\n  \u0026lt;/participant\u003e\n\n  \u0026lt;participant name=\u0022Solid\u0022\u003e\n    \u0026lt;provide-mesh name=\u0022Solid-Mesh\u0022 /\u003e\n    \u0026lt;read-data name=\u0022Force\u0022 mesh=\u0022Solid-Mesh\u0022 /\u003e\n    \u0026lt;write-data name=\u0022Displacement\u0022 mesh=\u0022Solid-Mesh\u0022 /\u003e\n    \u0026lt;watch-point mesh=\u0022Solid-Mesh\u0022 name=\u0022Flap-Tip\u0022 coordinate=\u00220.25;0.0\u0022 /\u003e\n    \u0026lt;export:vtk directory=\u0022precice-exports\u0022 /\u003e\n  \u0026lt;/participant\u003e\n\n  \u0026lt;m2n:sockets acceptor=\u0022Fluid\u0022 connector=\u0022Solid\u0022 exchange-directory=\u0022..\u0022 /\u003e\n\n  \u0026lt;coupling-scheme:serial-explicit\u003e\n    \u0026lt;time-window-size value=\u00222.5e-2\u0022 /\u003e\n    \u0026lt;max-time value=\u00222.5\u0022 /\u003e\n    \u0026lt;participants first=\u0022Solid\u0022 second=\u0022Fluid\u0022 /\u003e\n    \u0026lt;exchange data=\u0022Force\u0022 mesh=\u0022Solid-Mesh\u0022 from=\u0022Fluid\u0022 to=\u0022Solid\u0022 /\u003e\n    \u0026lt;exchange data=\u0022Displacement\u0022 mesh=\u0022Solid-Mesh\u0022 from=\u0022Solid\u0022 to=\u0022Fluid\u0022 /\u003e\n  \u0026lt;/coupling-scheme:serial-explicit\u003e\n\u0026lt;/precice-configuration\u003e","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;?\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003exml\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e version\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;1.0\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003e encoding\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;UTF-8\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e?\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eprecice-configuration\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003elog\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003esink\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efilter\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;%Severity% \u0026gt; debug and %Rank% = 0\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eformat\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;\u002d\u002d-\u0026#91;precice\u0026#93; %ColorizedSeverity% %Message%\u0026quot;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eenabled\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;true\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;/\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003elog\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edata:vector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Force\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003edata:vector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Displacement\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edimensions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;2\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003euse-data\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Force\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003euse-data\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Displacement\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;/\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edimensions\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;2\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003euse-data\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Displacement\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003euse-data\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Force\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;/\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eparticipant\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eprovide-mesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003ereceive-mesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efrom\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eread-data\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Displacement\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003ewrite-data\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Force\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003emapping:rbf\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edirection\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;read\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efrom\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003econstraint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;consistent\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003ebasis-function:thin-plate-splines\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;/\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003emapping:rbf\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003emapping:rbf\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edirection\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;write\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efrom\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003econstraint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;conservative\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e      \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003ebasis-function:thin-plate-splines\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;/\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003emapping:rbf\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;/\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eparticipant\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eparticipant\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eprovide-mesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eread-data\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Force\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003ewrite-data\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Displacement\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003ewatch-point\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ename\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Flap-Tip\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003ecoordinate\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;0.25;0.0\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eexport:vtk\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edirectory\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;precice-exports\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;/\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eparticipant\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003em2n:sockets\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eacceptor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003econnector\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eexchange-directory\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;..\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003ecoupling-scheme:serial-explicit\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003etime-window-size\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003evalue\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;2.5e-2\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003emax-time\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003evalue\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;2.5\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eparticipants\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efirst\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003esecond\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eexchange\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edata\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Force\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efrom\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eexchange\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003edata\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Displacement\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003emesh\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid-Mesh\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efrom\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Solid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e=\u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026quot;Fluid\u0026quot;\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;/\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003ecoupling-scheme:serial-explicit\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026lt;/\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eprecice-configuration\u003c/span\u003e\u003cspan style=\u0022color: #808080\u0022\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"xml","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":53,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>&lt;?xml version="1.0" encoding="UTF-8" ?>
&lt;precice-configuration>
  &lt;log>
    &lt;sink
      filter="%Severity% > debug and %Rank% = 0"
      format="---&#91;precice&#93; %ColorizedSeverity% %Message%"
      enabled="true" />
  &lt;/log>

  &lt;data:vector name="Force" />
  &lt;data:vector name="Displacement" />

  &lt;mesh name="Fluid-Mesh" dimensions="2">
    &lt;use-data name="Force" />
    &lt;use-data name="Displacement" />
  &lt;/mesh>

  &lt;mesh name="Solid-Mesh" dimensions="2">
    &lt;use-data name="Displacement" />
    &lt;use-data name="Force" />
  &lt;/mesh>

  &lt;participant name="Fluid">
    &lt;provide-mesh name="Fluid-Mesh" />
    &lt;receive-mesh name="Solid-Mesh" from="Solid" />
    &lt;read-data name="Displacement" mesh="Fluid-Mesh" />
    &lt;write-data name="Force" mesh="Fluid-Mesh" />
    &lt;mapping:rbf direction="read" from="Solid-Mesh" to="Fluid-Mesh" constraint="consistent">
      &lt;basis-function:thin-plate-splines />
    &lt;/mapping:rbf>
    &lt;mapping:rbf direction="write" from="Fluid-Mesh" to="Solid-Mesh" constraint="conservative">
      &lt;basis-function:thin-plate-splines />
    &lt;/mapping:rbf>
  &lt;/participant>

  &lt;participant name="Solid">
    &lt;provide-mesh name="Solid-Mesh" />
    &lt;read-data name="Force" mesh="Solid-Mesh" />
    &lt;write-data name="Displacement" mesh="Solid-Mesh" />
    &lt;watch-point mesh="Solid-Mesh" name="Flap-Tip" coordinate="0.25;0.0" />
    &lt;export:vtk directory="precice-exports" />
  &lt;/participant>

  &lt;m2n:sockets acceptor="Fluid" connector="Solid" exchange-directory=".." />

  &lt;coupling-scheme:serial-explicit>
    &lt;time-window-size value="2.5e-2" />
    &lt;max-time value="2.5" />
    &lt;participants first="Solid" second="Fluid" />
    &lt;exchange data="Force" mesh="Solid-Mesh" from="Fluid" to="Solid" />
    &lt;exchange data="Displacement" mesh="Solid-Mesh" from="Solid" to="Fluid" />
  &lt;/coupling-scheme:serial-explicit>
&lt;/precice-configuration></textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #808080">&lt;?</span><span style="color: #569CD6">xml</span><span style="color: #9CDCFE"> version</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;1.0&quot;</span><span style="color: #9CDCFE"> encoding</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;UTF-8&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">?&gt;</span></span>
<span class="line"><span style="color: #808080">&lt;</span><span style="color: #569CD6">precice-configuration</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">log</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">sink</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">filter</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;%Severity% &gt; debug and %Rank% = 0&quot;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">format</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;---&#91;precice&#93; %ColorizedSeverity% %Message%&quot;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #9CDCFE">enabled</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;true&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;/</span><span style="color: #569CD6">log</span><span style="color: #808080">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">data:vector</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Force&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">data:vector</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Displacement&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">mesh</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">dimensions</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;2&quot;</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">use-data</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Force&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">use-data</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Displacement&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;/</span><span style="color: #569CD6">mesh</span><span style="color: #808080">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">mesh</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">dimensions</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;2&quot;</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">use-data</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Displacement&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">use-data</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Force&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;/</span><span style="color: #569CD6">mesh</span><span style="color: #808080">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">participant</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid&quot;</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">provide-mesh</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">receive-mesh</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">from</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">read-data</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Displacement&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">mesh</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">write-data</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Force&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">mesh</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">mapping:rbf</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">direction</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;read&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">from</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">to</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">constraint</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;consistent&quot;</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">basis-function:thin-plate-splines</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;/</span><span style="color: #569CD6">mapping:rbf</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">mapping:rbf</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">direction</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;write&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">from</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">to</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">constraint</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;conservative&quot;</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">      </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">basis-function:thin-plate-splines</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;/</span><span style="color: #569CD6">mapping:rbf</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;/</span><span style="color: #569CD6">participant</span><span style="color: #808080">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">participant</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid&quot;</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">provide-mesh</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">read-data</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Force&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">mesh</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">write-data</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Displacement&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">mesh</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">watch-point</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">mesh</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">name</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Flap-Tip&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">coordinate</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;0.25;0.0&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">export:vtk</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">directory</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;precice-exports&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;/</span><span style="color: #569CD6">participant</span><span style="color: #808080">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">m2n:sockets</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">acceptor</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">connector</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">exchange-directory</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;..&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">coupling-scheme:serial-explicit</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">time-window-size</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">value</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;2.5e-2&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">max-time</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">value</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;2.5&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">participants</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">first</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">second</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">exchange</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">data</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Force&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">mesh</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">from</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">to</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">    </span><span style="color: #808080">&lt;</span><span style="color: #569CD6">exchange</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">data</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Displacement&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">mesh</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid-Mesh&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">from</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Solid&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #9CDCFE">to</span><span style="color: #D4D4D4">=</span><span style="color: #CE9178">&quot;Fluid&quot;</span><span style="color: #D4D4D4"> </span><span style="color: #808080">/&gt;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #808080">&lt;/</span><span style="color: #569CD6">coupling-scheme:serial-explicit</span><span style="color: #808080">&gt;</span></span>
<span class="line"><span style="color: #808080">&lt;/</span><span style="color: #569CD6">precice-configuration</span><span style="color: #808080">&gt;</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>This file is for coupling a fluid and a solid solver together for a fluid-structure interaction simulation. On lines 10-11, we say that <code>Force</code> and <code>Displacement</code> are the variables we want to exchange. We then also define our different grids (lines 13-16 for the fluid mesh and lines 18-21 for our solid mesh), which have dimensions attached to them, as well as data that they should be using (which we specified before).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>On lines 23-34, we create a fluid solver <em>participant</em>, where we state that we want to read in displacement data (line 26), and it should be applied to our fluid mesh. We also state here that force data should be extracted from this fluid mesh on line 27. We then specify how we want to map data from the solid to the fluid mesh, and vice versa, as shown on lines 28-33. We create a similar <em>participant</em> for the solid solver on lines 36-42.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Finally, we have to define our coupling scheme, which we do on lines 46-52. This is a rather simple example, but it shows you the basic working principle behind preCISE. The framework will now take and process this configuration file and make sure that the relevant fluid and structure solver will expose the required data, and it will map data from one mesh onto the other for each respective solver to consume.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>TaskFlow, on the other hand, is slightly different. The name is actually quite good, in that TaskFlow provides us with a mechanism to specify different tasks and how they depend on each other. For example, take a 1-way fluid-structure simulation, where we first run the fluid solver to get forces, and then the solid solver to get displacements. Using a 1-way coupling scheme, this is all we do (opposed to a 2-way coupling scheme, where we also map displacements back to the fluid solver and then iterate over time on both solvers).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The following example code shows how a 1-way fluid structure interaction problem may be set up:</p>
<!-- /wp:paragraph -->

<!-- wp:kevinbatdorf/code-block-pro {"code":"#include \u0026lt;taskflow/taskflow.hpp\u003e\n#include \u0026lt;fluid/solver.hpp\u003e\n#include \u0026lt;solid/solver.hpp\u003e\n\nint main() {\n  \n  tf::Executor executor;\n  tf::Taskflow taskflow;\n\n  FluidSolver fluid();\n  SolidSolver solid();\n\n  auto [fluidTask, solidTask] = taskflow.emplace(\n    [] () { fluid.run(); },\n    [] () { solid.run(); },\n  );                                  \n                                      \n  fluidTask.precede(solidTask);                                     \n  executor.run(taskflow).wait(); \n\n  return 0;\n}","codeHTML":"\u003cpre class=\u0022shiki dark-plus\u0022 style=\u0022background-color: #1E1E1E\u0022 tabindex=\u00220\u0022\u003e\u003ccode\u003e\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;taskflow/taskflow.hpp\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;fluid/solver.hpp\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003e#include\u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #CE9178\u0022\u003e\u0026lt;solid/solver.hpp\u0026gt;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eint\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003emain\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e() {\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003etf\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::Executor executor;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #4EC9B0\u0022\u003etf\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e::Taskflow taskflow;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  FluidSolver \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003efluid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  SolidSolver \u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003esolid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e();\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #569CD6\u0022\u003eauto\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u0026#91;fluidTask, solidTask\u0026#93; = \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003etaskflow\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eemplace\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [] () { \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efluid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003erun\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(); },\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e    [] () { \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003esolid\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003erun\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(); },\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  );                                  \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e                                      \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003efluidTask\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003eprecede\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(solidTask);                                     \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #9CDCFE\u0022\u003eexecutor\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e.\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003erun\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(taskflow).\u003c/span\u003e\u003cspan style=\u0022color: #DCDCAA\u0022\u003ewait\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e(); \u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e  \u003c/span\u003e\u003cspan style=\u0022color: #C586C0\u0022\u003ereturn\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e \u003c/span\u003e\u003cspan style=\u0022color: #B5CEA8\u0022\u003e0\u003c/span\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e;\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\u0022line\u0022\u003e\u003cspan style=\u0022color: #D4D4D4\u0022\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e","language":"cpp","theme":"dark-plus","bgColor":"#1E1E1E","textColor":"#D4D4D4","fontSize":".875rem","fontFamily":"Code-Pro-JetBrains-Mono","lineHeight":"1.25rem","clampFonts":false,"lineNumbers":true,"headerType":"none","disablePadding":false,"footerType":"none","enableMaxHeight":false,"seeMoreType":"","seeMoreString":"","seeMoreAfterLine":"","seeMoreTransition":false,"seeMoreCollapse":false,"seeMoreCollapseString":"","highestLineNumber":22,"highlightingHover":false,"lineHighlightColor":"rgba(234, 191, 191, 0.2)","copyButton":true,"copyButtonType":"heroicons","copyButtonUseTextarea":true,"useTabs":false} -->
<div class="wp-block-kevinbatdorf-code-block-pro cbp-has-line-numbers" data-code-block-pro-font-family="Code-Pro-JetBrains-Mono" style="font-size:.875rem;font-family:Code-Pro-JetBrains-Mono,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;--cbp-line-number-color:#D4D4D4;--cbp-line-number-width:calc(2 * 0.6 * .875rem);line-height:1.25rem;--cbp-tab-width:2;tab-size:var(--cbp-tab-width, 2)"><span role="button" tabindex="0" style="color:#D4D4D4;display:none" aria-label="Copy" class="code-block-pro-copy-button"><pre class="code-block-pro-copy-button-pre" aria-hidden="true"><textarea class="code-block-pro-copy-button-textarea" tabindex="-1" aria-hidden="true" readonly>#include &lt;taskflow/taskflow.hpp>
#include &lt;fluid/solver.hpp>
#include &lt;solid/solver.hpp>

int main() {
  
  tf::Executor executor;
  tf::Taskflow taskflow;

  FluidSolver fluid();
  SolidSolver solid();

  auto &#91;fluidTask, solidTask&#93; = taskflow.emplace(
    [] () { fluid.run(); },
    [] () { solid.run(); },
  );                                  
                                      
  fluidTask.precede(solidTask);                                     
  executor.run(taskflow).wait(); 

  return 0;
}</textarea></pre><svg xmlns="http://www.w3.org/2000/svg" style="width:24px;height:24px" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path class="with-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"></path><path class="without-check" stroke-linecap="round" stroke-linejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg></span><pre class="shiki dark-plus" style="background-color: #1E1E1E" tabindex="0"><code><span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;taskflow/taskflow.hpp&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;fluid/solver.hpp&gt;</span></span>
<span class="line"><span style="color: #C586C0">#include</span><span style="color: #569CD6"> </span><span style="color: #CE9178">&lt;solid/solver.hpp&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #569CD6">int</span><span style="color: #D4D4D4"> </span><span style="color: #DCDCAA">main</span><span style="color: #D4D4D4">() {</span></span>
<span class="line"><span style="color: #D4D4D4">  </span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">tf</span><span style="color: #D4D4D4">::Executor executor;</span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #4EC9B0">tf</span><span style="color: #D4D4D4">::Taskflow taskflow;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  FluidSolver </span><span style="color: #DCDCAA">fluid</span><span style="color: #D4D4D4">();</span></span>
<span class="line"><span style="color: #D4D4D4">  SolidSolver </span><span style="color: #DCDCAA">solid</span><span style="color: #D4D4D4">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #569CD6">auto</span><span style="color: #D4D4D4"> &#91;fluidTask, solidTask&#93; = </span><span style="color: #9CDCFE">taskflow</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">emplace</span><span style="color: #D4D4D4">(</span></span>
<span class="line"><span style="color: #D4D4D4">    [] () { </span><span style="color: #9CDCFE">fluid</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">run</span><span style="color: #D4D4D4">(); },</span></span>
<span class="line"><span style="color: #D4D4D4">    [] () { </span><span style="color: #9CDCFE">solid</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">run</span><span style="color: #D4D4D4">(); },</span></span>
<span class="line"><span style="color: #D4D4D4">  );                                  </span></span>
<span class="line"><span style="color: #D4D4D4">                                      </span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">fluidTask</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">precede</span><span style="color: #D4D4D4">(solidTask);                                     </span></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #9CDCFE">executor</span><span style="color: #D4D4D4">.</span><span style="color: #DCDCAA">run</span><span style="color: #D4D4D4">(taskflow).</span><span style="color: #DCDCAA">wait</span><span style="color: #D4D4D4">(); </span></span>
<span class="line"></span>
<span class="line"><span style="color: #D4D4D4">  </span><span style="color: #C586C0">return</span><span style="color: #D4D4D4"> </span><span style="color: #B5CEA8">0</span><span style="color: #D4D4D4">;</span></span>
<span class="line"><span style="color: #D4D4D4">}</span></span></code></pre></div>
<!-- /wp:kevinbatdorf/code-block-pro -->

<!-- wp:paragraph -->
<p>You see, at its core, TaskFlow is just a sort of task scheduling application. We first have to import the TaskFlow header (which is a header-only library, convenient to get it started quickly without compilation needed). We then have to define a task and an executer object, which we do on lines 7-8. I also define here some dummy fluid and solid solver on lines 10-11, solely for demonstration purposes.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We then start to set up our tasks. On lines 13-16, we set up the <code>fluidTask</code> and <code>solidTask</code>, as well as defining what these tasks should be doing. In this simple example, we simply call the respective <code>run()</code> function on each solver, but we could place more complex C++ code here. On line 18, we say that the <code>fluidTask</code> has to run before the <code>solidTask</code>, and then we give the tasks to the executor, who will run the tasks for us.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So far, we haven't used any parallelism, but TaskFlow does integrate with parallelisation frameworks and thus provides support for parallelism between tasks. It provides higher-level functions (or flows, as they seem to be called) which take away some of the lower-level function calls. For example, the <code>cudaFlow</code> workflow provides functions for copying data to and from the CPU and GPU.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The power of TaskFlow is that you can define tasks (like the execution of one time step inside a fluid solver) as an abstract task (i.e. we don't care how it is achieved; that is the responsibility of the fluid solver), all we care about is how and when the task is executed, for example, after the solid solver has provided displacement information.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>TaskFlow supports conditional task execution, which may be useful, for example, for checking the time at which the fluid solver is currently at, and then initiating data transfer (which itself is another task) between the fluid and the solid solver at particular points in time. If you want to get a more thorough introduction, have a look at their 2020 CppCon talk (ah, CppCon, another guilty pleasure of mine during lockdown ... I think I must have watched half of the conference):</p>
<!-- /wp:paragraph -->

<!-- wp:embed -->
<iframe src="https://www.youtube.com/embed/MX15huP5DsM?si=h__ZOo8NieHuV9-Y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen style="width:100%; aspect-ratio:16/9; border:0;"></iframe>
<!-- /wp:embed -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-parallelisations-for-adaptive-mesh-refinementamr">Parallelisations for adaptive mesh refinement (AMR)</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Adaptive mesh refinement itself is an area that is far from being a solved issue. At its core, adaptive mesh refinement allows us to refine a mesh in regions where we have large gradients (either through re-meshing or splitting of cells into smaller elements). The canonical example is shockwaves, and we probably want to resolve areas in which shockwaves occur. Another example may be the adaptive refinement of inflation layers, specifically the height of the first cell from the wall, though that is a much tougher problem to solve.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Sure, if I run a 2D airfoil example and I run some adaptive mesh refinement tutorials from the developers, I may be (mis)le(a)d to think that adaptive mesh refinement is easy, but it really isn't always that straightforward. The main issue, for me at least, is how we specify a criterion by which we select mesh cells that need to be adapted. For classic examples, like shockwaves, there may be good indicators we can use, for example, the gradient of the density field.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, even if we do that, we still need to specify a threshold above which we want to refine a cell. So, what is a good value for the gradient above which we want to refine our cells? Keep in mind that the gradient itself is computed as the difference between two points divided by their distance. The distance is typically related to the cell size. Thus, the gradient is dependent on the cell size itself, and for varying cell sizes in our mesh, we get different gradient values across shock waves.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, my question to you, again, is how we can define a value that will, ideally, only select cells in the region of shock waves and not anywhere else? This is a difficult task, at least if we want to generalise this for applications across various grids (and refinement criteria).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Or let's say we are interested in determining the separation point on an airfoil that hasn't stalled yet, but has a high angle of attack. A RANS model should be able to give us reasonably good predictions here, but we probably want to have good mesh refinement around the point of separation. What is a suitable criterion here? The local wall shear stresses are zero at the point of separation, so we may specify a band between positive and negative wall shear stresses in which we want to refine our mesh.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>However, as we refine our mesh, the separation poitn may move, and so we have to dynamically coarsen and refine our mesh, which may be indeed feasible but either result in costly mesh refinement steps, or, an infinite loop in which we adapt/coarsen our mesh as a result of a moving separation point, which may or may not be due to the mesh refinement; we may simply pick up a transient behaviour. But how can we distinguish between a transient response and a response to our mesh refinement? We can't.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another issue is the cell count explosion. If we are dealing with a 3D case, and, for the sake of argument, let's say that we use hexa elements in our mesh, each cell that is refined will be split into 8 cells. If we target 100,000 cells to be refined, then we have created 700,000 new cells (on top of the already 100,000 existing cells). If we don't have a good mechanism by which we can select only those cells we want to refine (which is difficult), we will end up with lots of additional cells.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>A common solution to this problem is to limit the total number of new cells that can be created as part of the adaptive mesh refinement strategy, but how do we know that we have achieved sufficient refinement with this arbitrary cell limit? Well, in short, we don't, and so while we may believe that we have reduced uncertainties by refining cells in regions of strong gradients, all that we have done is trade one uncertainty for another.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><em>Usually</em>, uncertainties will decrease, and <em>usually</em>, results will improve, even if we have a sub-optimal adaptive mesh refinement strategy (i.e., a mechanism to select relevant cells to refine). But you wouldn't write a report saying, for example, that your lift coefficient should <em>usually</em> be expected to be around 0.425. CFD is full of uncertainties, and our job is to reduce uncertainties where we can, not introduce new ones.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The goal is not to produce colourful images, which is often the case when we get started with CFD (at that stage, it is fine; we need to start somewhere), but as we gain expertise, our goal shifts towards generating high-quality simulations, which require uncertainty management. Adaptive mesh refinement works against us, to some degree, on that front.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now, let's bring this back to parallel computing. We may initially subdivide our mesh into [katex]N[/katex] sub-domains. Each sub-domain is receiving an equal number of cells to work on. After some iterations, we may decide to refine our mesh, and after the first mesh adaptation is done, we will have, potentially, a wild difference between the number of cells on each sub-domain. This will then result in poor load balancing.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The solution to this problem is to dynamically adjust the number of cells per sub-domain, which results in better load balancing. However, this task is a costly one, and so any time we gain through improved parallel efficiency (i.e. by having a better load balance) must be offset by the time it takes to redistribute cells. In practice, we would set a tolerance for the load balance, after which repartition is required.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>A good default value may be 10%, which states that we allow the number of cells between sub-domains to vary by 10% before redistributing cells across processors. And, as a side note, the same issue will occur not only during adaptive mesh refinement, but also during meshing in parallel in general. So, if we run our meshing algorithms in parallel, which, by definition, adaptively create new cells, the number of cells between sub-domains may quickly diverge and require a number of repartitioning steps.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In short, adaptive mesh refinement, or any other kind of dynamic mesh creation, will result in load balance issues, and load balancing is the number one reason that kills performance. It doesn't matter how much effort we put into making our code efficient. If we have poor load balancing, all of this effort is in vain. It is the same as buying a Ferrari for its speed, but then only driving it within the city. What's the point of the additional horse powers?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I presume showing-off is a large part of it, but I wouldn't know as a loyal Nissan customer (loyal as in my wife keeps making purchasing decisions that result in us buying Nissan cars, not as in I love the car or the brand; my car keeps falling apart in places I didn't even knew existed (but my mechanic is a very resourceful person when it comes to finding faults that need immediate replacement)).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>My local Nissan dealer used to do the service for us and always bragged about their 100% original Nissan parts. But judging by how frequently they fail, I am much happier with 0% original Nissan parts. Anyways, given the recent news about <a href="https://economictimes.indiatimes.com/news/international/us/is-nissan-heading-for-bankruptcy-will-honda-buy-the-iconic-japanese-auto-maker-heres-what-reports-are-saying/articleshow/116142643.cms?from=mdr" target="_blank" rel="noopener" title="">Nissan's potential bankruptcy</a>, this may be a future we all have to embrace.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Personally, I'll be using this as ammunition to convince my wife that it is time to upgrade from Japanese cars to Korean cars.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Update: We now own a Hyundai Sonata, but it was bought and registered in South Korea. I suppose it will be difficult to DLH it to the UK.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Note: I'm sure you came to this place to learn more about my car purchasing struggles. Life isn't <em>just</em> about CFD, it is also about Tom's first-world problems, well, at least this website is. Let's be honest, we are almost at the end of this article. How many people do you think will get this far into it?</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Anyway, I seem to have lost my train of thought now (I wonder why), let's say we have finished adaptive mesh refinement, and move on to the next and final issue.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 class="wp-block-heading" id="aioseo-issues-in-the-age-of-exascale-computing">Issues in the age of exascale computing</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Finally, let's talk about exascale computing. We have touched upon exascale computing in the introduction, that is, performing [katex]10^18[/katex] floating point operations per second. When this large number of operations per second is involved, problems of a whole new scale start to emerge. But in order to understand this, let us look at an example.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>According to the latest <a href="https://www.top500.org/" target="_blank" rel="noopener" title="">TOP500</a> list, ranking all of the registered high-performance computing (HPC) clusters in the world, the fastest cluster is <em>El Capitan</em> of Lawrence Livermore National Laboratory, featuring a peak performance of 1.8 ExaFLOPs across its 11,340,000 cores. Let's say we are granted access to the cluster, assuming full control over all 11,340,000 cores, and we are told we can do whatever we want with it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, naturally, we decided to run a <a href="https://cfd.university/learn/10-key-concepts-everyone-must-understand-in-cfd/the-origin-of-turbulence-and-direct-numerical-simulations-dns/#aioseo-direct-numerical-simulations-dns" target="_blank" rel="noopener" title="">direct numerical simulations (DNS)</a>, one of the persisting frontiers in CFD. Let's say we want to do something as benign as computing the lift and drag coefficient at a stall angle of attack. Surely, with 11,340,000, we ought to get some serious results. Well, we can do a simple back-of-the-envelope calculation to figure out what the largest Reynolds number is that we can simulate with this cluster.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>To do that, we need to consider which length scales we want to resolve. On the larger end, we have some large characteristic lengthscale [katex]L[/katex], which could be the airfoil's chord or some measure of the domain size. On the smaller scale, we need to resolve the Kolmogorov length scale [katex]\eta[/katex], that is, the smallest turbulent length scale. So, we need a grid that has elements small enough to resolve [katex]\eta[/katex] but which is, in dimension, large enough to capture [katex]L[/katex].</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We can now use the definition and some typical scaling behaviours for our lengthscales. The Kolmogorov length scale is defined as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\eta=\left(\frac{\nu^3}{\varepsilon}\right)^\frac{1}{4}
\tag{46}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Here, [katex]\nu[/katex] is the kinematic viscosity, and [katex]\varepsilon[/katex] is the dissipation. The dissipation itself scales well with the following correlation:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\varepsilon=\frac{U^3}{L}
\tag{47}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We want to express [katex]\eta[/katex] in terms of a Reynolds number given as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
Re=\frac{UL}{\nu}\tag{48}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>To do that, we insert Eq.(47) into Eq.(46), which results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\eta=\left(\frac{\nu^3}{U^3/L}\right)^\frac{1}{4}=\left(\frac{\nu^3}{U^3L^{-1}}\right)^\frac{1}{4}=\frac{\nu^\frac{3}{4}}{U^\frac{3}{4}L^{-\frac{1}{4}}}\tag{49}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We have [katex]L^{-\frac{1}{4}}[/katex] in the denominator, and if we can bring this into the form of [katex]L^{\frac{3}{4}}[/katex], then we have the inverse definition of the Reynolds number, raised to the power of [katex]3/4[/katex]. In order to get this lengthscale, and remembering the exponent rule [katex]a^n\cdot a^m = a^{n+m}[/katex], we expand the fraction by [katex]L/L[/katex], which results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\eta=\frac{\nu^\frac{3}{4}}{U^\frac{3}{4}L^{-\frac{1}{4}}}\frac{L^\frac{4}{4}}{L^\frac{4}{4}}\tag{50}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we combine the two length scales in the denominator and obtain:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
L^{-\frac{1}{4}}\cdot L^\frac{4}{4}= L^{-\frac{1}{4}+\frac{4}{4}}=L^{\frac{3}{4}}\tag{51}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Inserting this, we get:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
\eta=\frac{\nu^\frac{3}{4}}{U^\frac{3}{4}L^{\frac{3}{4}}}L^\frac{4}{4} = L \frac{\nu^\frac{3}{4}}{U^\frac{3}{4}L^{\frac{3}{4}}} = L \left(\frac{\nu}{UL}\right)^\frac{3}{4} = \frac{L}{Re^\frac{3}{4}}=L\cdot Re^{-\frac{3}{4}}
\tag{52}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>Now we know how [katex]\eta[/katex] scales with the Reynolds number. We can make use of this definition by now computing how many grid points we need in one direction to resolve both the largest length scale [katex]L[/katex] and the smallest length scale [katex]\eta[/katex]. This is defined as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
N_\text{cells per direction}=\frac{L}{\eta}
\tag{53}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>We know that we have to resolve [katex]\eta[/katex], so that is our smallest length scale. However, we also want to resolve [katex]L[/katex], and so we need to compute how many cells (of size [katex]\eta[/katex]) fit inside our largest lengthscale [katex]L[/katex]; hence, we divide [katex]\eta[/katex] by [katex]L[/katex]. And, if that is still not clear, for the sake of argument, let's say [katex]\eta=0.1mm[/katex], and [katex]L=1m[/katex], then, we need [katex]L/\eta=1/0.0001=10,000[/katex] cells in one direction to resolve both [katex]\eta[/katex] and [katex]L[/katex] at the same time.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, in order to compute the number of cells per direction, we have to insert Eq.(\tag{52}) into Eq.(53). This results in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
N_\text{cells per direction}=\frac{L}{L}Re^\frac{3}{4} = Re^\frac{3}{4}\tag{54}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is for one direction, but in order to get the total number of cells, we need to multiply the number of points in all three coordinate directions, resulting in:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
N_\text{total} = N_\text{cells per direction}^3 = \left(Re^\frac{3}{4}\right)^3=Re^\frac{9}{4}
\tag{55}
</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This number does not consider time stepping, but this is, as we will see in a second, also not really relevant here. It poses, in fact, a completely different problem that I'll return to. But let's finish off our example. Instead of assuming an arbitrary Reynolds number and then seeing how many grid points we can use, let's do it the other way around.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We know that <em>El Capitan</em> has 11,340,000 cores, and in our fictitious example, we were given all of them for our DNS. I also stated earlier that the best CFD solvers will scale well down to 50,000-100,000 cells per core. Taking a conservative pick, let's say that we want to run a DNS with 100,000 cells per core. We can now multiply that by our 11,340,000 cores and get a total mesh size of [katex]1.134\cdot 10^{12}[/katex] points, or 1.134 trillion points.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, it is 1.134 trillion points in English, <a href="https://painfulenglish.com/2020/05/23/billions-can-be-confusing/" target="_blank" rel="noopener" title="">but the Germans and French would say this is 1.134 billion points</a>. This used to confuse me when I learned English; now I find the Germans irritating. Ah, well, no party is complete without the presence of at least one German and one French. They'll keep spirits high!</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's go with [katex]1.134\cdot 10^{12}[/katex] grid points, which seems the least ambiguous. If that is the number of grid points that we can use, then we can compute the Reynolds number as:</p>
<!-- /wp:paragraph -->

<!-- wp:katex/display-block -->
<div class="wp-block-katex-display-block katex-eq" data-katex-display="true"><pre>
Re=N_\text{total}^\frac{4}{9}=\left(1,.134\cdot 12^{12}\right)^\frac{4}{9}\approx 230,000 \approx 2\cdot 10^5\tag{56}</pre></div>
<!-- /wp:katex/display-block -->

<!-- wp:paragraph -->
<p>This is laughable. Typical Reynolds numbers we achieve in aviation are around [katex]10^6[/katex] to [katex]10^7[/katex], and so even using the most potent super computer in the world, and assuming that we would be able to take over the entire system for our simulation, and that our code scales across the entire system without significant losses (all very strong assumptions), we would still fall one to two orders of magnitude short to simulate even a simple flow around an airfoil or wing, let alone an entire aircraft.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>OK, so perhaps full aircraft simulations are not what we are after, but even with a <em>modest</em> number of cores, say, 100,000 cores for a single simulation, which is far more feasible, we would be able to get up to Reynolds numbers of about [katex]Re=30,000[/katex]. This is, in realistic terms, what we can expect to be feasible with resources available in 2025. And this number is unlikely to change drastically in the near future, unless drastic changes to computer hardware are introduced (e.g. quantum computing).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>OK, so let's say we settle for a modest Reynolds number of 30,000; being able to use 100,000 cores provides a whole new range of issues. For starters, let's think about domain decomposition. We now have to efficiently distribute the mesh across 100,000 cores. If we perform the domain decomposition step in parallel, then, well, we likely have a lot of communications between sub-domains just to check if we have a good distribution of cells (for load balancing).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, our simulation may not even be the bottleneck; we may never get to it because the domain decomposition step just takes too long to finish.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I mentioned above that time stepping itself is also a problem. Why? As we saw in our simplified example for MPI, OpenMP, and CUDA, we really need to have lots of computations in parallel, and this only happens in space, that is, we can only parallelise computations in space across sub-domains, but not in time. We always compute one timestep after the other, which makes sense, but we could further enhance parallel efficiency if we could, somehow, parallelise our simulation in time as well.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Parallelisation in time is an ongoing research topic. At one point in my career, I saw it as a holy grail of parallel computing and devoted some time to learn about it, only to quickly realise that the limitations are likely too severe to ever overcome them for general-purpose CFD applications. There were good use cases for which parallelisation in time can be shown to yield good improvements, by not just parallelising the space loop but also the time loop, but these were, as far as I can tell, niche applications.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As far as I could tell, all applications used a simple model equation to demonstrate their effectiveness, but nothing was ever presented for the Navier-Stokes equations. Things may have changed, I may have missed a reference here or there, but the fact that parallelisation in time hasn't really been picked up as a mainstream research topic, despite its huge potential, probably is all you need to know about its true potential.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Don't get me wrong, if you feel like taking on the challenge and proving me wrong, I'd love for you to do that. I would be happy to accept that I am wrong if that means we get decent parallel-in-time performance for the Navier-Stokes equations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Another issue that we also touched upon is the fact that compute nodes are physically distributed in space. As we increase the number of cores, we increase the physical distance between compute nodes and thus the time it takes for information to travel through the network. Thus, just having a large number of cores available doesn't mean we can utilise them efficiently; we will always lose some performance as we increase the number of cores, and some weak scaling analysis can highlight that.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Thus, the issues we face in parallel computing in the age of exascale computing are a lack of mature software solutions for large-scale parallel computations, a hardware bottleneck in terms of network transfer speeds, as well as pretty tough requirements in terms of strong scaling performance of our code, to ensure it scales well across thousands of processors.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Remember Amdahl's law? It tells us how good our parallelisation needs to be to get efficient scaling across thousands of processors, and writing general-purpose CFD codes that scale well across thousands of processors is a challenge no one person alone can likely master.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":2} -->
<h2 class="wp-block-heading" id="aioseo-summary">Summary</h2>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>This has been yet another article that I planned to be much shorter, and then somehow exploded into this massive write-up that took about 2 months to finish. But I felt it was necessary to cover all aspects of parallel computing, including some code examples, to give you a flavour for how to deal with parallel computing, as well as to demonstrate some of its restrictions and bottlenecks.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In a nutshell, in an age in which processor speeds no longer double every 24 months according to Moore's law, but rather, the number of compute resources doubles every 24 months or so, we need to make use of code parallelisation in order to make use of the ever-increasing amount of computational power.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We saw that there are essentially two approaches available, which can be classified into <em>shared memory</em> and <em>distributed memory</em> approaches. In shared memory approaches, all cores have access to the same physical memory (RAM), and so all cores can simultaneously read and write data to memory. This makes parallelisation straightforward, and typically this approach is a good starting point when learning about parallel computations. OpenMP is the classic example of shared memory.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Distributed memory, on the other hand, assumes that each core gets its own private memory space that only it can read and write to and from. This means that if other cores need to have some data from surrounding processors, they have to send a request for data to be sent before they can use it. This approach means that it doesn't matter if the memory is located on the same physical memory (RAM) or somewhere else on a different compute node; data can always be sent via the network.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>MPI is the typical example of a distributed memory approach and the de facto standard in parallel computing, at least for CFD applications. Another player on the block, CUDA, targeting NVIDIA GPUs for parallel computations, promises fast code execution, which typically performs much better than CPU-based parallelisation (often providing speed-ups an order of magnitude better than the same code parallelised for CPUs).</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>While CUDA has become the standard in Machine Learning applications, where the training and inference of any Machine Learning model without the use of CUDA seems impossible these days, CFD applications have not yet caught up to using GPUs as much, due to the sheer memory requirements we have in CFD. This typically means that our simulations are too big to fit on GPUs in the first place, and thus, we can't utilise the resources, unless we invest in some heavy-duty GPUs, which are orders of magnitude more expensive than a CPU with some decent RAM.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>The parallelisation landscape is constantly changing, and what was the latest trend yesterday may as well be outdated tomorrow. One thing that seems to be standing strong in all of this, though, is MPI, and it is difficult to imagine a CFD future without a strong presence of MPI. Thus, if you want to become a proficient CFD coder, eventually you have to tackle MPI, which, as we have seen in the code examples I have provided, requires quite a bit of code manipulation to parallelise it.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>One thing is for sure: parallelisation is such an important topic in CFD that without it, we can't be expected to do any serious CFD simulations, unless we are working on 1D research codes, for example, to improve methodologies. In that case, we may get away without using parallelisation of any form, but eventually, we need to face the music and learn MPI (or CUDA, or OpenMP), if we target to work in the field of CFD, specifically writing code, not necessarily just running simulations.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We have also come across some of the current challenges with parallelisations, such as how to parallelise multigrids, dealing with adaptive mesh refinement, and dealing with exascale computing, which introduces completely new compute scales that challenge existing hardware and software.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>CFD is on an ever-evolving trajectory, and parallelisation is just one part of it. However, I believe that across the last articles in this series, I have given you a thorough overview of key concepts in CFD, along with challenges, and sometimes some fun little side projects, of which the STUPID turbulence model probably is my favourite.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>It was developed on a hot summer day in South Korea (something like 45 degrees Celsius / 110 degrees Fahrenheit), without air conditioning and a neighbour playing about 3-4 notes on his guitar for about 6 hours. Perhaps you noticed the Korean influence on the model development ... What was torture back then, somehow survived as a fond memory.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In any case, this is the end for this series, but I have a few little fun projects planned for the near future, hopefully something for you to look forward to. Until then, I'll see you in the next article.</p>
<!-- /wp:paragraph -->
